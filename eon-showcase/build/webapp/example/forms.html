<template>
  <eon-anchor state="button" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card first-card">
  <h1>BUTTON</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-button-tmp', '.d-button-pg');">
    <div name="example">
      <eon-showcase-item title="Button">
        <eon-button theme="claro" value="Alert" onclick="alert('Hi! ^_^')" icon='<i class="vicon vicon-build"></i>'></eon-button>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-button value="Disabled" disabled="true"></eon-button>
      </eon-showcase-item>
    </div>
    <div name="showcase">
       <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-button-pg"></eon-showcase>
    </div>
  </eon-viewer>
  <script>
    loadNextSections();
  </script>
  
  <!-- Showcase content -->
  <template class="d-button-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-button"] = "eon/ui/eon-button/";
        eon.registry.registerTheme("eon-button", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-button", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-button-config">
        <template>
  <div class="eon-button-button eon-bg2-border eon-bg2-hoverable eon-fg2 eon-fg2-hoverable eon-unselectable"></div>
</template>

<!-- <script data-src="eon-button.js"></script> -->

<script>
  eon.element({

    name: "eon-button",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} label 
        @description Button text
      */
      label: {
        value: "",
        reflect: true
      },
      /*
        @property {String} value 
        @description Button text
      */
      value: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} disabled 
        @description Button deactivation
        Values can be: true o false
        Default: false
      */
      disabled: {
        value: false,
        reflect: true
      },
      /*
        @property {String} type 
        @description Only indicate for submit buttons
        Values can be: submit or valueless
        Default: valueless
      */
      type: {
        value: "",
        reflect: true
      },
      /*
       @property {Boolean} inline 
       @description Space that occupy the button inside parent container.
       By default, its size adapts to its content
       Values can be: true or false
       Default: true
     */
      inline: {
        value: true,
        reflect: true,
        reflectDefault: true
      },
      /*
        @property {String} icon 
        @description Button icon
      */
      icon: {
        value: "",
        reflect: true
      },
      /*
        @property {String} iconPosition 
        @description Button icon position with respect text
        Values can be: left or right
        Default: left
      */
      iconPosition: {
        value: "left",
        reflect: true
      },
      vicon: {
        value: "",
        reflect: true
      }
    },

    functions: {
      /*
        @function setOnClick
        @description Set onclick attribute
        @param {String} functionality [Button onclick functionality]
      */
      setOnClick: function (functionality) {

        this.setAttribute("onclick", functionality);
      },

    },

    privateFunctions: {
      /*
        @function (private) _setLabel
        @description Set new button text
        @param {String} newVal [New button text]
      */
      setLabel: function () {
        var el = this;
        var button = el.querySelector(".eon-button-button");
        var buttonText = document.createElement("div");

        var label = el.label || (el.label && el.value) ? el.label : el.value;

        if (label) {
          // First time the button text is added
          if (!el.hasAttribute("text")) {

            buttonText.innerHTML = label;
            button.appendChild(buttonText);
            buttonText.classList.add("eon-button-buttonText");

            // When the button text is dynamically changed
          } else {
            var oldText = button.querySelector(".eon-button-buttonText");

            if (!oldText) {
              buttonText.innerHTML = label;
              button.appendChild(buttonText);
              buttonText.classList.add("eon-button-buttonText");

            } else {
              buttonText.innerHTML = label;
              var newText = buttonText;
              newText.classList.add("eon-button-buttonText");
              button.replaceChild(newText, oldText);
            }

          }

        }

        // When the button has no text is added an attribute
        // so if the button has icon it will be placed centered
        (!label) ? el.setAttribute("text", "false") : el.setAttribute("text", "true");
      },
      /*
        @function (private) _setupIcon
        @description Set new button icon
        @param {String} newVal [New button icon]
      */
      setupIcon: function () {
        var el = this;

        if (el.vicon) {

          var button = el.querySelector(".eon-button-button");
          var vicon = document.createElement("i");
          vicon.classList.add("vicon", el.vicon, "eon-button-buttonIcon");
          button.appendChild(vicon);

        } else if (el.icon) {
          var button = el.querySelector(".eon-button-button");
          var iconAttribute = el.icon;
          var icon;

          // When change the icon dynamically is necessary delete old icon
          if (button.classList.contains("eon-button-addedIcon")) {
            var oldIcon = el.querySelector(".eon-button-buttonIcon");

            button.removeChild(oldIcon);
          }

          if (iconAttribute.indexOf("</i>") !== -1) {
            var tempDiv = document.createElement("div");

            tempDiv.innerHTML = iconAttribute;
            icon = tempDiv.querySelector("i");
            icon.classList.add("eon-button-buttonIcon");

          } else {
            icon = document.createElement("div");
            icon.style.backgroundImage = "url('" + iconAttribute + "')";
            icon.classList.add("eon-button-buttonIcon");
          }

          button.appendChild(icon);
          button.classList.add("eon-button-addedIcon");
        }
      },

      /*
        @function (private) _updateDisabled
        @description Update disabled status
        @param {String} newVal [New value of disabled]
      */
      updateDisabled: function () {
        var button = this.querySelector(".eon-button-button");

        if (!eon.util.isTrue(this.disabled)) {
          button.removeAttribute("disabled");
          button.classList.remove("eon-fg2-disabled");
          this.style.pointerEvents = "auto";

        } else {

          button.setAttribute("disabled", "true");
          button.classList.add("eon-fg2-disabled");
          this.style.pointerEvents = "none";

        }
      }
    },

    onRender: function () {
      var el = this;
      var button = el.querySelector(".eon-button-button");

      el._setLabel();
      el._updateDisabled();
      el._setupIcon(el.icon);
      // When the button is a type form submit
      (el.type) ? button.setAttribute("type", el.type) : null;

      el.setAttribute("icon-position", el.iconPosition);

    },

    onPropertyChanged: function (attrName, oldVal, newVal) {
      switch (attrName) {
        case "disabled":
          this._updateDisabled();
          break;
        case "icon":
          this._setupIcon();
          break;
        case "label":
          this._setLabel();
          break;
        case "value":
          this._setLabel();
          break;
      }
    }
  });
</script>
        <style>
          eon-button[inline="true"] {
  display: inline-block;
}
eon-button[inline="true"] .eon-button-button {
  width: auto;
}
eon-button[icon-position="left"] .eon-button-button {
  flex-direction: row-reverse;
}
eon-button[icon-position="left"] .eon-button-buttonIcon {
  margin-right: 5px;
}
eon-button[icon-position="right"] .eon-button-button {
  flex-direction: row;
}
eon-button[icon-position="right"] .eon-button-buttonIcon {
  margin-left: 5px;
  flex-direction: row;
}
eon-button[text="false"] .eon-button-buttonIcon {
  margin-right: 0;
  margin-left: 0;
}
eon-button[text="false"] .eon-button-button {
  padding: 16px 5px;
}
eon-button[icon-position="left"][text="true"] .eon-button-addedIcon {
  padding-left: 10px;
}
eon-button[icon-position="right"][text="true"] .eon-button-addedIcon {
  padding-right: 10px;
}
.eon-button-button {
  font-weight: bold;
  position: relative;
  display: flex;
  width: 100%;
  box-sizing: border-box;
  height: 30px;
  padding: 16px;
  cursor: pointer;
  -webkit-transition: background-color ease 0.5s;
  -moz-transition: background-color ease 0.5s;
  transition: background-color ease 0.5s;
  border-width: 3px;
  border-style: solid;
  align-items: center;
  justify-content: center;
}
.eon-button-buttonIcon {
  font-size: 22px;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-button[theme="claro"] .eon-button-button,
div[data-theme="claro"] eon-button .eon-button-button,
body[data-theme="claro"] eon-button .eon-button-button {
  transition: background-color ease 0.5s, color ease 0.2s;
}
        </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Button">
        <eon-button theme="claro" value="Alert" onclick="alert('Hi! ^_^')" icon='<i class="vicon vicon-build"></i>'></eon-button>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-button value="Disabled" disabled="true"></eon-button>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //** 
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="checkbox" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>CHECKBOX</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-checkbox-tmp', '.d-checkbox-pg');">
    <div name="example">
      <eon-showcase-item title="Checkbox">
        <eon-checkbox label="Option 1" name="options" value="option 1" checked="true"></eon-checkbox>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-checkbox label="Option 2" checked="true" name="options" value="option 2" disabled="true"></eon-checkbox>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-checkbox-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-checkbox-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-checkbox"] = "eon/ui/eon-checkbox/";
        eon.registry.registerTheme("eon-checkbox", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-checkbox", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-checkbox-config">
        <template>
    <div class="eon-checkbox-checkbox">
        <input class="eon-checkbox-input" type="checkbox">
        <label class="eon-checkbox-label eon-fg2 eon-unselectable">
            <div class="eon-checkbox-labelText"></div>
        </label>
    </div>
</template>

<script>
    eon.element({

        name: "eon-checkbox",
        style: "",

        themed: true,

        properties: {
            /*
              @property {String} name 
              @description Checkbox name for the form functionality
            */
            name: {
                value: "",
                reflect: true
            },
            /*
              @property {String} value 
              @description Checkbox value for the form functionality
            */
            value: {
                value: "",
                reflect: true
            },
            /*
              @property {String} label 
              @description Checkbox label
            */
            label: {
                value: "",
                reflect: true
            },
            /*
              @property {Boolean} disabled 
              @description Checkbox deactivation
              Values can be: true or false
              Default: false
            */
            disabled: {
                value: false,
                reflect: true
            },
            /*
              @property {Boolean} readonly 
              @description Toggles the readonly status of the checkbox
              Default: false
            */
            readonly: {
                value: false,
                reflect: true
            },
            /*
              @property {Boolean} checked 
              @description Checkbox checked status
              Values can be: true or false
            */
            checked: {
                value: "",
                reflect: true
            },
            /*
            @property {Boolean} default
            @description Sets checked status by default when the element is reset
            Values can be: true or false
            */
            default: {
                value: "",
                reflect: true
            },
            /*
             @property {Boolean} inline 
             @description Space that occupy the checkbox inside parent container.
             By default, its size adapts to its content
             Values can be: true or false
             Default: true
           */
            inline: {
                value: true,
                reflect: true
            },
        },

        privateProperties: {
            /*
              @property (private) {String} _formElement 
              @description Set that  checkbox is a form element
              Value: checkbox
            */
            formElement: {
                value: "checkbox"
            },
            /*
              @property (private) {Object} _currentValue
              @description Current checkbox value
           */
            currentValue: {
                value: ""
            },
            /*
              @property (private) {Object} _refs 
              @description Object with  references
            */
            refs: {
                value: {}
            }
        },
        functions: {
            /*
            @function clear
            @description Unchecks the element
            */
            clear: function () {
                this.checked = false;
            },
            /*
            @function reset
            @description Resets checked status of the element to the default one
            */
            reset: function () {
                var el = this;
               
                if (eon.util.isTrue(el.default)) {
                    el.checked = el.default;
                } else {
                    el.clear();
                }

            }
        },

        privateFunctions: {
            /*
              @function (private) _setValue
              @description Set new checkbox value
              @param {String} newVal [New checkbox value]
            */
            setValue: function () {
                this._currentValue = this.value;
                eon.triggerCallback("onChange", this);

            },
            /*
              @function (private) _updateDisabled
              @description Update disabled status
            */
            updateDisabled: function () {
                var el = this;

                if (!eon.util.isTrue(el.disabled)) {
                    el._refs.input.removeAttribute("disabled");
                    // For Edge bug (not solved yet): when enable o disable an input dynamically,
                    // it is not automatically associated with the corresponding css,
                    // so is necessary to add a css property to activate the process
                    el._refs.label.style.visibility = (navigator.userAgent.indexOf("Edge") != -1) ? "inherit" : el._refs.label.style.visibility;
                    el._refs.span.style.visibility = (navigator.userAgent.indexOf("Edge") != -1) ? "inherit" : el._refs.span.style.visibility;

                } else {
                    el._refs.input.setAttribute("disabled", "true");

                    el._refs.label.style.visibility = (navigator.userAgent.indexOf("Edge") != -1) ? "visible" : el._refs.label.style.visibility;
                    el._refs.span.style.visibility = (navigator.userAgent.indexOf("Edge") != -1) ? "visible" : el._refs.span.style.visibility;

                }
            },

            /*
            @function (private) _updateReadonly
            @description Updates readonly status
            */
            updateReadonly: function () {
                var el = this;

                if (eon.util.isTrue(el.readonly)) {
                    el._refs.input.setAttribute("readonly", "true");
                } else {
                    el._refs.input.removeAttribute("readonly");
                }

            },

            /* 
              @function (private) _updateCheck
              @description Update checked status
              @param {String} oldVal [Old value]
            */
            updateCheck: function (oldVal) {
                var el = this;

                if (!eon.util.isTrue(el.checked)) {
                    el._refs.input.checked = false;
                    el._refs.input.removeAttribute("checked");
                    el._refs.input.classList.remove("eon-checkbox-checked");

                    if (eon.util.isTrue(oldVal)) {
                        eon.triggerCallback("onUncheck", el);
                    }

                } else {
                    el._refs.input.checked = true;
                    el._refs.input.setAttribute("checked", "true");
                    // Required for set style correctly when checkbox is checked and disabled
                    el._refs.input.classList.add("eon-checkbox-checked");
                    eon.triggerCallback("onCheck", el);
                }

            },

            /*
              @function (private) _createRefs
              @description Creates fast access to elements
            */
            createRefs: function () {
                var el = this;

                el._refs.checkbox = el.template.querySelector(".eon-checkbox-checkbox");
                el._refs.input = el.template.querySelector(".eon-checkbox-input");
                el._refs.label = el.template.querySelector(".eon-checkbox-label");
                el._refs.labelText = el.template.querySelector(".eon-checkbox-labelText");
                el._refs.span = document.createElement("span");
            }
        },

        onCreated: function () {
            eon.createCallback("onChange", this);
            eon.createCallback("onCheck", this);
            eon.createCallback("onUncheck", this);

            this._createRefs();
        },

        onRender: function () {
            var el = this;

            el._refs.label.insertBefore(el._refs.span, el._refs.label.firstChild);
            el._refs.span.classList.add("eon-checkbox-span", "eon-bg2-border");
            el._currentValue = el.value;
            el._refs.labelText.innerHTML = el.label;
            el.checked = el.default != "" && el.checked == "" ? el.default : el.checked;
            
            // Checking or unchecking the checkbox
            el._refs.label.addEventListener("click", function (e) {
                // The click event is triggered by two elements, the real input and the
                // visual custom element. So it is necessary to control one of the two elements
                // fot not activate the action twice.
                if (!eon.util.isTrue(el.disabled) && !eon.util.isTrue(el.readonly) && e.target.type !== "checkbox") {
                    el.checked = eon.util.isTrue(el.checked) ? false : true;
                }

            }, false);

            el._updateDisabled();
            el._updateReadonly();
            el._updateCheck();

        },

        onPropertyChanged: function (attrName, oldVal, newVal) {
            switch (attrName) {
                case "disabled":
                    this._updateDisabled();
                    break;
                case "readonly":
                    this._updateReadonly();
                    break;
                case "checked":
                    this._updateCheck(oldVal);
                    break;
                case "label":
                    this._refs.labelText.innerHTML = newVal;
                    break;
                case "value":
                    this._setValue();
                    break;
            }
        }
    });

</script>
        <style>
          eon-checkbox {
  position: relative;
}
eon-checkbox[inline="true"] {
  display: inline-block;
}
eon-checkbox[inline="true"] .eon-checkbox-checkbox {
  width: auto;
}
eon-checkbox[readonly="false"] .eon-checkbox-label {
  cursor: pointer;
}
.eon-checkbox-checkbox {
  width: 100%;
  display: flex;
}
.eon-checkbox-input[type="checkbox"] {
  display: none;
}
.eon-checkbox-label {
  display: flex;
  align-items: center;
}
.eon-checkbox-input[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span {
  box-sizing: border-box;
  width: 18px;
  height: 18px;
  margin: -2px 5px 0 0;
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
  vertical-align: middle;
  border-width: 2px;
  border-style: solid;
  border-radius: 2px;
  background-color: transparent;
}
.eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after {
  position: absolute;
  top: 4px;
  left: 3px;
  width: 10px;
  height: 5px;
  content: "";
  transform: rotate(-45deg);
}
.eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span {
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
  background-color: #18c796;
}
.eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label .eon-checkbox-span {
  cursor: auto;
}
.eon-checkbox-input:disabled + .eon-checkbox-label,
.checkbox[type="checkbox"]:disabled + .eon-checkbox-label .eon-checkbox-span,
.eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label:after {
  cursor: auto;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-checkbox[theme="claro"],
div[data-theme="claro"] eon-checkbox,
body[data-theme="claro"] eon-checkbox {
  /* Create the tick inside the checkbox */
  /* Style of the box when the checkbox it's disabled */
  /* Box style when the checkbox it's checked and disabled */
}
eon-checkbox[theme="claro"] .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after,
div[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after,
body[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after {
  border: 2px solid #ffffff;
  border-top: none;
  border-right: none;
  background: transparent;
}
eon-checkbox[theme="claro"] .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span,
div[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span,
body[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span {
  background-color: #ffffff;
}
eon-checkbox[theme="claro"] .eon-checkbox-input[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span,
div[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span,
body[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"] + .eon-checkbox-label .eon-checkbox-span {
  background-color: #ffffff;
}
eon-checkbox[theme="claro"] .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after,
div[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after,
body[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"] + .eon-checkbox-label:after {
  border-color: #47cce2;
}
eon-checkbox[theme="claro"] .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label span,
div[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label span,
body[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label span {
  border: 2px solid #cecece;
}
eon-checkbox[theme="claro"] .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label span,
div[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label span,
body[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label span {
  border: 2px solid #cecece;
  background-color: transparent;
}
eon-checkbox[theme="claro"] .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label:after,
div[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label:after,
body[data-theme="claro"] eon-checkbox .eon-checkbox-checked[type="checkbox"]:disabled + .eon-checkbox-label:after {
  border-color: #cecece;
}
eon-checkbox[theme="claro"] .eon-checkbox-input:disabled + .eon-checkbox-label,
div[data-theme="claro"] eon-checkbox .eon-checkbox-input:disabled + .eon-checkbox-label,
body[data-theme="claro"] eon-checkbox .eon-checkbox-input:disabled + .eon-checkbox-label,
eon-checkbox[theme="claro"] .checkbox[type="checkbox"]:disabled + .eon-checkbox-label span,
div[data-theme="claro"] eon-checkbox .checkbox[type="checkbox"]:disabled + .eon-checkbox-label span,
body[data-theme="claro"] eon-checkbox .checkbox[type="checkbox"]:disabled + .eon-checkbox-label span,
eon-checkbox[theme="claro"] .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label:after,
div[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label:after,
body[data-theme="claro"] eon-checkbox .eon-checkbox-input[type="checkbox"]:disabled + .eon-checkbox-label:after {
  color: #cecece;
}
        </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Checkbox">
        <eon-checkbox label="Option 1" name="options" value="option 1" checked="true"></eon-checkbox>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-checkbox label="Option 2" checked="true" name="options" value="option 2" disabled="true"></eon-checkbox>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      /* -- Shared cross-examples -- */
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="combobox" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>COMBOBOX</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-combobox-tmp', '.d-combobox-pg');">
    <div name="example">
      <eon-showcase-item title="Search filter">
        <eon-combobox label="Colors" placeholder="Select an item" filter="true">
          <eon-item value="red" display-value="Red"></eon-item>
          <eon-item value="green" display-value="Green"></eon-item>
          <eon-item value="pink" display-value="Pink"></eon-item>
          <eon-item value="grey" display-value="Grey"></eon-item>
        </eon-combobox>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-combobox disabled="true" label="States" name="comboTest2" placeholder="Ohio">
          <eon-item value="tomato" display-value="Tomato"></eon-item>
          <eon-item value="avocado" display-value="Avocado"></eon-item>
          <eon-item value="strawberry" display-value="Strawberry"></eon-item>
          <eon-item value="onion" display-value="Onion"></eon-item>
        </eon-combobox>
      </eon-showcase-item>
      <div class="d-combobox-placeholder"></div>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-combobox-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-combobox-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        .d-combobox-placeholder {
          height: 200px;
          width: 100%;
        }

        eon-showcase-item {
          height: 120px;
        }

        @media (max-width: 800px) {
          .d-combobox-placeholder {
            height: 0;
          }
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-combobox"] = "eon/ui/eon-combobox/";
        eon.registry.registerTheme("eon-combobox", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-combobox", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-combobox-config">
        <template>

    <div class="eon-combobox-data eon-fg2">
        <label class="eon-combobox-label"></label>
    </div>

    <div class="eon-combobox-main eon-fg2">

        <div class="eon-combobox-wrapper eon-bg2">
            <div class="eon-combobox-input">
                <input type="text" class="eon-fg2">
            </div>
            <i class="eon-combobox-dropButton eon-fg2-hoverable eon-unselectable vicon vicon-chevron-down"></i>
        </div>

        <span class="eon-combobox-underline"></span>

    </div>

    <div class="eon-combobox-dropdown eon-fg2 eon-sect1 eon-boxshadow2 hidden"></div>

    <div class="eon-combobox-description"></div>

</template>

<script type="text/javascript">
    eon.element({

        name: "eon-combobox",
        style: "",

        themed: true,

        dependencies: [
            "../eon-overlay",
            "../eon-scroll",
            "../eon-item"
        ],

        privateProperties: {
            /*
            @property (private) {string} _formElement 
            @description Necessary property for a form
            */
            formElement: {
                value: "combobox"
            },
            /*
            @property {object} _refs
            @description Object with references to relevant element nodes
            */
            refs: {
                value: {},
                reflect: false
            },
            /*
            @property (private) {Object} _misc
            @description Object with useful information
            */
            misc: {
                value: {},
                reflect: false
            },
        },

        properties: {
            /*
            @property {string} name
            @description Name of the combobox
            */
            name: {
                value: "",
                reflect: true
            },
            /*
            @property {string} filter
            @description Whether the input will be enabled to filter the dropdown options
            */
            filter: {
                value: "false",
                reflect: true,
                reflectDefault: true
            },
            /*
            @property {string} placeholder
            @description Sets the placeholder for the input
            */
            placeholder: {
                value: "",
                reflect: true
            },
            /*
            @property {string} label
            @description Sets the placeholder for the input
            */
            label: {
                value: "",
                reflect: true,
                reflectDefault: true
            },
            /*
            @property {string} displayProperty
            @description Property that will be used to get the displayValue in case a store has been provided
            */
            displayProperty: {
                value: "",
                reflect: true
            },
            /*
            @property {string} value
            @description The value of the dropdown
            */
            value: {
                value: "",
                reflect: true
            },
            /*
            @property {string} displayValue
            @description The displayValue of the item
            */
            displayValue: {
                value: "",
                reflect: true
            },
            /*
            @property {String} default
            @description Value of the element when the element is reseted, if will also be the value of the element if no value is provided
            */
            default: {
                value: "",
                reflect: true
            },
            /*
            @property {Boolean} inline 
            @description Space that occupies the button inside its parent container.
            */
            inline: {
                value: true,
                reflect: true,
                reflectDefault: true
            },
            /*
            @property {string} readonly
            @description Toggles the readonly status of the element
            */
            readonly: {
                value: false,
                reflect: true
            },
            /*
            @property {String} disabled
            @description Toggles the disabled status of the element
            */
            disabled: {
                value: false,
                reflect: true
            },
            /*
            @property {String} tooltip
            @description Text to be shown for the element
            */
            tooltip: {
                value: "",
                reflect: true,
                reflectDefault: false
            },
            /*
            @property {Boolean} invalid
            @description Whether the element meets the requirements or not
            */
            invalid: {
                value: false,
                reflect: true,
                reflectDefault: false
            },
            /*
            @property {Boolean} ** New store: store
            @description 
            */
            store: {
                value: false,
                reflect: true
            }
        },

        privateFunctions: {
            /*
            @function setupRefs
            @description Creates some fast access elements so that theres no need for calling the QuerySelector all the time.
            */
            setupRefs: function () {

                var el = this;

                el._refs.main = el.template.querySelector(".eon-combobox-main");
                el._refs.input = el.template.querySelector("input");
                el._refs.dropDown = el.template.querySelector(".eon-combobox-dropdown");
                el._refs.dropDownButton = el.template.querySelector(".eon-combobox-dropButton");

                el._refs.underline = el.template.querySelector(".eon-combobox-underline");

                el._refs.data = el.template.querySelector(".eon-combobox-data");
                el._refs.label = el.template.querySelector(".eon-combobox-label");

                el._refs.description = el.template.querySelector(".eon-combobox-description");

            },
            /*
            @function _setupDropdown
            @description Prepares the dropdown to hold the items
            */
            setupDropdown: function () {

                var el = this;

                el._refs.scroll = document.createElement("eon-scroll");

                el._refs.scroll.thickness = 8;
                el._refs.scroll.fill = false;
                el._refs.scroll.autoGrowth = true;
                el._refs.scroll.type = "vertical";

                // If the dropdown has now scroll we do not want to close the overlay if the user attempts to scroll
                // so we prevent scrolling events, otherwise just stops the propagations
                el._refs.scroll.content.addEventListener("wheel", function (e) {

                    if (el._refs.scroll._getVerticalScrollableSize() == 0) {
                        e.preventDefault();
                    }

                    e.stopPropagation();
                    return false;

                });

                el._refs.dropDown.appendChild(el._refs.scroll);

                if (eon.util.isTrue(el.filter)) {

                    var modalInputWrapper = document.createElement("div");

                    modalInputWrapper.classList.add("eon-combobox-modalFilter", "eon-bg8");

                    el._refs.modalInput = document.createElement("input");

                    el._refs.modalInput.classList.add("eon-fg2");
                    el._refs.modalInput.placeholder = el.placeholder != "" ? el.placeholder : "Filter";

                    el._refs.modalInput.addEventListener('focus', function (e) {
                        // When the device modal input is focused, it shows the keyboard, this keyboard triggers onWindowResize, 
                        // since onWindowResize we want to hide the dropdown this variable helps us know
                        //  if the resize event was triggered by the input or the window manually resizing
                        el._misc.modal.inputFocus = true;
                    }, false);

                    el._refs.modalInput.addEventListener('blur', function (e) {
                        el._misc.modal.inputFocus = false;
                    }, false);

                    el._refs.modalInput.addEventListener("keyup", function (e) {
                        el._filter();
                    });

                    modalInputWrapper.appendChild(el._refs.modalInput);
                    el._refs.dropDown.insertBefore(modalInputWrapper, el._refs.dropDown.childNodes[0]);
                }

            },
            /*
            @function _setupType
            @description Depending on user specifications we will prepare the element
            */
            setupStore: function () {

                var el = this;

                // ** New store
                el.store = eon.util.isTrue(el.store) ? new eon.store() : "";

            },
            /*
            @function _setupType
            @description Depending on user specifications we will prepare the element
            */
            setupType: function () {

                var el = this;

                if (!eon.util.isTrue(el.filter)) {

                    el._refs.main.classList.add("eon-fg1-hoverable");
                    el._refs.main.querySelector("input").addEventListener("touchstart", function (e) {
                        e.stopPropagation();
                    });

                } else {

                    el._refs.input.addEventListener("blur", function () {

                        if (!el.isOnPath && !el._refs.dropDown.isOnPath) {
                            // When blur occurs and no item has been selected when clear the input
                            if (el.value == "") {
                                el._refs.input.value = "";
                            }
                        }

                    });

                    el._refs.input.addEventListener("focus", function (e) {
                        el.expand();
                        el._refs.modalInput.focus();
                    });

                    el._refs.input.addEventListener("keyup", function (e) {
                        el._filter();
                    });

                }

                // This listener is meant for devices, it does not matter where the user touches we will open de dropdown
                if (window.innerWidth <= eon.tabletWidth) {

                    el._refs.main.querySelector("input").addEventListener("touchstart", function (e) {
                        e.stopPropagation();
                    });

                    el.addEventListener("click", function (e) {

                        e.stopPropagation();
                        e.preventDefault();
                        el.expand();

                        if (eon.util.isTrue(el.filter)) {
                            el._refs.modalInput.focus();
                        }

                    });

                }

            },
            /*
            @function _setupMisc
            @description Sets up the listener to the click events
            */
            setupMisc: function () {

                var el = this;

                el._misc.modal = {};
                el._misc.items = {};
                el._misc.descriptionText = "";

            },
            /*
            @function (private) {String} _setupDescription
            @description Creates the touch blur
            */
            setupDescription: function () {

                var el = this;

                if (el.tooltip != "") {
                    el.updateDescription(el.tooltip);
                }

            },
            /*
            @function setupTriggers
            @description Sets up the listener to the click events
            */
            setupTriggers: function () {

                var el = this;
                var clickTarget = eon.util.isTrue(el.filter) ? el._refs.dropDownButton : el._refs.main;

                clickTarget.addEventListener("click", function () {
                    el._toggleDropdown(el);
                });

                document.body.addEventListener("click", function (e) {
                    if (!el.isOnPath && !el._refs.dropDown.isOnPath && !el._refs.overlay.classList.contains("eon-combobox-device")) {
                        el._refs.input.blur();
                        el.shrink();
                    }
                });

            },
            /*
            @function setupAnimations
            @description Here we will setup the animations for the input
            */
            setupAnimations: function () {

                var el = this;

                el._refs.input.addEventListener("focus", function () {
                    el._refs.underline.classList.add("animate");
                });

                el._refs.input.addEventListener("blur", function () {
                    el._refs.underline.classList.remove("animate");
                });

            },
            /*
            @function (private) _setupOverlay
            @description Sets up basic properties for the data object
            */
            setupOverlay: function () {

                var el = this;

                var iOS = parseFloat(
                    ('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1])
                        .replace('undefined', '3_2').replace('_', '.').replace('_', '')
                ) || false;

                el._refs.overlay = el.generateOverlayNode();
                el._refs.overlay.classList.add("eon-combobox-overlay", "eon-bg1-modal");
                el._refs.overlay.appendChild(el._refs.dropDown);

                // Prevents scrolling on mobile devices
                el._refs.overlay.addEventListener("wheel", function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, { passive: false });

                // If the user manages the scroll we close the overlay
                window.addEventListener("scroll", function (e) {
                    if (el._misc.modal.active && !el._refs.overlay.classList.contains("eon-combobox-device")) {
                        el.shrink();
                    }
                });

                // This behavior is only supported on iOS 10 and beyond
                if (iOS && iOS >= 10) {

                    // Prevents scrolling on mobile devices
                    window.addEventListener("touchstart", function (e) {
                        if (el._misc.modal.active && el._refs.overlay.classList.contains("eon-combobox-device")) {
                            if (!el._refs.dropDown.isOnPath) {
                                e.preventDefault();
                                e.stopPropagation();
                                el._misc.modal.blur = true;
                            }
                        }
                    }, { passive: false });

                    // On touch end it blurs the modal dropdown
                    window.addEventListener("touchend", function (e) {
                        if (el._misc.modal.active && el._refs.overlay.classList.contains("eon-combobox-device") && el._misc.modal.blur) {
                            el._misc.modal.blur = false;
                            el.shrink();
                        }
                    });

                } else {

                    // On touch end it blurs the modal dropdown
                    window.addEventListener("touchend", function (e) {
                        if (el._misc.modal.active && el._refs.overlay.classList.contains("eon-combobox-device") && !el._refs.dropDown.isOnPath) {
                            el.shrink();
                        }
                    });

                }

            },
            /*
            @function setupItems
            @description Takes all the items and moves them
            */
            setupItems: function () {

                var el = this;

                // ** New store

                if (el.store) {

                    el.store.onLoaded(function () {

                        // Update items on data changed
                        el.store.onDataChanged(function () {
                            el._setupStoreItems(el);
                        });

                        el._setupStoreItems(el);

                    });

                } else {

                    var sourceNodes = this.getSourceElements();
                    var itemsDocFragment = document.createDocumentFragment();
                    var length = sourceNodes.length;
                    var item;

                    for (var i = 0; i < length; i++) {

                        item = sourceNodes[i];

                        el._setupItem(item);

                        el._misc.items[item.value] = item;

                        itemsDocFragment.appendChild(item);

                    }

                    el._refs.scroll.content.appendChild(itemsDocFragment);

                    el._initValue();

                }

            },
            /*
            @function setupItem
            @description Takes a single item, adds its events and assigns its properties
            */
            setupItem: function (item) {

                var el = this;

                item.onRender(function () {

                    var span = document.createElement("span");

                    this.classList.add("result", "eon-bg1-hoverable", "eon-fg1-hoverable");
                    this.dataset.matches = true;
                    this.value = this.getAttribute("value");
                    this.displayValue = this.getAttribute("display-value") || this.value;

                    span.innerHTML = this.displayValue;

                    this.appendChild(span);
                    this.addEventListener("click", function () {
                        el.select(this)
                    });
                    this.addEventListener("pointerdown", function (e) {
                        // Solves other eon elements bug related to blur event functionality
                        e.stopPropagation();
                    });

                });

            },
            /*
            @function setupStoreItems
            @description Here we setup our items depending on the store data
            */
            setupStoreItems: function () {

                var el = this;

                var dropdown = el._refs.dropDown;
                var itemsDocFragment = document.createDocumentFragment();
                var displayProperty = (el.displayProperty != "") ? el.displayProperty : el.store.idProperty;
                // ** New store
                var storeData = el.store.data;
                // ** var storeData = el._refs.store.data.asObject();
                var item;
                // ** New store
                storeData.forEach(function (value, key, map) {
                    item = document.createElement("eon-item");

                    item.classList.add("eon-bg1-hoverable", "eon-fg1-hoverable");
                    item.dataset.matches = true;
                    item.value = storeData.get(key)[el.store.idProperty];
                    item.displayValue = storeData.get(key)[displayProperty];

                    el._misc.items[item.value] = item;

                    el._misc.items[item.value].style.cursor = "pointer";

                    el._misc.items[item.value].onRender(function () {

                        var span = document.createElement("span");

                        span.innerHTML = this.displayValue;
                        this.appendChild(span);
                        this.addEventListener("click", function () { el.select(this) });
                    });

                    itemsDocFragment.appendChild(item);
                });

                el._refs.scroll.content.appendChild(itemsDocFragment);

                el._initValue();

            },
            /*
            @function (private) {String} _setupTouchBlur
            @description Creates the touch blur
            */
            setupTouchBlur: function () {

                var el = this;
                var blurTrigger = eon.util.isTouchScreen() ? "touchend" : "click";

                eon.registerPathListener(el);
                eon.registerPathListener(el._refs.dropDown);

                document.addEventListener(blurTrigger, function () {
                    if (!el.isOnPath && !el._refs.dropDown.isOnPath && !el._refs.overlay.classList.contains("eon-combobox-device")) {
                        el._refs.input.blur();
                        el.shrink();
                    }
                });

            },
            /*
            @function (private) _setupMatchingErrorItem
            @description Creates the touch blur
            */
            setupMatchingErrorItem: function () {

                var el = this;

                el._refs.matchingErrorItem = document.createElement("div");
                el._refs.matchingErrorItem.classList.add("eon-combobox-matchingError");
                el._refs.matchingErrorItem.innerHTML = "No matches found";

            },
            /*
            @function (private) _initDefault
            @description If a value has been provided by the user we set it for our element
            */
            initDefault: function () {
                this.value = this.default != "" && this.value == "" ? this.default : this.value;
            },
            /*
            @function (private) _initValue
            @description Sets the initial value depending if an item with the provided value exists
            */
            initValue: function () {

                var el = this;

                if (el.value != "" && el._misc.items.hasOwnProperty(el.value)) {
                    el.select(el._misc.items[el.value]);
                }

            },
            /*
            @function (private) _filter
            @description Takes the value of the input and filters the dropdown items
            */
            filter: function () {

                var el = this;

                el._filterItems();

                //Check if its already expanded, if its not then expand it
                if (el._refs.dropDown.classList.contains("hidden")) {
                    el.expand();
                }

                el._value = "";
                el.displayValue = "";

            },
            /*
            @function (private) _filterItems
            @description Loops through its items to filter the ones that match the value
            */
            filterItems: function () {

                var el = this;

                var items = el._refs.dropDown.querySelectorAll("eon-item");
                var value = el._misc.modal.inputFocus ? el._refs.modalInput.value.toLowerCase() : el._refs.input.value.toLowerCase();

                //Loop to find matches and hide those that do not match
                for (var i = 0; i < items.length; i++) {

                    if (!items[i].hasAttribute("display-value") || !(items[i].hasAttribute("display-value") && items[i].getAttribute("display-value").toLowerCase().match("^" + value))) {

                        if (!items[i].classList.contains("hidden")) {
                            items[i].classList.add("hidden");
                            items[i].dataset.matches = false;

                        }

                    } else {

                        if (items[i].classList.contains("hidden")) {
                            items[i].classList.remove("hidden");
                            items[i].dataset.matches = true;
                        }

                    }

                }

                var matchedItems = el._refs.dropDown.querySelectorAll('[data-matches="true"]');

                if (matchedItems.length == 0) {

                    el._showMatchingError();

                } else {

                    el._hideMatchingError();

                }

            },
            /*
            @function (private) _undoFilter
            @description Shows all the previously filtered items
            */
            undoFilter: function () {

                var el = this;
                var hiddenItems = el._refs.dropDown.querySelectorAll('[data-matches="false"]');

                for (var i = 0; i < hiddenItems.length; i++) {
                    hiddenItems[i].dataset.matches = true;
                    hiddenItems[i].classList.remove("hidden");
                }

                el._hideMatchingError();

                // We set the modalInput value to empty in case its been used to filter
                if (el._refs.modalInput) {
                    el._refs.modalInput.value = "";
                }

            },
            /*
            @function (private) _showMatchingError
            @description Shows matching error on the dropdown
            */
            showMatchingError: function () {

                var el = this;

                el._refs.scroll.content.appendChild(el._refs.matchingErrorItem);
                el.invalid = true;

            },
            /*
            @function (private) _hideMatchingError
            @description Hides matching error on the dropdown
            */
            hideMatchingError: function () {

                var el = this;

                if (el._refs.matchingErrorItem.parentNode) {

                    el._refs.matchingErrorItem.parentNode.removeChild(el._refs.matchingErrorItem);
                    el.invalid = false;

                }

            },
            /*
            @function toggleDropdown
            @description Toggles the dropdown when clicking on the dropdown button
            */
            toggleDropdown: function () {

                var el = this;

                if (!el._refs.dropDown.classList.contains("hidden")) {
                    // el.shrink();
                } else {
                    el.expand();
                }
            },
            /*
            @function (private) _assignDropdownStyle
            @description Assigns the dropdown's width and position relative to the datebox
            */
            assignDropdownStyle: function () {

                var el = this;

                if (window.innerWidth <= eon.tabletWidth) {

                    if (!el._refs.overlay.classList.contains("eon-combobox-device")) {

                        el._refs.dropDown.style.top = "auto";
                        el._refs.dropDown.style.left = "auto";

                        el._refs.overlay.classList.add("eon-combobox-device");
                        el._refs.overlay.classList.add("eon-bg1-modal");

                    }

                } else {

                    el._refs.overlay.classList.remove("eon-combobox-device");
                    el._refs.overlay.classList.remove("eon-bg1-modal");

                    el._refs.dropDown.style.top = el._refs.main.getBoundingClientRect().top + el._refs.main.offsetHeight + 1 + "px";
                    el._refs.dropDown.style.left = el._refs.main.getBoundingClientRect().left + "px";
                    el._refs.dropDown.style.width = el._refs.main.offsetWidth + "px";

                }

            },
            /*
            @function (private) _updateLabel
            @description Updates the label node with the new label
            */
            updateLabel: function () {

                var el = this;

                if (el.label != "") {
                    el._refs.label.innerHTML = el.label;
                }

            },
            /*
            @function (private) _updateDisabled
            @description Updates disabled status
            */
            updateDisabled: function () {

                var el = this;
                var typingNode = el.type == "area" ? el._refs.editableArea : el._refs.input;

                if (!eon.util.isTrue(el.disabled)) {

                    el._refs.input.classList.add("eon-fg2");
                    el._refs.input.classList.remove("eon-fg2-disabled");

                    el._refs.data.classList.remove("eon-fg2-disabled");
                    el._refs.main.classList.remove("eon-fg2-disabled");

                    el.removeAttribute("disabled");
                    el._refs.input.removeAttribute("disabled");

                } else {

                    el._refs.input.setAttribute("disabled", "true");

                    el._refs.input.classList.remove("eon-fg2");
                    el._refs.input.classList.add("eon-fg2-disabled");

                    el._refs.data.classList.add("eon-fg2-disabled");
                    el._refs.main.classList.add("eon-fg2-disabled");

                }
            },
            /*
            @function (private) _updateReadOnly
            @description Updates readonly status
            */
            updateReadOnly: function () {

                var el = this;

                if (!eon.util.isTrue(el.readonly) && eon.util.isTrue(el.filter)) {

                    el.removeAttribute("readonly");
                    el._refs.input.removeAttribute("readonly");
                    el._refs.input.classList.add("eon-unselectable");

                } else {

                    el._refs.input.setAttribute("readonly", "true");
                    el._refs.input.classList.remove("eon-unselectable");
                }

            },
            /*
            @function (private) _updateValue
            @description Updates the value
            */
            updateValue: function () {

                var el = this;
                var item = el._misc.items[el.value];
                if (item) {

                    var value = item.value;
                    var displayValue = item.displayValue;

                    el.displayValue = displayValue;

                    el._refs.input.value = item.displayValue;

                } else {

                    el._value = "";
                    el.displayValue = "";
                    el._refs.input.value = "";

                }

            },
            /*
            @function (private) _updateInvalid
            @description Updates the invalid status
            */
            updateInvalid: function () {

                var el = this;
                var classListFn = eon.util.isTrue(el.invalid) ? "add" : "remove";

                el.classList[classListFn]("eon-combobox-error");

            }

        },

        functions: {
            /*
            @function addItem
            @description Adding a new option item programmatically
            @param {object} item 
            */
            addItem: function (item) {

                var el = this;

                el._misc.items[item.value] = item;

                item.onRender(function () {
                    var span = document.createElement("span");
                    span.innerHTML = this.displayValue;
                    this.classList.add("result", "eon-bg1-hoverable", "eon-fg1-hoverable")
                    this.appendChild(span);
                    this.dataset.matches = true;
                    this.addEventListener("click", function () { el.select(this) });
                });

                el._refs.scroll.content.appendChild(item);
            },
            /*
            @function select
            @description Sets the item as the inputs value and hide the options div
            @param {object} item
            */
            select: function (item) {
                var el = this;

                var value = item.value;
                var displayValue = item.displayValue;

                el.value = value;
                el.displayValue = displayValue;

                el._refs.input.value = item.displayValue;

                eon.triggerCallback("onSelected", el, el, [item]);

                el.shrink();

            },
            /*
            @function expand
            @description Expands the items dropdown
            */
            expand: function () {

                var el = this;

                el._assignDropdownStyle();

                el._refs.scroll.scrollTop = 0;

                el._refs.dropDown.classList.remove("hidden");
                el._refs.underline.classList.add("animate");

                el.classList.add("focus");

                el._undoFilter();

                document.body.appendChild(el._refs.overlay);

                el._misc.modal.active = true;

            },
            /*
            @function shrink
            @description Shrinks the items dropdown
            */
            shrink: function () {

                var el = this;

                if (el.classList.contains("focus")) {

                    el.classList.remove("focus")

                    el._refs.dropDown.classList.add("hidden");
                    el._refs.underline.classList.remove("animate");

                    if (el._refs.overlay.parentNode) {
                        el._refs.overlay.parentNode.removeChild(el._refs.overlay);
                    }

                    el._filterItems();

                    el._misc.modal.active = false;
                    el._misc.modal.inputFocus = false;

                }

            },
            /*
            @function clear
            @description Empties the value
            */
            clear: function () {
                this.value = "";
            },
            /*
            @function reset
            @description Resets the value of the element to the default one, if no default is provided then empties the value
            */
            reset: function () {

                var el = this;

                if (el.default != "") {
                    el.value = el.default;
                } else {
                    el.clear();
                }

            },
            /*
            @function updateDescription
            @description Updates the description value for the
            */
            updateDescription: function (text) {
                this._misc.descriptionText = text;
                this._refs.description.innerHTML = this._misc.descriptionText;
            },
            /*
            @function updateDescription
            @description Updates the description value for the
            */
            resetDescription: function () {

                var el = this;
                var description = el.tooltip != "" ? el.tooltip : "";

                el._misc.descriptionText = description;
                el._refs.description.innerHTML = description;

            }

        },

        onCreated: function () {

            var el = this;

            el._setupMisc();
            el._setupRefs();
            el._setupDropdown();

            eon.createCallback("onSelected", el);

        },

        onInit: function () {

            var el = this;

            var declarativePlaceholder = el.getAttribute("placeholder");

            el._setupStore();

            el._setupTriggers();
            el._setupAnimations();
            el._setupTouchBlur();
            el._setupMatchingErrorItem();

            el._setupDescription();

            el._updateLabel();
            el._updateDisabled();
            el._updateReadOnly();

            el._setupType();
            el._setupOverlay();

            el._initDefault();

            if (declarativePlaceholder) el._refs.input.placeholder = declarativePlaceholder;

        },

        onRender: function () {

            var el = this;

            el._setupItems();

        },

        onPropertyChanged: function (key, oldVal, newVal) {

            switch (key) {
                case "label":
                    this._updateLabel();
                    break;
                case "disabled":
                    this._updateDisabled();
                    break;
                case "readonly":
                    this._updateReadOnly();
                    break;
                case "value":
                    this._updateValue();
                    break;
                case "invalid":
                    this._updateInvalid();
                    break;
            }

        },
        onWindowResize: function () {

            var el = this;

            if (el._misc.modal.active && !el._misc.modal.inputFocus) {
                el.shrink();
            }

        }
    });
</script>
        <style>
          eon-combobox[inline="true"] {
  display: inline-block;
  width: 200px;
}
eon-combobox[label=""] .eon-combobox-data {
  display: none;
}
eon-combobox .eon-combobox-data {
  height: 18px;
  margin-bottom: 5px;
  flex-grow: 0;
  display: flex;
}
eon-combobox[label=""] .eon-combobox-data {
  display: none;
}
eon-combobox .eon-combobox-label {
  font-size: 15px;
  height: 100%;
  flex-grow: 1;
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
}
eon-combobox .eon-combobox-main {
  position: relative;
  display: flex;
  flex-direction: column;
  cursor: pointer;
  border: none;
  border-bottom-width: 1px;
  border-bottom-style: solid;
}
eon-combobox[filter="false"] input:hover {
  cursor: pointer;
}
eon-combobox .eon-combobox-wrapper {
  display: flex;
  flex-direction: row;
  align-items: center;
}
eon-combobox .eon-combobox-input {
  flex-grow: 1;
}
eon-combobox .eon-combobox-underline {
  position: relative;
  display: block;
  width: auto;
}
eon-combobox .eon-combobox-underline:before,
eon-combobox .eon-combobox-underline:after {
  position: absolute;
  bottom: 0;
  width: 0;
  top: 0;
  height: 2px;
  content: "";
  -webkit-transition: width 0.5s ease;
  -moz-transition: width 0.5s ease;
  transition: width 0.5s ease;
}
eon-combobox .eon-combobox-underline:before {
  left: 50%;
}
eon-combobox .eon-combobox-underline:after {
  right: 50%;
}
eon-combobox .eon-combobox-underline.animate:before,
eon-combobox .eon-combobox-underline.animate:after {
  width: 50%;
}
eon-combobox .eon-combobox-dropButton {
  flex-grow: 0;
  margin-right: 5px;
}
eon-combobox input {
  font-size: 15px;
  padding: 10px;
  border: 0;
  background-color: transparent;
  box-sizing: border-box;
  width: 100%;
}
eon-combobox input:focus {
  outline: none;
}
eon-combobox[disabled="true"],
eon-combobox[readonly="true"] {
  pointer-events: none;
}
.eon-combobox-dropdown {
  font-size: 16px;
  display: flex;
  flex-direction: column;
  position: absolute;
  max-height: calc(100% - 10%);
}
.eon-combobox-dropdown eon-scroll {
  flex-grow: 1;
}
.eon-combobox-dropdown .eon-combobox-modalFilter {
  box-sizing: border-box;
  padding: 0 20px;
  display: none;
}
.eon-combobox-dropdown .eon-combobox-modalFilter input {
  width: 100%;
  box-sizing: border-box;
  height: 50px;
  border: none;
  background: transparent;
  outline: none;
}
.eon-combobox-dropdown.hidden {
  display: none;
}
.eon-combobox-dropdown eon-item {
  display: flex;
  height: 50px;
  padding: 0 20px;
  text-decoration: none;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
}
.eon-combobox-dropdown eon-item.hidden {
  display: none;
}
.eon-combobox-dropdown eon-item:hover {
  cursor: pointer;
}
.eon-combobox-overlay {
  position: fixed;
  margin: 0;
  z-index: 100;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.eon-combobox-overlay.eon-combobox-device {
  display: flex;
  justify-content: center;
  align-items: center;
}
.eon-combobox-overlay.eon-combobox-device .eon-combobox-dropdown {
  width: 90%;
  max-width: 90%;
  min-width: 90%;
  position: relative;
}
.eon-combobox-overlay.eon-combobox-device .eon-combobox-modalFilter {
  display: block;
}
.eon-combobox-overlay.eon-combobox-device .eon-combobox-modalFilter input {
  font-size: 16px;
}
.eon-combobox-overlay.eon-combobox-device .eon-combobox-close {
  display: flex;
}
.eon-combobox-matchingError {
  display: block;
  padding: 12px 16px;
  text-decoration: none;
}
.eon-combobox-description {
  margin-top: 5px;
  font-size: 14px;
  width: 100%;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-combobox[theme="claro"],
eon-overlay[theme="claro"],
div[data-theme="claro"] eon-combobox,
body[data-theme="claro"] eon-combobox {
  /* - Chrome 56,
  - Safari 5-10.0
  - iOS Safari 4.2-10.2
  - Opera 15-43
  - Opera Mobile >12
  - Android Browser 2.1-4.4.4
  - Samsung Internet
  - UC Browser for Android
  - QQ Browser */
  /* Firefox 4-18 */
  /* Firefox 19-50 */
  /* - Internet Explorer 1011
  - Internet Explorer Mobile 10-11 */
}
eon-combobox[theme="claro"] ::-webkit-input-placeholder,
eon-overlay[theme="claro"] ::-webkit-input-placeholder,
div[data-theme="claro"] eon-combobox ::-webkit-input-placeholder,
body[data-theme="claro"] eon-combobox ::-webkit-input-placeholder {
  color: #9a9a9a;
}
eon-combobox[theme="claro"] :-moz-placeholder,
eon-overlay[theme="claro"] :-moz-placeholder,
div[data-theme="claro"] eon-combobox :-moz-placeholder,
body[data-theme="claro"] eon-combobox :-moz-placeholder {
  color: #9a9a9a;
}
eon-combobox[theme="claro"] ::-moz-placeholder,
eon-overlay[theme="claro"] ::-moz-placeholder,
div[data-theme="claro"] eon-combobox ::-moz-placeholder,
body[data-theme="claro"] eon-combobox ::-moz-placeholder {
  color: #9a9a9a;
}
eon-combobox[theme="claro"] :-ms-input-placeholder,
eon-overlay[theme="claro"] :-ms-input-placeholder,
div[data-theme="claro"] eon-combobox :-ms-input-placeholder,
body[data-theme="claro"] eon-combobox :-ms-input-placeholder {
  color: #9a9a9a !important;
}
eon-combobox[theme="claro"].focus .eon-combobox-label,
eon-overlay[theme="claro"].focus .eon-combobox-label,
div[data-theme="claro"] eon-combobox.focus .eon-combobox-label,
body[data-theme="claro"] eon-combobox.focus .eon-combobox-label {
  color: #47cce2;
}
eon-combobox[theme="claro"] .eon-combobox-underline:before,
eon-overlay[theme="claro"] .eon-combobox-underline:before,
div[data-theme="claro"] eon-combobox .eon-combobox-underline:before,
body[data-theme="claro"] eon-combobox .eon-combobox-underline:before,
eon-combobox[theme="claro"] .eon-combobox-underline:after,
eon-overlay[theme="claro"] .eon-combobox-underline:after,
div[data-theme="claro"] eon-combobox .eon-combobox-underline:after,
body[data-theme="claro"] eon-combobox .eon-combobox-underline:after {
  background: #47cce2;
}
eon-combobox[theme="claro"].eon-combobox-error .eon-combobox-label,
eon-overlay[theme="claro"].eon-combobox-error .eon-combobox-label,
div[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-label,
body[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-label,
eon-combobox[theme="claro"].eon-combobox-error .eon-combobox-description,
eon-overlay[theme="claro"].eon-combobox-error .eon-combobox-description,
div[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-description,
body[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-description {
  color: #c33232;
}
eon-combobox[theme="claro"].eon-combobox-error .eon-combobox-main,
eon-overlay[theme="claro"].eon-combobox-error .eon-combobox-main,
div[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-main,
body[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-main {
  border-bottom: 1px solid #c33232;
}
eon-combobox[theme="claro"].eon-combobox-error .eon-combobox-underline:before,
eon-overlay[theme="claro"].eon-combobox-error .eon-combobox-underline:before,
div[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-underline:before,
body[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-underline:before,
eon-combobox[theme="claro"].eon-combobox-error .eon-combobox-underline:after,
eon-overlay[theme="claro"].eon-combobox-error .eon-combobox-underline:after,
div[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-underline:after,
body[data-theme="claro"] eon-combobox.eon-combobox-error .eon-combobox-underline:after {
  background: #c33232;
}
        </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Search filter">
        <eon-combobox label="Colors" placeholder="Select an item" filter="true">
          <eon-item value="red" display-value="Red"></eon-item>
          <eon-item value="green" display-value="Green"></eon-item>
          <eon-item value="pink" display-value="Pink"></eon-item>
          <eon-item value="grey" display-value="Grey"></eon-item>
        </eon-combobox>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-combobox disabled="true" label="States" name="comboTest2" placeholder="Ohio">
          <eon-item value="tomato" display-value="Tomato"></eon-item>
          <eon-item value="avocado" display-value="Avocado"></eon-item>
          <eon-item value="strawberry" display-value="Strawberry"></eon-item>
          <eon-item value="onion" display-value="Onion"></eon-item>
        </eon-combobox>
      </eon-showcase-item>
      <div class="d-combobox-placeholder"></div>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="date" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>DATEBOX</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-date-tmp', '.d-date-pg');">
    <div name="example">
      <eon-showcase-item title="Date">
        <eon-date></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Days">
        <eon-date selectable="dmy" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Months">
        <eon-date selectable="my" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Years">
        <eon-date selectable="y" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <div class="d-date-placeholder"></div>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-date-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-date-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        .d-date-placeholder {
          height: 100px;
          width: 100%;
        }
        @media (max-width: 800px) {
          .d-date-placeholder {
            height: 0;
          }
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-date"] = "eon/ui/eon-date/";
        eon.registry.registerTheme("eon-date", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-date", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-date-config">
        <template>

  <!-- Default date input elements -->
  <div class="eon-date-data eon-fg1">
    <label class="eon-date-label"></label>
  </div>

  <div class="eon-date-main eon-bg2 eon-fg1 eon-unselectable">

    <div class="eon-date-subInputs">
      <div class="eon-date-subInput first">
        <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
      </div>
      <div class="eon-date-separator"></div>
      <div class="eon-date-subInput second">
        <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
      </div>
      <div class="eon-date-separator"></div>
      <div class="eon-date-subInput third">
        <input placeholder="" type="number" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></input>
      </div>
    </div>
    <i class="eon-date-button eon-fg2 eon-fg2-hoverable vicon vicon-calendar"></i>

  </div>

  <span class="eon-date-underline"></span>

  <!-- Date calendar elements -->
  <div class="eon-date-calendar eon-unselectable eon-sect1 eon-boxshadow2 eon-fg1">

    <div class="eon-date-header">
      <div class="eon-date-leftNavigation">
        <div class="eon-date-previous eon-unselectable eon-fg1-hoverable">
          <i class="vicon vicon-chevron-left"></i>
        </div>
        <div class="eon-date-next eon-unselectable eon-fg1-hoverable">
          <i class="vicon vicon-chevron-right"></i>
        </div>
      </div>

      <div class="eon-date-daysGridSelectors">
        <div class="eon-date-month eon-fg1-hoverable"></div>
        <div class="eon-date-year eon-fg1-hoverable"></div>
      </div>

      <div class="eon-date-rightNavigation">
        <div class="eon-date-back eon-unselectable eon-date-hidden eon-fg1-hoverable">
          <i class="vicon vicon-arrow-back"></i>
        </div>
      </div>
    </div>

    <div class="eon-date-body"> </div>

  </div>

  <div class="eon-date-description"></div>

</template>

<script>
  eon.element({

    name: "eon-date",
    style: "",

    themed: true,

    dependencies: [
      "../eon-overlay"
    ],

    privateProperties: {
      /*
      @property (private) {Object} _misc
      @description Object with useful information
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {Object} _refs
      @description Object with usefull information
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {String} _formElement 
      @description Necessary property for a form
      */
      formElement: {
        value: "date"
      }
    },

    properties: {
      /*
      @property {String} name
      @description Name to identify the element in a form
      */
      name: {
        value: "",
        reflect: true
      },
      /*
      @property {String} value
      @description Value of the element
      */
      value: {
        value: "",
        reflect: true
      },
      /*
      @property {String} default
      @description Value of the element when the element is reseted, if will also be the value of the element if no value is provided
      */
      default: {
        value: "",
        reflect: true
      },
      /*
      @property {Number} fontSize
      @description Basic font size from which we will determine all the sizes
      */
      fontSize: {
        value: 14,
        reflect: true
      },
      /*
      @property {String} type
      @description Determines the type of the date selection (input or calendar)
      */
      type: {
        value: "input",
        reflect: true
      },
      /*
      @property {String} selectable
      @description Indicates the selectable values of the calendar (day, month and year)
      */
      selectable: {
        value: "dmy",
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {String} label
      @description Label for the element
      */
      label: {
        value: "",
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {String} locale
      @description Locale to be used in the datebox
      */
      locale: {
        value: "",
        reflect: true
      },
      /*
      @property {String} mask
      @description Date format of the input
      */
      mask: {
        value: "YYYYMMDD",
        reflect: true
      },
      /*
      @property {String} min
      @description Indicates the inferior limit of the date
      */
      min: {
        value: "",
        reflect: true
      },
      /*
      @property {String} max
      @description Indicates the superior limit of the date
      */
      max: {
        value: "",
        reflect: true
      },
      /*
      @property {String} weekStart
      @description Indicates the first day of the week for the calendar
      */
      weekStart: {
        value: "monday",
        reflect: true
      },
      /*
      @property {String} weekFormat
      @description Indicates the format of the week days header
      */
      weekFormat: {
        value: "short",
        reflect: true
      },
      /*
      @property {String} valueFormat
      @description Indicates the format of the value
      */
      valueFormat: {
        value: "YYYY-MM-DD",
        reflect: true
      },
      /*
      @property {Boolean} toolbar
      @description Indicates whether its in toolbar mode or not
      */
      toolbar: {
        value: false,
        reflect: true
      },
      /*
      @property {Boolean} inline 
      @description Space that occupies the button inside its parent container.
      */
      inline: {
        value: true,
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {Boolean} readonly
      @description Toggles the readonly status of the element
      */
      readonly: {
        value: false,
        reflect: true
      },
      /*
      @property {Boolean} disabled
      @description Toggles the disabled status of the element
      */
      disabled: {
        value: false,
        reflect: true
      },
      /*
      @property {Number} day
      @description Toggles the disabled status of the element
      */
      day: {
        value: "",
        reflect: true
      },
      /*
      @property {Number} month
      @description Toggles the disabled status of the element
      */
      month: {
        value: "",
        reflect: true
      },
      /*
      @property {Number} year
      @description Toggles the disabled status of the element
      */
      year: {
        value: "",
        reflect: true
      },
      /*
      @property {String} tooltip
      @description Text to be shown for the element
      */
      tooltip: {
        value: "",
        reflect: true,
        reflectDefault: false
      },
      /*
      @property {Boolean} invalid
      @description Whether the element meets the requirements or not
      */
      invalid: {
        value: false,
        reflect: true,
        reflectDefault: false
      }
    },
    privateFunctions: {
      /*
      @function (private) _setup
      @description Here we setup everything we need for the element
      */
      setup: function () {

        var el = this;

        el.locale = (el.locale != undefined && el.locale != "") ? el.locale : navigator.language;

        el._refs.calendar.setAttribute("selectable", el.selectable);

        el._initDefault();

        el._setupMinDate();
        el._setupMaxDate();

        el._setupSeparator();
        el._setupMask();
        el._setupEvents();

        el._setupCalendar();

        el._setupToolbarMode();

        el._initValue();

        el._refresh();

        el._updateLabel();
        el._updateDisabled();
        el._updateReadOnly();

      },
      /*
      @function (private) _setupType
      @description Creates the structure of the element depending on the type
      */
      setupType: function () {

        var el = this;

        var calendarFragment = document.createDocumentFragment();
        var dataFragment = document.createDocumentFragment();
        var inputFragment = document.createDocumentFragment();

        // Separates the template into 3 different fragments, depending on the type we will reappend 
        // the elements we need
        calendarFragment.appendChild(el.template.querySelector(".eon-date-calendar"));
        dataFragment.appendChild(el.template.querySelector(".eon-date-data"));
        inputFragment.appendChild(el.template);

        if (el.type == "calendar") {

          el.template.appendChild(dataFragment);
          el.template.appendChild(calendarFragment);

          eon.addResizeListener(el._refs.calendar, "calendar", function () {
            el._handleAutoHeight();
            el._handleFonts();
          });

        } else {

          el.template.appendChild(dataFragment);
          el.template.appendChild(inputFragment);

          el._refs.overlay.appendChild(calendarFragment);

        }

      },
      /*
      @function (private) _setupCalendar
      @description Prepares the calendar and its grids/events
      */
      setupCalendar: function () {

        var el = this;

        el._setupWeekDays();
        el._setupYearsGrid();
        el._setupMonthsGrid();
        el._setupDaysGrid();

        el._handleAutoHeight();
        el._handleFonts();

        // Events

        el._refs.calendarButton.addEventListener('click', function (e) {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el._showCalendar();
          }
        }, false);

        el._refs.previous.addEventListener(el._misc.downTrigger, function (e) {
          e.stopPropagation();
          e.preventDefault();
          el._goToPrevious(this);
        });

        el._refs.next.addEventListener(el._misc.downTrigger, function (e) {
          e.stopPropagation();
          e.preventDefault();
          el._goToNext(this);
        });

        el._refs.calendar.querySelector(".eon-date-back").addEventListener(el._misc.downTrigger, function (e) {
          e.stopPropagation();
          e.preventDefault();
          el._goBack(this);
        });

        el._refs.calendar.querySelector(".eon-date-header .eon-date-month").addEventListener(el._misc.downTrigger, function (e) {
          if (this.dataset.disabled != "true") {
            e.stopPropagation();
            e.preventDefault();
            el._showMonthsGrid();
          }
        });

        el._refs.calendar.querySelector(".eon-date-header .eon-date-year").addEventListener(el._misc.downTrigger, function (e) {
          if (this.dataset.disabled != "true") {
            e.stopPropagation();
            e.preventDefault();
            el._showYearsGrid();
          }
        });

        eon.registerPathListener(el._refs.calendar, "calendar");

      },
      /*
            @function (private) _setupOverlay
            @description Sets up basic properties for the data object
            */
      setupOverlay: function () {

        var el = this;

        el._refs.overlay = el.generateOverlayNode();
        el._refs.overlay.classList.add("eon-date-overlay", "eon-bg1-modal");

        // Prevents scrolling on mobile devices
        el._refs.overlay.addEventListener("wheel", function (e) {
          if (!el._refs.calendar.isOnPath) {
            e.preventDefault();
            e.stopPropagation();
          }
        }, { passive: false });

        // Overlay blur
        el._refs.overlay.addEventListener("click", function (e) {
          if (el._misc.modal.active && !el._refs.calendar.isOnPath) {
            e.preventDefault();
            e.stopPropagation();
            el._hideCalendar();
          }
        });

        // If the user scrolls the window scrollbar we hide the calendar
        window.addEventListener("scroll", function (e) {
          if (el._misc.modal.active) {
            el._hideCalendar();
          }
        });

      },
      /*
      @function (private) _setupMisc
      @description Sets up basic properties for the misc object
      */
      setupMisc: function () {

        var el = this;

        el._misc.current = {};
        el._misc.mask = {};
        el._misc.min = {};
        el._misc.min.active = false;
        el._misc.max = {};
        el._misc.max.active = false;
        el._misc.modal = {};

        el._misc.weekDays = {};
        el._misc.current = {};
        el._misc.selected = {};
        el._misc.selector = {};
        el._misc.selector.range = {};

        el._misc.descriptionText = "";

        el._misc.downTrigger = "click";

      },
      /*
      @function (private) _setupRefs
      @description Creates some fast access elements so that theres no need for calling the QuerySelector all the time.
      */
      setupRefs: function () {

        var el = this;

        // Input related references
        el._refs.subInputsWrapper = el.template.querySelector(".eon-date-subInputs");
        el._refs.subInputs = {};

        el._refs.subInputs.first = el.template.querySelector(".eon-date-subInputs .first input");
        el._refs.subInputs.second = el.template.querySelector(".eon-date-subInputs .second input");
        el._refs.subInputs.third = el.template.querySelector(".eon-date-subInputs .third input");

        el._refs.underline = el.template.querySelector(".eon-date-underline");

        el._refs.data = el.template.querySelector(".eon-date-data");
        el._refs.main = el.template.querySelector(".eon-date-main");

        el._refs.calendarButton = el.template.querySelector(".eon-date-button");

        // Calendar related references
        el._refs.calendar = el.template.querySelector(".eon-date-calendar");

        el._refs.selectorsContainer = el._refs.calendar.querySelector(".eon-date-daysGridSelectors");
        el._refs.monthSelector = el._refs.calendar.querySelector(".eon-date-header .eon-date-month");
        el._refs.yearSelector = el._refs.calendar.querySelector(".eon-date-header .eon-date-year");

        el._refs.header = el._refs.calendar.querySelector(".eon-date-header");
        el._refs.body = el._refs.calendar.querySelector(".eon-date-body");

        el._refs.description = el.template.querySelector(".eon-date-description");

        el._refs.previous = el._refs.calendar.querySelector(".eon-date-previous");
        el._refs.next = el._refs.calendar.querySelector(".eon-date-next");

      },
      /*
      @function (private) {String} _setupDescription
      @description Creates the touch blur
      */
      setupDescription: function () {

        var el = this;

        if (el.tooltip != "") {
          el.updateDescription(el.tooltip);
        }

      },
      /*
      @function (private) _setupMask
      @description Sets up the mask and the subinputs to be used for the user input
      */
      setupMask: function () {

        var el = this;

        el._misc.mask.order = [];

        var dayFormat = el.mask.match(/[d|D]{1,2}/)[0];
        var monthFormat = el.mask.match(/[M]{1,4}/)[0];
        var yearFormat = el.mask.match(/[y|Y]{2,4}/)[0];

        el._misc.mask["day"] = {};
        el._misc.mask["month"] = {};
        el._misc.mask["year"] = {};

        if (dayFormat && monthFormat && yearFormat) {

          var yearOrder = el.mask.indexOf(yearFormat);

          el._misc.mask.day.format = dayFormat;
          el._misc.mask.month.format = monthFormat;
          el._misc.mask.year.format = yearFormat;

          if (el.mask.indexOf(dayFormat) < el.mask.indexOf(monthFormat)) {

            el._misc.mask.order[0] = "day";
            el._misc.mask.order[1] = "month";

          } else {

            el._misc.mask.order[0] = "month";
            el._misc.mask.order[1] = "day";
          }

          if (el.mask.indexOf(yearFormat) < el.mask.indexOf(dayFormat)) {
            el._misc.mask.order.splice(0, 0, "year");
          } else if (el.mask.indexOf(yearFormat) < el.mask.indexOf(monthFormat)) {
            el._misc.mask.order.splice(1, 0, "year");
          } else {
            el._misc.mask.order[2] = "year";
          }

          el.mask = el._misc.mask[el._misc.mask.order[0]].format + el._misc.mask[el._misc.mask.order[1]].format + el._misc.mask[el._misc.mask.order[2]].format;

          el._refs.subInputs.first.placeholder = el._misc.mask[el._misc.mask.order[0]].format;
          el._refs.subInputs.second.placeholder = el._misc.mask[el._misc.mask.order[1]].format;
          el._refs.subInputs.third.placeholder = el._misc.mask[el._misc.mask.order[2]].format;

        } else {

          el._misc.mask.order = ["day", "month", "year"];

          el._misc.mask.day.format = "DD";
          el._misc.mask.month.format = "MM";
          el._misc.mask.year.format = "YYYY";

          el.mask = "DDMMYYYY";

          el._refs.subInputs.first.placeholder = "DD";
          el._refs.subInputs.second.placeholder = "MM";
          el._refs.subInputs.third.placeholder = "YYYY";
        }

        var firstSection = el._misc.mask[el._misc.mask.order[0]];
        var secondSection = el._misc.mask[el._misc.mask.order[1]];
        var thirdSection = el._misc.mask[el._misc.mask.order[2]];

        firstSection.start = 0;
        firstSection.end = el._misc.mask[el._misc.mask.order[0]].format.length;

        secondSection.start = firstSection.end + el._misc.separator.length;
        secondSection.end = secondSection.start + el._misc.mask[el._misc.mask.order[1]].format.length;

        thirdSection.start = secondSection.end + el._misc.separator.length;
        thirdSection.end = thirdSection.start + el._misc.mask[el._misc.mask.order[2]].format.length;

        el._refs.subInputs.first.parentNode.dataset.field = el._misc.mask.order[0];
        el._refs.subInputs.first.parentNode.dataset.order = "0";

        el._refs.subInputs.second.parentNode.dataset.field = el._misc.mask.order[1];
        el._refs.subInputs.second.parentNode.dataset.order = "1";

        el._refs.subInputs.third.parentNode.dataset.field = el._misc.mask.order[2];
        el._refs.subInputs.third.parentNode.dataset.order = "2";

        var separators = el.querySelectorAll(".eon-date-subInputs .eon-date-separator");

        for (var i = 0; i < separators.length; i++) {
          separators[i].innerHTML = el._misc.separator;
        }

      },
      /*
      @function (private) _setupEvents
      @description Creates the events for the subinputs
      */
      setupEvents: function () {

        var el = this;

        el._setupFocusEvents();
        el._setupBlurEvents();
        el._setupOnKeyDownEvents();
        el._setupOnKeyUpEvents();
        el._setupPasteEvents();

      },
      /*
      @function (private) _setupFocusEvents
      @description Creates the focus events for the subinputs
      */
      setupFocusEvents: function () {

        var el = this;
        el._labelNode = el.querySelector(".eon-date-label");

        el._refs.subInputs.first.addEventListener("focus", function (e) {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el._handleFocus(this);
            el._assignFocusStyle();
          }
        }, true);

        el._refs.subInputs.second.addEventListener("focus", function (e) {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el._handleFocus(el._refs.subInputs.second);
            el._assignFocusStyle();
          }
        }, true);

        el._refs.subInputs.third.addEventListener("focus", function (e) {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el._handleFocus(el._refs.subInputs.third);
            el._assignFocusStyle();
          }
        }, true);

      },
      /*
      @function (private) _setupBlurEvents
      @description Sets up the blur events for the subinputs
      */
      setupBlurEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("blur", function () {

          if ((el._refs.subInputs.first.dataset.field == "day" || el._refs.subInputs.first.dataset.field == "month") && el._refs.subInputs.first.textContent.length == 1 && el._refs.subInputs.first.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.first.textContent = "0" + el._refs.subInputs.first.textContent;
          }

          el._revertFocusStyle();

        }, true);

        el._refs.subInputs.second.addEventListener("blur", function () {

          if ((el._refs.subInputs.second.dataset.field == "day" || el._refs.subInputs.second.dataset.field == "month") && el._refs.subInputs.second.textContent.length == 1 && el._refs.subInputs.second.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.second.textContent = "0" + el._refs.subInputs.second.textContent;
          }

          el._revertFocusStyle();

        }, true);

        el._refs.subInputs.third.addEventListener("blur", function () {

          if ((el._refs.subInputs.third.dataset.field == "day" || el._refs.subInputs.third.dataset.field == "month") && el._refs.subInputs.third.textContent.length == 1 && el._refs.subInputs.third.textContent.length < el._misc.mask[el._misc.mask.order[0]].format.length) {
            el._refs.subInputs.third.textContent = "0" + el._refs.subInputs.third.textContent;
          }

          el._revertFocusStyle();

        }, true);

      },
      /*
      @function (private) _setupOnKeyDownEvents
      @description Sets up the keydown events for the subinputs
      */
      setupOnKeyDownEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.first, e);
        }, true);

        el._refs.subInputs.second.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.second, e);
        }, true);

        el._refs.subInputs.third.addEventListener("keydown", function (e) {
          el._handleKeyDown(el._refs.subInputs.third, e);
        }, true);

      },
      /*
      @function (private) _setupOnKeyUpEvents
      @description Sets up the keyup events for the subinputs
      */
      setupOnKeyUpEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.first, e);
        }, true);

        el._refs.subInputs.second.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.second, e);
        }, true);

        el._refs.subInputs.third.addEventListener("keyup", function (e) {
          el._handleKeyUp(el._refs.subInputs.third, e);
        }, true);

      },
      /*
      @function (private) _setupPasteEvents
      @description Sets up the events for the subinputs to prevent paste
      */
      setupPasteEvents: function () {

        var el = this;

        el._refs.subInputs.first.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

        el._refs.subInputs.second.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

        el._refs.subInputs.third.addEventListener("paste", function (e) {
          e.preventDefault;
          return false;
        }, true);

      },
      /*
      @function (private) _setupMinDate
      @description Sets up the inferior limit of the date
      */
      setupMinDate: function () {

        var el = this;

        if (el.min != "") {

          if (el.min.indexOf("/") > -1) {

            var splittedMin = el.min.split("/");

            el._misc.min.day = parseInt(splittedMin[0]);
            el._misc.min.month = parseInt(splittedMin[1]) - 1;
            el._misc.min.year = parseInt(splittedMin[2]);

            el._misc.min.active = true;

          }

        }

      },
      /*
      @function (private) _setupMaxDate
      @description Sets up the superior limit of the date
      */
      setupMaxDate: function () {

        var el = this;

        if (el.max != "") {

          if (el.max.indexOf('/') > -1) {

            var splittedMax = el.max.split("/");

            el._misc.max.day = parseInt(splittedMax[0]);
            el._misc.max.month = parseInt(splittedMax[1]) - 1;
            el._misc.max.year = parseInt(splittedMax[2]);

            el._misc.max.active = true;

          }

        }

      },
      /*
      @function (private) {String} _setupSeparator
      @description Takes the value format and saves its separator
      */
      setupSeparator: function () {
        var el = this;
        el._misc.separator = eon.time.getFormatSeparator(el.valueFormat);
      },
      /*
      @function (private) _setupToolbarMode
      @description Adds whats needed to overwrite the default style
      */
      setupToolbarMode: function () {
        var el = this;
        el._refs.main.classList.add("toolbar");
      },
      /*
      @function (private) _addFocusStyle
      @description When focused, it adds the corresponding style
      */
      addFocusStyle: function () {

        var el = this;

        if (eon.util.isTrue(el.toolbar)) {
          el._refs.main.classList.add("toolbar");
        }

      },
      /*
      @function (private) _setupWeekDays
      @description Sets up the weekdays, including its locale, format and weekDayStart
      */
      setupWeekDays: function () {

        var el = this;

        function reorderWeekDays(array, oldIndex, newIndex) {
          while (oldIndex < 0) {
            oldIndex += array.length;
          }
          while (newIndex < 0) {
            newIndex += array.length;
          }
          if (newIndex >= array.length) {
            var k = newIndex - array.length;
            while ((k--) + 1) {
              array.push(undefined);
            }
          }
          array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
          return array;
        }

        el._misc.weekDays.display = eon.time.getWeekDays(el.locale, el.weekFormat);
        el._misc.weekDays.keys = eon.time.getWeekDays("en", "long");

        if (el._misc.weekDays.keys[0].toLowerCase() != el.weekStart.toLowerCase()) {

          for (var i = 0; i < el._misc.weekDays.keys.length; i++) {

            el._misc.weekDays.display = reorderWeekDays(el._misc.weekDays.display, 6, 0);
            el._misc.weekDays.keys = reorderWeekDays(el._misc.weekDays.keys, 6, 0);

            if (el._misc.weekDays.keys[0].toLowerCase() == el.weekStart.toLowerCase()) {
              break;
            }
          }
        }
      },
      /*
      @function (private) _setupDaysGrid
      @description Sets up the days Grid
      */
      setupDaysGrid: function () {

        var el = this;

        if (el.type.toLowerCase() != "calendar" || el.type.toLowerCase() == "calendar" && el.selectable.indexOf('d') > -1) {

          var week;
          var day;

          var daysGridContainer = document.createElement("div");
          var weekDaysContainer = document.createElement("div");
          var daysGrid = document.createElement("div");

          var weeksFragment = document.createDocumentFragment();

          daysGridContainer.style.zIndex = -1;

          daysGridContainer.classList.add("eon-date-daysGrid");
          weekDaysContainer.classList.add("eon-date-weekDays");
          daysGrid.classList.add("eon-date-grid");

          daysGridContainer.appendChild(weekDaysContainer);
          daysGridContainer.appendChild(daysGrid);
          el._refs.calendar.querySelector(".eon-date-body").appendChild(daysGridContainer);

          el._refs.daysGrid = daysGridContainer;

          el._createWeekDaysHeaders();

          for (var i = 1; i <= 6; i++) {

            week = document.createElement("div");
            week.classList.add("eon-date-week");

            for (var j = 1; j <= 7; j++) {

              day = document.createElement("div");
              day.classList.add("eon-date-day", "eon-bg1-hoverable", "eon-fg1-hoverable");
              day.addEventListener(el._misc.downTrigger, function (e) {
                e.preventDefault();
                e.stopPropagation();
                el._selectDay(this);
              });

              week.appendChild(day);
            }
            weeksFragment.appendChild(week);
          }
          daysGrid.appendChild(weeksFragment);

        }

      },
      /*
      @function (private) _setupMonthsGrid
      @description Sets up the months Grid
      */
      setupMonthsGrid: function () {

        var el = this;

        if (el.type.toLowerCase() != "calendar" || el.type.toLowerCase() == "calendar" && el.selectable.indexOf('m') > -1) {

          var row;
          var month;

          var monthsGrid = document.createElement("div");
          var rowsFragment = document.createDocumentFragment();

          var months = eon.time.getMonthNames(el.locale, "short");

          monthsGrid.classList.add("eon-date-monthsGrid", "eon-sect1");
          el._refs.calendar.querySelector(".eon-date-body").appendChild(monthsGrid);

          el._refs.monthsGrid = monthsGrid;

          row = document.createElement("div");
          row.classList.add("eon-date-row");

          for (var i = 0; i < months.length; i++) {

            month = document.createElement("div");
            month.classList.add("eon-date-month", "eon-bg1-hoverable", "eon-fg1-hoverable");
            month.innerHTML = months[i];
            month.dataset.index = i;

            month.addEventListener(el._misc.downTrigger, function (e) {
              e.preventDefault();
              e.stopPropagation();
              el._selectMonth(this);
            });

            row.appendChild(month);

            if (row.childNodes.length == 4) {
              rowsFragment.appendChild(row);
              row = document.createElement("div");
              row.classList.add("eon-date-row");
            }
          }

          monthsGrid.appendChild(rowsFragment);

        }

      },
      /*
      @function (private) _setupYearsGrid
      @description Sets up the years Grid
      */
      setupYearsGrid: function () {

        var el = this;

        if (el.type.toLowerCase() != "calendar" || el.type.toLowerCase() == "calendar" && el.selectable.indexOf('y') > -1) {

          var row;
          var year;

          var yearsGrid = document.createElement("div");
          var rowsFragment = document.createDocumentFragment();

          var currentYear = new Date();
          var years = [];

          currentYear = currentYear.getFullYear();

          for (var i = currentYear - 6; i < currentYear + 6; i++) {
            years.push(i);
          }

          yearsGrid.classList.add("eon-date-yearsGrid", "eon-sect1");
          el._refs.calendar.querySelector(".eon-date-body").appendChild(yearsGrid);

          el._refs.yearsGrid = yearsGrid;

          row = document.createElement("div");
          row.classList.add("eon-date-row");

          for (var i = 0; i < years.length; i++) {

            year = document.createElement("div");
            year.classList.add("eon-date-year", "eon-bg1-hoverable", "eon-fg1-hoverable");

            year.addEventListener(el._misc.downTrigger, function (e) {
              e.preventDefault();
              e.stopPropagation();
              el._selectYear(this);
            });

            row.appendChild(year);

            if (row.childNodes.length == 4) {
              rowsFragment.appendChild(row);
              row = document.createElement("div");
              row.classList.add("eon-date-row");
            }
          }

          yearsGrid.appendChild(rowsFragment);

        }

      },
      /*
      @function (private) _assignFocusStyle
      @description When focused, it adds the corresponding style
      */
      assignFocusStyle: function () {

        var el = this;

        el._refs.underline.classList.add("animate");
        el.classList.add("eon-date-focus");
        el._labelNode.classList.add("eon-fg1");

      },
      /*
      @function (private) _revertFocusStyle
      @description On blur, removes the corresponding style
      */
      revertFocusStyle: function () {

        var el = this;

        el._refs.underline.classList.remove("animate");
        el.classList.remove("eon-date-focus");
        el._labelNode.classList.remove("eon-fg1");

      },
      /*
      @function (private) _assignCalendarStyle
      @description Assigns the calendar's width and position relative to the datebox
      */
      assignCalendarStyle: function () {

        var el = this;

        if (window.innerWidth <= eon.tabletWidth) {

          if (!el._refs.overlay.classList.contains("eon-date-device")) {

            el._refs.calendar.style.top = "auto";
            el._refs.calendar.style.left = "auto";

            el._refs.overlay.classList.add("eon-date-device");
            el._refs.overlay.classList.add("eon-bg1-modal");

          }

        } else {

          el._refs.overlay.classList.remove("eon-date-device");
          el._refs.overlay.classList.remove("eon-bg1-modal");

          el._refs.calendar.style.top = el._refs.main.getBoundingClientRect().top + 1 + el._refs.main.offsetHeight + "px";
          el._refs.calendar.style.left = el._refs.main.getBoundingClientRect().left + "px";
          el._refs.calendar.style.width = el._refs.main.offsetWidth + "px";
          el._refs.calendar.style.height = "auto";

        }

      },
      /*
      @function (private) _showCalendar
      @description Shows the calendar
      */
      showCalendar: function () {

        var el = this;

        el._assignCalendarStyle();
        el._assignFocusStyle();

        el._refresh();

        document.body.appendChild(el._refs.overlay);

        el._handleAutoHeight();
        el._handleFonts();

        el._misc.modal.active = true;

      },
      /*
      @function (private) _hideCalendar
      @description Hides the calendar
      */
      hideCalendar: function () {

        var el = this;

        el._revertFocusStyle();

        if (el._refs.overlay.parentNode) {
          el._refs.overlay.parentNode.removeChild(el._refs.overlay);
        }

        el._misc.modal.active = false;

      },
      /*
      @function (private) _validate
      @description Validates if what the user typed is a valid date
      */
      validate: function () {

        var el = this;

        var inputs = el.querySelectorAll(".eon-date-subInputs .eon-date-subInput input");

        var day = inputs[el._misc.mask.order.indexOf("day")].value;
        var month = inputs[el._misc.mask.order.indexOf("month")].value;
        var year = inputs[el._misc.mask.order.indexOf("year")].value;

        var validDate = false;
        var date;

        var obj = {

          day: day,
          month: month,
          year: year

        }

        //If all the three fields have text typed in and their content is valid we set the boolean to true
        if (year != "") {
          if (month != "" && parseInt(month) > 0 && parseInt(month) <= 12) {
            if (day != "" && day > 0 && day <= eon.time.getDaysInMonth(year, parseInt(month) - 1)) {
              validDate = true;
            }
          }
        }

        //If its valid we remove the error classes, and update everything according to the new date
        if (validDate) {

          el.invalid = false;

          el._misc.current.day = parseInt(day);
          el._misc.current.month = parseInt(month) - 1;
          el._misc.current.year = parseInt(year);

          el._misc.preventUpdate = true;

          el.value = eon.time.generateOutput(dateObj, el.valueFormat);


        } else {

          el.invalid = true;

        }

      },
      /*
      @function (private) _initDefault
      @description If a value has been provided by the user we set it for our element
      */
      initDefault: function () {
        this.value = this.default != "" && this.value == "" ? this.default : this.value;
      },
      /*
      @function (private) _initValue
      @description If a value has been provided by the user we set it for our element
      */
      initValue: function () {

        var el = this;
        var dateObj;

        // If no value was provided by the user we create one
        if (el.value == "") {

          var date = new Date();

          dateObj = {
            day: el.day != "" ? parseInt(el.day) : parseInt(date.getDate()),
            month: el.month != "" ? parseInt(el.month) : parseInt(date.getMonth()) + 1,
            year: el.year != "" ? parseInt(el.year) : parseInt(date.getFullYear())
          }

        } else {

          dateObj = eon.time.getDateObjectFromString(el.value, el.valueFormat);

        }

        if (el._exceedsMinDate(dateObj)) {

          dateObj.day = el._misc.min.day;
          dateObj.month = el._misc.min.month + 1;
          dateObj.year = el._misc.min.year;

        } else if (el._exceedsMaxDate(dateObj)) {

          dateObj.day = el._misc.max.day;
          dateObj.month = el._misc.max.month + 1;
          dateObj.year = el._misc.max.year;

        }

        dateObj = el._formatObj(dateObj);

        el.value = eon.time.generateOutput(dateObj, el.valueFormat);

        el._updateValue();

      },
      /*
      @function (private) {String} _format
      @description We replace the format with the given data, in case the field's length is lower than its format then we add 0 as needed
      @param {String} text
      @param {String} format
      */
      format: function (text, format) {

        var el = this;

        text = text ? text + "" : "";

        if (text.length > 0 && text.length < format.length) {
          for (var i = 0; i < (format.length - text.length); i++) {
            text = "0" + text;
          }
        }

        return text;

      },
      /*
      @function (private) {Boolean} _isMinMonth
      @description Returns true if the month is equal/lower than the min month
      @param {Number} year
      @param {Number} month
      */
      isMinMonth: function (year, month) {
        return (year == this._misc.min.year && month <= this._misc.min.month || year < this._misc.min.year);
      },
      /*
      @function (private) {Boolean} _isMaxMonth
      @description Returns true if the month is equal/higher than the max month
      @param {Number} year
      @param {Number} month
      */
      isMaxMonth: function (year, month) {
        return (year == this._misc.max.year && month >= this._misc.max.month || year > this._misc.max.year);
      },
      /*
      @function (private) _handleFocus
      @description Moves the cursor to the right when a subinput is being focused
      @param {Object} subInput
      */
      handleFocus: function (subInput) {
        if (subInput.firstChild) {
          var range = document.createRange();
          var sel = window.getSelection();

          range.selectNodeContents(subInput);

          sel.removeAllRanges();
          sel.addRange(range);

        }
      },
      /*
      @function (private) {Number}  _getCaretPosition
      @description function_description
      @param {Object} editableDiv
      */
      getCaretPosition: function (editableDiv) {
        var caretPos = 0,
          sel, range;
        if (window.getSelection) {
          sel = window.getSelection();
          if (sel.rangeCount) {
            range = sel.getRangeAt(0);
            if (range.commonAncestorContainer.parentNode == editableDiv) {
              caretPos = range.endOffset;
            }
          }
        } else if (document.selection && document.selection.createRange) {
          range = document.selection.createRange();
          if (range.parentElement() == editableDiv) {
            var tempEl = document.createElement("span");
            editableDiv.insertBefore(tempEl, editableDiv.firstChild);
            var tempRange = range.duplicate();
            tempRange.moveToElementText(tempEl);
            tempRange.setEndPoint("EndToEnd", range);
            caretPos = tempRange.text.length;
          }
        }
        return caretPos;
      },
      /*
      @function (private) {Boolean} _isNumeric
      @description Whether the recieved key event has a numeric value or not
      @param {Object} e
      */
      isNumeric: function (e) {
        return (e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105);
      },
      /*
      @function (private) _handleKeyDown
      @description Handles the typing and the date correction, if the subinput reaches its limit it jumpes to the next one
      @param {Object} subInput
      @param {Object} e
      */
      handleKeyDown: function (subInput, e) {

        var el = this;
        var selection = window.getSelection();

        if (!el._isNumeric(e)) {

          if (e.keyCode != "9" && e.keyCode != "46" && e.keyCode != "8" && e.keyCode != "37" && e.keyCode != "39") {

            e.preventDefault();
            e.stopPropagation();

          } else {

            if (e.keyCode == "8") {

              var subInputs = el.querySelector(".eon-date-subInputs");
              var previousSubInputOrder = parseInt(subInput.parentNode.dataset.order) - 1;
              var previousSubInput = subInputs.querySelector('[data-order="' + previousSubInputOrder + '"] input');
              var caretPosition = subInput.selectionStart;

              if (!(selection.anchorNode === subInput && selection.extentOffset > 0 && selection.type == "Range")) {
                if (caretPosition == 0 && previousSubInput) {
                  previousSubInput.focus();
                }

              }

            }

          }
        } else {

          var subInputs = el.querySelector(".eon-date-subInputs");

          var nextSubInputOrder = parseInt(subInput.dataset.order) + 1;
          var nextSubInput = subInputs.querySelector('[data-order="' + nextSubInputOrder + '"] input');

          var aux = subInput.value;

          if (!(selection.anchorNode === subInput && selection.extentOffset > 0 && selection.type == "Range")) {

            if (!(aux.length >= el._misc.mask[subInput.parentNode.dataset.field].format.length)) {
              subInput.value = aux + el._getStringFromKeyCode(e.keyCode);
              e.preventDefault();
              e.stopPropagation();
            }


          }

        }

        // Checks if the key press corresponds to ENTER
        if (e.keyCode == 13) {
          eon.triggerCallback("onEnter", el)
        }

      },
      /*
      @function (private) {String} _getStringFromKeyCode
      @description Receives a keyCode and returns the string value (intented for numeric)
      @param {String} keyCode
      */
      getStringFromKeyCode: function (keyCode) {
        return String.fromCharCode((keyCode >= 96 && keyCode <= 105) ? keyCode - 48 : keyCode)
      },
      /*
      @function (private) _handleKeyUp
      @description Handles the key up event
      @param {Object} subInput 
      @param {Object} e [event]
      */
      handleKeyUp: function (subInput, e) {

        var el = this;

        if (!(document.activeElement.isEqualNode(subInput) && el._getSelectionText().length == subInput.value.length)) {

          if (el._isNumeric(e) || e.keyCode == "8" || e.keyCode == "46") {

            var subInputs = el.querySelector(".eon-date-subInputs");

            var nextSubInputOrder = parseInt(subInput.parentNode.dataset.order) + 1;
            var nextSubInput = subInputs.querySelector('[data-order="' + nextSubInputOrder + '"] input');

            if ((subInput.value.length >= el._misc.mask[subInput.parentNode.dataset.field].format.length)) {

              if (nextSubInput) {
                nextSubInput.focus();
              }

              el._handleCorrection();
            }

            el._validate();

          }

        }

      },
      /*
      @function (private) {String} _getSelectionText
      @description Gets the selected text
      */
      getSelectionText: function () {
        var text = "";
        var activeEl = document.activeElement;
        var activeElTagName = activeEl ? activeEl.tagName.toLowerCase() : null;
        if (
          (activeElTagName == "textarea") || (activeElTagName == "input" &&
            /^(?:text|search|password|tel|url)$/i.test(activeEl.type)) &&
          (typeof activeEl.selectionStart == "number")
        ) {
          text = activeEl.value.slice(activeEl.selectionStart, activeEl.selectionEnd);
        } else if (window.getSelection) {
          text = window.getSelection().toString();
        }
        return text;
      },
      /*
      @function (private) _handleCorrection
      @description Handles the date correction for months and days
      */
      handleCorrection: function () {

        var el = this;

        var subInputs = el.querySelector(".eon-date-subInputs");

        var dayInput = subInputs.querySelector('[data-field="day"] input');
        var monthInput = subInputs.querySelector('[data-field="month"] input');
        var yearInput = subInputs.querySelector('[data-field="year"] input');

        if (dayInput.value != "" && parseInt(dayInput.value) > 31) {
          dayInput.value = "31";
        } else if (dayInput.value.length == 2 && parseInt(dayInput.value) == 0) {
          dayInput.value = "1";
        }

        if (monthInput.value != "" && parseInt(monthInput.value) > 12) {
          monthInput.value = "12";
        } else if (monthInput.value.length == 2 && parseInt(monthInput.value) == 0) {
          monthInput.value = "1";
        }

        if (yearInput.value != "" && parseInt(yearInput.value) > 9999) {
          yearInput.value = "9999";
        } else if (parseInt(yearInput.value) == 0) {
          yearInput.value = "1";
        }

        if (dayInput.value != "" && monthInput.value != "" && yearInput.value != "" && (yearInput.value.length == el._misc.mask.year.format.length)) {
          if (parseInt(dayInput.value) > eon.time.getDaysInMonth(parseInt(yearInput.value), parseInt(monthInput.value) - 1)) {
            dayInput.value = eon.time.getDaysInMonth(parseInt(yearInput.value), parseInt(monthInput.value) - 1);
          }
        }

        el._handleLimits(dayInput, monthInput, yearInput);
      },
      /*
      @function (private) _handleLimits
      @description Handles the limits such as min/max date
      @param {Object} dayInput
      @param {Object} monthInput
      @param {Object} yearInput
      */
      handleLimits: function (dayInput, monthInput, yearInput) {

        var el = this;

        if (dayInput.value != "" && monthInput.value != "" && yearInput.value != "" && yearInput.value.length == el._misc.mask.year.format.length) {

          var dayInputValue = parseInt(dayInput.value);
          var monthInputValue = parseInt(monthInput.value);
          var yearInputValue = parseInt(yearInput.value);

          if ((dayInputValue < el._misc.min.day && monthInputValue <= el._misc.min.month && yearInputValue == el._misc.min.year) || (monthInputValue < el._misc.min.month && yearInputValue == el._misc.min.year) || yearInputValue < el._misc.min.year) {

            dayInput.value = el._misc.min.day;
            monthInput.value = el._misc.min.month;
            yearInput.value = el._misc.min.year;

          } else if ((dayInputValue > el._misc.max.day && monthInputValue >= el._misc.max.month && yearInputValue == el._misc.max.year) || (monthInputValue > el._misc.max.month && yearInputValue == el._misc.max.year) || yearInputValue > el._misc.max.year) {

            dayInput.value = el._misc.max.day;
            monthInput.value = el._misc.max.month;
            yearInput.value = el._misc.max.year;
          }
        }
      },
      /*
      @function (private) {Boolean} _exceedsMinDate
      @description Returns whether the provided date exceeds the minimal date or not
      @param {Object} dateObj
      */
      exceedsMinDate: function (dateObj) {

        var el = this;

        if (el._misc.min.active) {
          var exceedsDay = dateObj.day < el._misc.min.day && dateObj.month == el._misc.min.month && dateObj.year == el._misc.min.year;
          var exceedsMonth = dateObj.month < el._misc.min.month && dateObj.year == el._misc.min.year;
          var exceedsYear = dateObj.year < el._misc.min.year;
        }

        return exceedsDay || exceedsMonth || exceedsYear ? true : false;

      },
      /*
      @function (private) {Boolean} _exceedsMaxDate
      @description Returns whether the provided date exceeds the maximum date or not
      @param {Object} dateObj
      */
      exceedsMaxDate: function (dateObj) {

        var el = this;

        if (el._misc.max.active) {
          var exceedsDay = dateObj.day > el._misc.min.day && dateObj.month == el._misc.min.month && dateObj.year == el._misc.min.year;
          var exceedsMonth = dateObj.month > el._misc.max.month && dateObj.year == el._misc.max.year;
          var exceedsYear = dateObj.year > el._misc.max.year;
        }

        return exceedsDay || exceedsMonth || exceedsYear ? true : false;

      },
      /*
      @function (private) _createWeekDaysHeaders
      @description Creates the weekdays headers for the daysGrid
      */
      createWeekDaysHeaders: function () {

        var el = this;

        var dayHeadersFragment = document.createDocumentFragment();
        var dayHeader;

        for (var i = 0; i < el._misc.weekDays.keys.length; i++) {

          dayHeader = document.createElement("div");
          dayHeader.classList.add("eon-date-dayHeader");
          dayHeader.innerHTML = el._misc.weekDays.display[i];

          dayHeadersFragment.appendChild(dayHeader);
        }

        el._refs.calendar.querySelector(".eon-date-daysGrid .eon-date-weekDays").appendChild(dayHeadersFragment);
      },
      /*
      @function (private) _refresh
      @description Shows the picker and the corresponding grid
      */
      refresh: function () {

        var el = this;

        if (el._refs.daysGrid) {

          el._fillDaysGrid(el._misc.current.year, el._misc.current.month);
          el._updateHeaderSelectors("daysGrid", el._misc.current.year, el._misc.current.month);
          el._showDaysGrid();

        } else if (el._refs.monthsGrid) {

          el._updateHeaderSelectors("monthsGrid");
          el._showMonthsGrid();

        } else if (el._refs.yearsGrid) {

          el._updateHeaderSelectors("yearsGrid");
          el._showYearsGrid();
        }

        if (el._refs.yearsGrid) {

          var yearButton = el._refs.yearsGrid.querySelector("[data-year='" + el._misc.selected.year + "']");

          if (yearButton && yearButton.dataset.disabled != "true") {
            el._highlight(yearButton, el.querySelector(".eon-date-yearsGrid .eon-date-current"));
          }

        }

        if (el._refs.monthsGrid) {

          var monthButton = el._refs.monthsGrid.querySelector("[data-year='" + el._misc.selected.year + "'][data-index='" + el._misc.selected.month + "']");

          if (monthButton && monthButton.dataset.disabled != "true") {
            el._highlight(monthButton, el.querySelector(".eon-date-monthsGrid .eon-date-current"));
          }

        }

        if (el._refs.daysGrid) {

          var dayButton = el._refs.daysGrid.querySelector("[year='" + el._misc.selected.year + "'][month='" + parseInt(el._misc.selected.month) + "'][day='" + parseInt(el._misc.selected.day) + "']");

          if (dayButton && dayButton.dataset.disabled != "true") {
            el._highlight(dayButton, el.querySelector(".eon-date-daysGrid .eon-date-grid .eon-date-current"));
          }

        }

      },
      /*
      @function (private) _updateHeaderSelectors
      @description Updates the header depending on the grid passed as parameters
      @param {String} headerType
      @param {Number} year
      @param {Number} month
      */
      updateHeaderSelectors: function (headerType, year, month) {

        var el = this;

        var backButton = el._refs.calendar.querySelector(".eon-date-back");

        if (headerType == "daysGrid") {

          year = (!year) ? el._misc.current.year : year;
          month = (!month) ? el._misc.current.month : month;

          el._refs.selectorsContainer.setAttribute("class", "eon-date-daysGridSelectors");

          el._refs.yearSelector.innerHTML = year;
          el._refs.yearSelector.classList.remove("eon-date-hidden");

          // Depending on the selectable we enabled/disable the hover class
          el._refs.yearSelector.classList[!el.selectable.indexOf("y") > -1 ? "remove" : "add"]("eon-fg1-hoverable");
          el._refs.monthSelector.classList[!el.selectable.indexOf("m") > -1 ? "remove" : "add"]("eon-fg1-hoverable");

          el._refs.monthSelector.innerHTML = eon.time.getMonthName(el.locale, month, "long");
          el._refs.monthSelector.classList.remove("eon-date-hidden");

          backButton.classList.add("eon-date-hidden");

          el._refs.previous.dataset.disabled = (el._isMinMonth(year, month)) ? "true" : "false";
          el._refs.previous.classList[el._refs.previous.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

          el._refs.next.dataset.disabled = (el._isMaxMonth(year, month)) ? "true" : "false";
          el._refs.next.classList[el._refs.next.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

        } else if (headerType == "monthsGrid") {

          year = (!year) ? el._misc.current.year : year;

          el._refs.selectorsContainer.setAttribute("class", "eon-date-monthsGridSelectors");

          el._refs.yearSelector.innerHTML = year;
          el._refs.monthSelector.classList.add("eon-date-hidden");

          // Depending on the selectable we enabled/disable the hover class
          el._refs.yearSelector.classList[!el.selectable.indexOf("y") > -1 ? "remove" : "add"]("eon-fg1-hoverable");
          el._refs.monthSelector.classList[!el.selectable.indexOf("m") > -1 ? "remove" : "add"]("eon-fg1-hoverable");

          el._refs.previous.dataset.disabled = (year <= el._misc.min.year) ? "true" : "false";
          el._refs.previous.classList[el._refs.previous.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

          el._refs.next.dataset.disabled = (year >= el._misc.max.year) ? "true" : "false";
          el._refs.next.classList[el._refs.next.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

          if (el._refs.daysGrid) {

            backButton.classList.remove("eon-date-hidden");
            backButton.dataset.grid = "days";

          } else {

            backButton.classList.add("eon-date-hidden");
          }

        } else if (headerType == "yearsGrid") {

          year = (!year) ? el._misc.selector.range.start + "-" + el._misc.selector.range.end : year;

          el._refs.selectorsContainer.setAttribute("class", "eon-date-yearsGridSelectors");

          el._refs.yearSelector.innerHTML = year;
          el._refs.yearSelector.classList.remove("eon-fg1-hoverable");

          el._refs.monthSelector.classList.add("eon-date-hidden");

          el._refs.previous.dataset.disabled = (el._misc.selector.range.start <= el._misc.min.year) ? "true" : "false";
          el._refs.previous.classList[el._refs.previous.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

          el._refs.next.dataset.disabled = (el._misc.selector.range.end >= el._misc.max.year) ? "true" : "false";
          el._refs.next.classList[el._refs.next.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

          if (el._refs.daysGrid) {

            backButton.classList.remove("eon-date-hidden");
            backButton.dataset.grid = "days";

          } else if (el._refs.monthsGrid) {

            backButton.classList.remove("eon-date-hidden");
            backButton.dataset.grid = "months";

          } else {

            backButton.classList.add("eon-date-hidden");
          }
        }

      },
      /*
      @function (private) _highlight
      @description Highlights the button and removes highlight in the previous one
      @param {Object} dayButton
      */
      highlight: function (selected, previous) {

        var el = this;

        if (previous) {
          previous.classList.remove("eon-date-current", "eon-bg2-active");
        }

        selected.classList.add("eon-date-current", "eon-bg2-active");
      },
      /*
      @function (private) {Object} _formatObj
      @description Recieves an object with a day/year/month and returns an object with the same values with the provided format
      @param {Object} obj
      */
      formatObj: function (obj) {

        var el = this;

        var format = el.valueFormat;

        var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
        var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
        var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

        var finalObj = {};

        finalObj.day = obj.day ? el._format(obj.day, dayFormat) : undefined;
        finalObj.month = obj.month ? el._format(obj.month, monthFormat) : undefined;
        finalObj.year = obj.year ? el._format(obj.year, yearFormat) : undefined;

        return finalObj;

      },
      /*
      @function (private) _handleAutoHeight
      @description Maintains an aspect ratio for the picker relative to its width
      */
      handleAutoHeight: function () {

        var el = this;
        var calendar = el._refs.calendar;

        if (calendar.offsetWidth != 0) {
          calendar.style.height = (parseFloat(calendar.offsetWidth) * 0.839) + "px";
        }

      },
      /*
      @function (private) _handleFonts
      @description It handles the fontSizes for different picker widths
      */
      handleFonts: function () {

        var el = this;
        var calendar = el._refs.calendar;

        var baseFontSize, weekDaysConstant, headerConstant;
        var daysFontSize, weekDaysFontSize, headerFontSize, navigation, otherGridsFontSize;

        weekDaysConstant = 1.0667;

        if (parseInt(calendar.offsetWidth) >= 240) {

          baseFontSize = el.fontSize;
          navigation = 24;
          headerConstant = 1.1111111111;
          otherGridsConstant = 1.1111111111;

        } else {

          baseFontSize = el.fontSize * 0.75;
          navigation = 18;
          headerConstant = 1.197916667;
          otherGridsConstant = 1.296296296;
        }

        daysFontSize = baseFontSize;
        weekDaysFontSize = baseFontSize / weekDaysConstant;
        headerFontSize = baseFontSize * headerConstant;
        otherGridsFontSize = baseFontSize * otherGridsConstant

        if (calendar.querySelector(".eon-date-daysGrid")) {
          calendar.querySelector(".eon-date-daysGrid .eon-date-grid").style.fontSize = baseFontSize + "px";
          calendar.querySelector(".eon-date-daysGrid .eon-date-weekDays").style.fontSize = weekDaysFontSize + "px";
        }

        if (calendar.querySelector(".eon-date-monthsGrid")) {
          calendar.querySelector(".eon-date-monthsGrid").style.fontSize = otherGridsFontSize + "px"
        }

        if (calendar.querySelector(".eon-date-yearsGrid")) {
          calendar.querySelector(".eon-date-yearsGrid").style.fontSize = otherGridsFontSize + "px"
        }

        calendar.querySelector(".eon-date-header").style.fontSize = headerFontSize + "px";

        calendar.querySelector(".eon-date-back i").style.fontSize = navigation + "px";
        calendar.querySelector(".eon-date-previous i").style.fontSize = navigation + "px";
        calendar.querySelector(".eon-date-next i").style.fontSize = navigation + "px";
      },
      /*
      @function (private) _goBack
      @description It shows the corresponding grid
      @param {Object} backButton
      */
      goBack: function (backButton) {

        var el = this;

        if (backButton.dataset.grid == "days") {

          el._showDaysGrid();

        } else if (backButton.dataset.grid == "months") {

          el._showMonthsGrid();

        } else if (backButton.dataset.grid == "years") {

          el._showYearsGrid();
        }

      },
      /*
      @function (private) _goToPrevious
      @description Handles the redirection to whether the month/year/day previous callback
      @param {Object} button
      */
      goToPrevious: function (button) {

        var el = this;

        if (el._misc.selector.type == "month") {
          el._goToPreviousMonth(button);
        } else if (el._misc.selector.type == "year") {
          el._goToPreviousYear(button);
        } else if (el._misc.selector.type == "yearsRange") {
          el._goToPreviousYearsRange(button);
        }
      },
      /*
      @function (private) _goToPreviousMonth
      @description Fills the daysGrid with the previous Month
      @param {Object} button
      */
      goToPreviousMonth: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {

          var previous = el._getPreviousByMonth(el._misc.current.year, el._misc.current.month);


          el._fillDaysGrid(previous.year, previous.month);
          el._updateHeaderSelectors("daysGrid", previous.year, previous.month);
        }
      },
      /*
      @function (private) _goToNext
      @description Handles the redirection to whether the month/year/day next callback
      @param {Object} button
      */
      goToNext: function (button) {

        var el = this;

        if (el._misc.selector.type == "month") {
          el._goToNextMonth(button);
        } else if (el._misc.selector.type == "year") {
          el._goToNextYear(button);
        } else if (el._misc.selector.type == "yearsRange") {
          el._goToNextYearsRange(button);
        }
      },
      /*
      @function (private) _goToNextMonth
      @description Fills the daysGrid with the next Month
      @param {Object} button
      */
      goToNextMonth: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {
          var next = el._getNextByMonth(el._misc.current.year, el._misc.current.month);

          el._fillDaysGrid(next.year, next.month);
          el._updateHeaderSelectors("daysGrid", next.year, next.month);
        }
      },
      /*
      @function (private) _goToPreviousYear
      @description Changes the actual year, for the previous one
      @param {Object} button
      */
      goToPreviousYear: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {

          el._misc.current.year = el._misc.current.year - 1;

          el._updateHeaderSelectors("monthsGrid");
          el._fillMonthsGrid();
        }
      },
      /*
      @function (private) _goToNextYear
      @description Changes the actual year, for the next one
      @param {Object} button
      */
      goToNextYear: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {

          el._misc.current.year = parseInt(el._misc.current.year) + 1;

          el._updateHeaderSelectors("monthsGrid");
          el._fillMonthsGrid();
        }
      },
      /*
      @function (private) _goToPreviousYearsRange
      @description Changes the actual years range, for the previous one
      @param {Object} button
      */
      goToPreviousYearsRange: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {
          el._misc.selector.range.start = el._misc.selector.range.start - 12;
          el._misc.selector.range.end = el._misc.selector.range.start + 11;

          el._fillYearsGrid();
          el._updateHeaderSelectors("yearsGrid");
        }
      },
      /*
      @function (private) _goToNextYearsRange
      @description Changes the actual years range, for the next one
      @param {Object} button
      */
      goToNextYearsRange: function (button) {

        var el = this;

        if (button.dataset.disabled != "true") {
          el._misc.selector.range.end = el._misc.selector.range.end + 12;
          el._misc.selector.range.start = el._misc.selector.range.end - 11;

          el._fillYearsGrid();
          el._updateHeaderSelectors("yearsGrid");
        }
      },
      /*
      @function (private) _fillDaysGrid
      @description Fills the grid with the corresponding days for the provided year/month
      @param {Number} year
      @param {Number} month
      */
      fillDaysGrid: function (year, month) {

        var el = this;

        var gridWeeks = el._refs.calendar.querySelector(".eon-date-grid").children;

        var monthDays = eon.time.getDaysInMonth(year, month);
        var monthFirstWeekDay = eon.time.getFirstWeekDay("en", year, month, "long");

        var previous = el._getPreviousByMonth(year, month);
        var next = el._getNextByMonth(year, month);

        var previousMonthDaysToDisplay = el._getPreviousMonthDaysToDisplay(year, month);
        var nextMonthDaysToDisplay = el._getNextMonthDaysToDisplay(year, month, monthDays, previousMonthDaysToDisplay);

        var week = gridWeeks[0];

        var currentWeek = 0;
        var weekDaysCount = 0;
        var dummyDay, day;

        var areLimits = (el._misc.min.active == true || el._misc.max.active == true);

        if (areLimits) {
          var isPreviousMonthMin = el._isMinMonth(previous.year, previous.month);
          var isMinMonth = el._isMinMonth(year, month);
          var isNextMonthMin = el._isMinMonth(next.year, next.month);

          var isPreviousMonthMax = el._isMaxMonth(previous.year, previous.month);
          var isMaxMonth = el._isMaxMonth(year, month);
          var isNextMonthMax = el._isMaxMonth(next.year, next.month);

          var disableDayAsMin, disableDayAsMax;
        }

        el._misc.current.year = year;
        el._misc.current.month = month;

        //Create previous Month Days
        for (var i = 0; i < previousMonthDaysToDisplay.length; i++) {
          if (el._misc.weekDays.keys[i] == monthFirstWeekDay) {
            break;
          } else {

            day = week.children[weekDaysCount];

            if (day) {

              day.innerHTML = previousMonthDaysToDisplay[i];
              day.classList.add("eon-date-previousMonth", "eon-fg2-disabled");
              day.classList.remove("eon-date-current", "eon-bg2-active");

              day.setAttribute("year", previous.year);
              day.setAttribute("month", previous.month);
              day.setAttribute("day", previousMonthDaysToDisplay[i]);

              if (areLimits) {

                disableDayAsMin = (isPreviousMonthMin && previousMonthDaysToDisplay[i] < el._misc.min.day || isMinMonth || isNextMonthMin) ? true : false;
                disableDayAsMax = (isPreviousMonthMax && previousMonthDaysToDisplay[i] > el._misc.max.day) ? true : false;

                day.dataset.disabled = ((disableDayAsMin && disableDayAsMax) || (disableDayAsMin || disableDayAsMax)) ? "true" : "false";
              }

            }

            weekDaysCount++;
          }
        }

        //Create actual month days
        for (var i = 1; i <= monthDays; i++) {

          day = week.children[weekDaysCount];

          if (day) {
            day.classList.remove("eon-date-previousMonth", "eon-fg2-disabled", "eon-date-nextMonth", "eon-fg2-disabled", "eon-date-current", "eon-bg2-active");
            day.innerHTML = i;

            day.setAttribute("year", year);
            day.setAttribute("month", parseInt(month));
            day.setAttribute("day", i);

            weekDaysCount++;

            if (weekDaysCount == 7) {

              week = gridWeeks[currentWeek + 1];
              weekDaysCount = 0;

              currentWeek++;
            }

            if (areLimits) {

              disableDayAsMin = (isMinMonth && i < el._misc.min.day || isNextMonthMin) ? true : false;
              disableDayAsMax = (isPreviousMonthMax || isMaxMonth && i > el._misc.max.day) ? true : false;

              day.dataset.disabled = ((disableDayAsMin && disableDayAsMax) || (disableDayAsMin || disableDayAsMax)) ? "true" : "false";
              day.classList[day.dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");
            }

          }
        }

        //Create next month days
        for (var i = 0; i < nextMonthDaysToDisplay.length; i++) {

          day = week.children[weekDaysCount];

          if (day) {

            day.innerHTML = nextMonthDaysToDisplay[i];
            day.classList.add("eon-date-nextMonth", "eon-fg2-disabled");
            day.classList.remove("eon-date-current", "eon-bg2-active");

            day.setAttribute("year", next.year);
            day.setAttribute("month", parseInt(next.month));
            day.setAttribute("day", nextMonthDaysToDisplay[i]);

            weekDaysCount++;

            if (weekDaysCount == 7) {

              week = gridWeeks[currentWeek + 1];
              weekDaysCount = 0;

              currentWeek++;
            }

            if (areLimits) {

              disableDayAsMin = (isNextMonthMin && nextMonthDaysToDisplay[i] < el._misc.min.day) ? true : false;
              disableDayAsMax = (isNextMonthMax && nextMonthDaysToDisplay[i] > el._misc.max.day || isMaxMonth || isPreviousMonthMax) ? true : false;

              day.dataset.disabled = ((disableDayAsMin && disableDayAsMax) || (disableDayAsMin || disableDayAsMax)) ? "true" : "false";
            }

          }
        }

        var currentDay = el._refs.daysGrid.querySelector('[day="' + parseInt(el._misc.selected.day) + '"][month="' + parseInt(el._misc.selected.month) + '"][year="' + parseInt(el._misc.selected.year) + '"]');

        if (currentDay) {
          el._highlight(currentDay);
        }
      },
      /*
      @function (private) _fillMonthsGrid
      @description When the monthsGrid is about the be showed, we handle the ones that the user can click on, and also point out the current month if needed
      */
      fillMonthsGrid: function () {

        var el = this;
        var monthsGrid = el._refs.calendar.querySelector(".eon-date-monthsGrid");
        var months = monthsGrid.querySelectorAll('[data-index]');
        var month, disableMonthAsMin, disableMonthAsMax;

        for (var i = 0; i < 12; i++) {

          year = el._misc.current.year;
          month = months[i].dataset.index;

          months[i].dataset.year = year;
          months[i].classList.remove("eon-date-current");
          months[i].classList.remove("eon-bg2-active");

          if (el._misc.current.year == el._misc.min.year || el._misc.current.year == el._misc.max.year) {

            disableMonthAsMin = (year == el._misc.min.year && month < el._misc.min.month || year < el._misc.min.year) ? true : false;
            disableMonthAsMax = (year == el._misc.max.year && month > el._misc.max.month || year > el._misc.max.year) ? true : false;

            months[i].dataset.disabled = ((disableMonthAsMin || disableMonthAsMax) || (disableMonthAsMin && disableMonthAsMax)) ? "true" : "false";

          } else {
            months[i].dataset.disabled = "false";
          }

          months[i].classList[months[i].dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");
        }

        var currentMonthCell = monthsGrid.querySelector('[data-index ="' + parseInt(el._misc.selected.month) + '"][data-year ="' + parseInt(el._misc.selected.year) + '"]');

        if (currentMonthCell) {
          el._highlight(currentMonthCell, el.querySelector(".eon-date-monthsGrid .eon-date-current"));
        }
      },
      /*
      @function (private) _fillYearsGrid
      @description Fills the grid with the year corresponding to the years range
      */
      fillYearsGrid: function () {

        var el = this;
        var yearsGrid = el._refs.calendar.querySelector(".eon-date-yearsGrid");
        var yearsGridRow = yearsGrid.children;
        var year = el._misc.selector.range.start;
        var row;
        var selectedYearCell;

        for (var i = 0; i < yearsGridRow.length; i++) {

          row = yearsGridRow[i];

          for (var j = 0; j < 4; j++) {
            row.children[j].innerHTML = year;
            row.children[j].dataset.year = year;
            row.children[j].classList.remove("eon-date-current");
            row.children[j].classList.remove("eon-bg2-active");

            disableYearAsMin = (parseInt(year) < el._misc.min.year) ? true : false;
            disableYearAsMax = (parseInt(year) > el._misc.max.year) ? true : false;
            row.children[j].dataset.disabled = ((disableYearAsMin || disableYearAsMax) || (disableYearAsMin && disableYearAsMax)) ? "true" : "false";
            row.children[j].classList[row.children[j].dataset.disabled == "true" ? "add" : "remove"]("eon-fg2-disabled");

            year++;
          }
        }

        selectedYearCell = yearsGrid.querySelector('[data-year ="' + el._misc.selected.year + '"]')

        if (selectedYearCell) {
          el._highlight(selectedYearCell, el.querySelector(".eon-date-yearsGrid .eon-date-current"));
        }
      },
      /*
      @function (private) _selectDay
      @description Selects the day clicked and runs its default behavior if the user didnt specify a custom callback
      @param {Object} dayButton
      */
      selectDay: function (dayButton) {

        if (dayButton.dataset.disabled != "true") {

          var el = this;

          // We have to add 1 to the month becouse the indexes are set starting from 0 to match it with the way js Date works
          var dateObj = el._formatObj({ day: dayButton.getAttribute("day"), month: (parseInt(dayButton.getAttribute("month")) + 1), year: dayButton.getAttribute("year") });
          var formattedValue = eon.time.generateOutput(dateObj, el.valueFormat);

          el._misc.selected.day = parseInt(dayButton.getAttribute("day"));
          el._misc.selected.month = parseInt(dayButton.getAttribute("month"));
          el._misc.selected.year = parseInt(dayButton.getAttribute("year"));

          el._highlight(dayButton, el._refs.calendar.querySelector(".eon-date-daysGrid .eon-date-grid .eon-date-current"));
          el._hideCalendar();

          el.value = formattedValue;

        }
      },
      /*
      @function (private) _selectMonth
      @description Selects the month clicked and runs its default behavior if the user didnt specify a specific funcion
      @param {Object} monthButton
      */
      selectMonth: function (monthButton) {

        var el = this;

        if (monthButton.dataset.disabled != "true") {

          el._misc.current.month = parseInt(monthButton.dataset.index);
          el._misc.selected.month = parseInt(monthButton.dataset.index);
          el._misc.selected.year = parseInt(el._misc.current.year);

          if (el._refs.daysGrid) {

            el._fillDaysGrid(el._misc.current.year, el._misc.current.month);
            el._showDaysGrid();

          } else {

            // We have to add 1 to the month becouse the indexes are set starting from 0 to match it with the way js Date works
            var dateObj = el._formatObj({ day: undefined, month: (parseInt(monthButton.dataset.index) + 1), year: el._misc.current.year });
            var formattedValue = eon.time.generateOutput(dateObj, el.valueFormat);

            el._highlight(monthButton, el.querySelector(".eon-date-monthsGrid .eon-date-current"));

            el._misc.preventUpdate = true;
            el.value = formattedValue;

          }
        }
      },
      /*
      @function (private) _selectYear
      @description Selects the year clicked and runs its default behavior if the user didnt specify a specific funcion
      @param {Object} yearButton
      */
      selectYear: function (yearButton) {

        var el = this;

        if (yearButton.dataset.disabled != "true") {

          el._misc.current.year = parseInt(yearButton.dataset.year);
          el._misc.selected.year = parseInt(yearButton.dataset.year);

          if (el._refs.daysGrid) {

            if (el._isMinMonth(el._misc.current.year, el._misc.current.month)) {
              el._misc.current.month = el._misc.min.month;
              el._misc.selected.month = el._misc.min.month;
            }

            el._fillDaysGrid(el._misc.current.year, el._misc.current.month);
            el._showDaysGrid();

          } else if (el._refs.monthsGrid) {

            if (el._isMinMonth(el._misc.current.year, el._misc.current.month)) {
              el._misc.current.month = el._misc.min.month;
              el._misc.selected.month = el._misc.min.month;
            }

            el._showMonthsGrid();

          } else {

            var dateObj = el._formatObj({ day: undefined, month: undefined, year: yearButton.dataset.year });
            var formattedValue = eon.time.generateOutput(dateObj, el.valueFormat);

            el._highlight(yearButton, el.querySelector(".eon-date-yearsGrid .eon-date-current"));

            el._misc.preventUpdate = true;

            el.value = formattedValue;

          }
        }
      },
      /*
      @function (private) _showDaysGrid
      @description Shows the daysGrid and hides the other ones, it also updates the headerSelectors
      */
      showDaysGrid: function () {

        var el = this;

        el._refs.daysGrid.style.zIndex = 0;
        el._refs.daysGrid.style.opacity = 1;

        if (el._refs.monthsGrid) {
          el._hideMonthsGrid();
        }

        if (el._refs.yearsGrid) {
          el._hideYearsGrid();
        }

        el._updateHeaderSelectors("daysGrid");
        el._misc.selector.type = "month";
      },
      /*
      @function (private) _hideDaysGrid
      @description Hides the days grid
      */
      hideDaysGrid: function () {

        var el = this;

        el._refs.daysGrid.style.zIndex = -1;
        el._refs.daysGrid.style.opacity = 0;
      },
      /*
      @function (private) _showMonthsGrid
      @description Shows the months grid and hides the other ones, it also updates the headerSelectors
      */
      showMonthsGrid: function () {

        var el = this;

        el._refs.monthsGrid.style.zIndex = 0;
        el._refs.monthsGrid.style.opacity = 1;

        if (el._refs.daysGrid) {
          el._hideDaysGrid();
        }

        if (el._refs.yearsGrid) {
          el._hideYearsGrid();
        }

        el._updateHeaderSelectors("monthsGrid");
        el._fillMonthsGrid();

        el._misc.selector.type = "year";
      },
      /*
      @function (private) _hideMonthsGrid
      @description Hides the monthsGrid
      */
      hideMonthsGrid: function () {

        var el = this;

        el._refs.monthsGrid.style.zIndex = -1;
        el._refs.monthsGrid.style.opacity = 0;
      },
      /*
      @function (private) _showYearsGrid
      @description Shows the yearsGrid and hides the other ones, it also updates the headerSelectors
      */
      showYearsGrid: function () {

        var el = this;

        el._refs.yearsGrid.style.zIndex = 1;
        el._refs.yearsGrid.style.opacity = 1;

        if (el._refs.monthsGrid) {
          el._hideMonthsGrid();
        }

        if (el._refs.daysGrid) {
          el._hideDaysGrid();
        }

        el._misc.selector.range.start = parseInt(el._misc.current.year) - 6;
        el._misc.selector.range.end = parseInt(el._misc.current.year) + 5;

        el._fillYearsGrid();
        el._updateHeaderSelectors("yearsGrid");

        el._misc.selector.type = "yearsRange";
      },
      /*
      @function (private) _hideYearsGrid
      @description Hides the yearsGrid
      */
      hideYearsGrid: function () {

        var el = this;

        el._refs.yearsGrid.style.zIndex = -1;
        el._refs.yearsGrid.style.opacity = 0;
      },
      /*
      @function (private) {Object} _getPreviousByMonth
      @description Gets the previos month, the year is returned aswell in case the current month is January
      @param {Number} year
      @param {Number} month
      */
      getPreviousByMonth: function (year, month) {

        if (parseInt(month) - 1 < 0) {
          month = 11
          year = parseInt(year) - 1;
        } else {
          month = parseInt(month) - 1;
        }

        return {
          "month": month,
          "year": year
        };
      },
      /*
      @function (private) {Object} _getNextByMonth
      @description Gets the next month, the year is returned aswell in case the current month is December
      @param {Number} year
      @param {Number} month
      */
      getNextByMonth: function (year, month) {

        if (parseInt(month) + 1 > 11) {
          month = 0
          year = parseInt(year) + 1;
        } else {
          month = parseInt(month) + 1;
        }

        return {
          "month": month,
          "year": year
        };
      },
      /*
      @function (private) {Array} _getPreviousMonthDaysToDisplay
      @description Gets the previos month days to show along the current month
      @param {Number} year
      @param {Number} month
      */
      getPreviousMonthDaysToDisplay: function (year, month) {

        var el = this;

        var monthFirstWeekDay = eon.time.getFirstWeekDay("en", year, month, "long");

        var previous = el._getPreviousByMonth(year, month);
        var previousMonthDaysToDisplay = [];
        var previousMonthDays;

        var daysUntilMonthStart = 0;

        previousMonthDays = eon.time.getDaysInMonth(previous.year, previous.month)

        for (var i = 0; i < el._misc.weekDays.keys.length; i++) {
          if (monthFirstWeekDay != el._misc.weekDays.keys[i]) {
            previousMonthDaysToDisplay.push(previousMonthDays - i)
          } else {
            break;
          }
        }

        return previousMonthDaysToDisplay.reverse();
      },
      /*
      @function (private) {Array} _getNextMonthDaysToDisplay
      @description Gets the next month days to show along the current month
      @param {Number} year
      @param {Number} month
      @param {Number} monthDays
      @param {Array} previousMonthDaysToDisplay
      */
      getNextMonthDaysToDisplay: function (year, month, monthDays, previousMonthDaysToDisplay) {

        var el = this;

        var nextMonthDaysToDisplay = [];
        var remainingDaysToFill = 42 - monthDays - previousMonthDaysToDisplay.length;

        //Theres no need to know which is the current month as they all start the same
        for (var i = 1; i <= remainingDaysToFill; i++) {
          nextMonthDaysToDisplay.push(i);
        }

        return nextMonthDaysToDisplay;
      },
      /*
      @function (private) _updateLabel
      @description Updates the label node with the new label
      */
      updateLabel: function () {

        var el = this;

        if (el.label != "") {
          el.querySelector(".eon-date-label").innerHTML = el.label;
        }

      },
      /*
      @function (private) _updateDisabled
      @description Updates disabled status
      */
      updateDisabled: function () {

        var el = this;

        if (el.type == "calendar") {

          var selectedCell = el.querySelector(".eon-bg2-active");

          if (eon.util.isTrue(el.disabled)) {

            if (selectedCell) {
              selectedCell.classList.remove("eon-bg2-active");
              selectedCell.classList.add("eon-bg2-disabled");
            }

            el._refs.data.classList.add("eon-fg2-disabled");
            el._refs.header.classList.add("eon-fg2-disabled");
            el._refs.body.classList.add("eon-fg2-disabled");

          } else {

            if (selectedCell) {
              selectedCell.classList.add("eon-bg2-active");
              selectedCell.classList.remove("eon-bg2-disabled");
            }

            el._refs.data.classList.remove("eon-fg2-disabled");
            el._refs.header.classList.remove("eon-fg2-disabled");
            el._refs.body.classList.remove("eon-fg2-disabled");

          }

        } else {

          if (eon.util.isTrue(el.disabled)) {

            el._refs.subInputsWrapper.classList.add("eon-fg2-disabled");

            el._refs.calendarButton.classList.remove("eon-fg2");
            el._refs.calendarButton.classList.add("eon-fg2-disabled");

            el._refs.data.classList.add("eon-fg2-disabled");
            el._refs.main.classList.add("eon-fg2-disabled");

            el._hideCalendar();

          } else {

            el._refs.subInputsWrapper.classList.remove("eon-fg2-disabled");

            el._refs.calendarButton.classList.add("eon-fg2");
            el._refs.calendarButton.classList.remove("eon-fg2-disabled");

            el._refs.data.classList.remove("eon-fg2-disabled");
            el._refs.main.classList.remove("eon-fg2-disabled");

          }

        }

      },
      /*
      @function (private) _updateReadOnly
      @description Updates readonly status
      */
      updateReadOnly: function () {

        var el = this;

        if (eon.util.isTrue(el.readonly)) {

          el._refs.subInputs.first.setAttribute("readonly", "true");
          el._refs.subInputs.second.setAttribute("readonly", "true");
          el._refs.subInputs.third.setAttribute("readonly", "true");

          el._refs.calendarButton.classList.remove("eon-fg2-hoverable");

        } else {

          el._refs.subInputs.first.removeAttribute("readonly");
          el._refs.subInputs.second.removeAttribute("readonly");
          el._refs.subInputs.third.removeAttribute("readonly");

          el._refs.calendarButton.classList.add("eon-fg2-hoverable");

          if (el.type != "calendar") {
            el._hideCalendar();
          }

        }

      },
      /*
      @function (private) _updateValue
      @description Allows the user tu set a new value to the element
      @param {Object} value
      */
      updateValue: function () {

        var el = this;

        if (!el._misc.preventUpdate) {

          var format = el.valueFormat;

          var subInputsWrapper = el._refs.subInputsWrapper;
          var dayInput = subInputsWrapper.querySelector('[data-field="day"] input');
          var monthInput = subInputsWrapper.querySelector('[data-field="month"] input');
          var yearInput = subInputsWrapper.querySelector('[data-field="year"] input');

          var value = el.value;

          var valueObj, day, month, year;

          if (value.constructor == Date) {

            day = value.toLocaleString([], {
              day: "numeric"
            });

            month = value.toLocaleString([], {
              month: "numeric"
            });

            year = value.toLocaleString([], {
              year: "numeric"
            });

            valueObj = {
              day: day,
              month: month,
              year: year
            }

          } else {

            valueObj = eon.time.getDateObjectFromString(el.value, el.valueFormat);

          }

          el._misc.current.day = valueObj.day;
          el._misc.current.month = valueObj.month - 1;
          el._misc.current.year = valueObj.year;

          el._misc.selected.day = el._misc.current.day;
          el._misc.selected.month = el._misc.current.month;
          el._misc.selected.year = el._misc.current.year;

          dayInput.value = el._format(valueObj.day, el._misc.mask.day.format);
          monthInput.value = el._format(valueObj.month, el._misc.mask.month.format);
          yearInput.value = el._format(valueObj.year, el._misc.mask.year.format);

          el._refresh();

        }

        el._misc.preventUpdate = false;

      },

      /*
      @function (private) _updateInvalid
      @description Updates the invalid status
      */
      updateInvalid: function () {

        var el = this;
        var classListFn = eon.util.isTrue(el.invalid) ? "add" : "remove";

        el.classList[classListFn]("eon-date-error");

      }

    },
    functions: {
      /*
      @function clear
      @description Empties the value
      */
      clear: function () {
        this.value = "";
      },
      /*
      @function reset
      @description Resets the value of the element to the default one, if no default is provided then empties the value
      */
      reset: function () {

        var el = this;

        if (el.default != "") {
          el.value = el.default;
        } else {
          el.clear();
        }

      },

      /*
      @function updateDescription
      @description Updates the description value for the element
      */
      updateDescription: function (text) {
        this._misc.descriptionText = text;
        this._refs.description.innerHTML = this._misc.descriptionText;
      },
      /*
      @function resetDescription
      @description Updates the description value for the element
      */
      resetDescription: function () {

        var el = this;
        var description = el.tooltip != "" ? el.tooltip : "";

        el._misc.descriptionText = description;
        el._refs.description.innerHTML = description;

      }
    },
    onCreated: function () {

      var el = this;

      eon.createCallback("onEnter", this);

      if (eon.util.isTouchScreen()) {
        el.dataset.touch = "true";
      }

      eon.registerPathListener(el, "date");

    },
    onInit: function () {

      var el = this;

      el._setupMisc();
      el._setupRefs();
      el._setupOverlay();
      el._setupType();
      el._setupDescription();

    },
    onRender: function () {
      this._setup();
    },
    onPropertyChanged: function (key, oldVal, newVal) {

      switch (key) {
        case "label":
          this._updateLabel();
          break;
        case "disabled":
          this._updateDisabled();
          break;
        case "readonly":
          this._updateReadOnly();
          break;
        case "value":
          this._updateValue();
          break;
        case "invalid":
          this._updateInvalid();
          break;
      }

    },
    onWindowResize: function () {

      var el = this;

      if (el._misc.modal.active) {
        el._hideCalendar();
      }

    }
  });

</script>
        <style>
          eon-date {
  min-width: 200px;
}
eon-date[inline="true"] {
  display: inline-block;
  width: 200px;
}
eon-date[type="calendar"][inline="false"] {
  width: 100%;
}
.eon-date-data {
  height: 18px;
  margin-bottom: 5px;
  flex-grow: 0;
  display: flex;
}
eon-date[label=""] .eon-date-data {
  display: none;
}
.eon-date-label {
  font-size: 15px;
  height: 100%;
  flex-grow: 1;
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
}
.eon-date-counter {
  height: 100%;
  flex-grow: 0;
  font-size: 11px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
}
eon-date[disabled="true"] {
  pointer-events: none;
}
.eon-date-main {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  border-bottom-width: 1px;
  border-bottom-style: solid;
}
.eon-date-input {
  position: relative;
  display: flex;
  flex-direction: column;
  width: 100%;
  border: none;
}
.eon-date-subInputs {
  display: flex;
  background-color: transparent;
  padding: 10px;
  align-items: center;
  flex-grow: 1;
  flex-basis: 0;
}
.eon-date-subInputs div[data-field="day"],
.eon-date-subInputs div[data-field="month"] {
  text-align: center;
  flex-basis: 0;
  flex-grow: 1;
}
.eon-date-subInputs div[data-field="year"] {
  text-align: center;
  flex-basis: 0;
  flex-grow: 1.5;
}
.eon-date-subInputs div[data-field] {
  transition: 0.3s all;
  outline: none;
  display: flex;
}
.eon-date-subInput input {
  width: 100%;
  box-sizing: border-box;
  background-color: transparent;
  border: none;
  outline: none;
  text-align: center;
  color: inherit;
  font-size: 15px;
  padding: 0;
  -moz-appearance: textfield;
}
.eon-date-subInput input[readonly="true"] {
  cursor: default;
}
input[type=number]::-webkit-outer-spin-button,
input[type=number]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.eon-date-separator {
  display: flex;
  padding: 0 5px;
  align-items: center;
  flex-basis: 0;
  flex-grow: 0;
  justify-content: center;
  font-size: 15px;
}
.eon-date-button {
  margin-right: 10px;
  flex-grow: 0;
}
eon-date:not([readonly="true"]) .eon-date-button {
  cursor: pointer;
}
.eon-date-underline {
  position: relative;
  display: block;
  width: auto;
}
.eon-date-underline:before,
.eon-date-underline:after {
  position: absolute;
  bottom: -1px;
  width: 0;
  height: 2px;
  content: "";
  -webkit-transition: 0.5s ease all;
  -moz-transition: 0.5s ease all;
  transition: 0.5s ease all;
}
.eon-date-underline:before {
  left: 50%;
}
.eon-date-underline:after {
  right: 50%;
}
.eon-date-focus .eon-date-underline:before,
.eon-date-focus .eon-date-underline:after {
  width: 50%;
}
eon-date[toolbar="true"] {
  border: none;
}
eon-date[toolbar="true"] .eon-date-underline {
  display: none;
}
eon-date[toolbar="true"] .eon-date-main {
  border: none;
}
eon-date[toolbar="true"] .eon-date-data {
  display: none;
}
.eon-date-overlay {
  position: fixed;
  margin: 0;
  z-index: 100;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.eon-date-overlay.eon-date-device {
  display: flex;
  justify-content: center;
  align-items: center;
}
.eon-date-overlay.eon-date-device .eon-date-calendar {
  width: 90%;
  max-width: 90%;
  min-width: 90%;
  position: relative;
}
@media screen and (orientation: landscape) {
  .eon-date-overlay.eon-date-device .eon-date-calendar {
    height: 90%;
    min-height: 90%;
    max-height: 90%;
  }
}
.eon-date-calendar {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
  position: relative;
  flex-direction: column;
  min-height: 180px;
}
[readonly="true"] .eon-date-calendar {
  pointer-events: none;
}
.eon-date-year,
.eon-date-month {
  cursor: pointer;
}
eon-date:not([selectable*=y]) .eon-date-year:hover,
.eon-date-yearsGridSelectors .eon-date-year:hover {
  text-decoration: none;
  cursor: default;
}
eon-date:not([data-touch="true"]) .eon-date-day:hover {
  cursor: pointer;
}
eon-date[disabled="true"] {
  pointer-events: none;
}
.eon-date-wrapper {
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  height: 100%;
  cursor: default;
  align-items: center;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-header {
  font-size: 20px;
  font-weight: bold;
  position: relative;
  display: flex;
  width: 100%;
  height: 18%;
  max-height: 60px;
  text-transform: capitalize;
  box-sizing: border-box;
  align-items: center;
  justify-content: center;
}
div[data-disabled="true"]:hover {
  cursor: default;
  text-decoration: none;
}
.eon-date-header .eon-date-hidden {
  display: none;
}
.eon-date-daysGridSelectors,
.eon-date-monthsGridSelectors,
.eon-date-yearsGridSelectors {
  display: flex;
  height: 100%;
  top: 0;
  bottom: 0;
  align-items: center;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-daysGridSelectors .eon-date-month {
  display: flex;
  height: 100%;
  padding-right: 1.5%;
  align-items: center;
  flex-grow: 1;
  justify-content: flex-end;
}
.eon-date-monthsGridSelectors .eon-date-month {
  display: none;
}
.eon-date-daysGridSelectors .eon-date-year {
  display: flex;
  height: 100%;
  padding-left: 1.5%;
  align-items: center;
  flex-grow: 1;
  justify-content: flex-start;
}
.eon-date-monthsGridSelectors .eon-date-year {
  display: flex;
  height: 100%;
  align-items: center;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-leftNavigation {
  position: absolute;
  left: 0;
  display: flex;
  width: 22%;
  max-width: 120px;
  height: 100%;
  top: 0;
  bottom: 0;
}
.eon-date-rightNavigation {
  position: absolute;
  right: 0;
  display: flex;
  width: 22%;
  max-width: 120px;
  height: 100%;
  top: 0;
  bottom: 0;
  justify-content: flex-end;
}
.eon-date-previous,
.eon-date-next,
.eon-date-back,
.eon-date-close {
  display: flex;
  width: 50%;
  height: 100%;
  cursor: pointer;
  -webkit-transition: background-color 0.3s;
  -moz-transition: background-color 0.3s;
  -o-transition: background-color 0.3s;
  transition: background-color 0.3s;
  align-items: center;
  flex-grow: 0;
  justify-content: center;
}
.eon-date-body {
  position: relative;
  display: flex;
  box-sizing: border-box;
  width: 100%;
  padding: 0 5px 10px 5px;
  flex-grow: 1;
}
.eon-date-body .eon-date-row div {
  display: flex;
  text-transform: capitalize;
  align-items: center;
  flex-basis: 0;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-body .eon-bg1-hoverable:not([data-disabled="true"]) {
  cursor: pointer;
}
.eon-date-body div[data-disabled="true"] {
  text-decoration: line-through;
  pointer-events: none;
  cursor: default;
}
.eon-date-daysGrid {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
}
.eon-date-daysGrid .eon-date-weekDays {
  font-size: 15px;
  font-weight: bold;
  display: flex;
  width: 100%;
  height: 30px;
  margin-bottom: 10px;
  text-transform: capitalize;
  align-items: center;
  flex-grow: 0;
  justify-content: center;
}
.eon-date-daysGrid .eon-date-grid {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
}
.eon-date-row,
.eon-date-week {
  display: flex;
  width: 100%;
  flex-grow: 1;
}
.eon-date-monthsGrid,
.eon-date-yearsGrid {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  display: flex;
  flex-direction: column;
  padding: 5px;
  -webkit-transition: opacity 0.1s;
  -moz-transition: opacity 0.1s;
  -o-transition: opacity 0.1s;
  transition: opacity 0.1s;
  opacity: 0;
}
.eon-date-dayHeader {
  display: flex;
  height: 100%;
  cursor: default;
  align-items: center;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-day {
  display: flex;
  align-items: center;
  flex-basis: 0;
  flex-grow: 1;
  justify-content: center;
}
.eon-date-description {
  margin-top: 5px;
  font-size: 14px;
  width: 100%;
}
          </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-date[theme="claro"],
eon-overlay[theme="claro"],
div[data-theme="claro"] eon-date,
body[data-theme="claro"] eon-date {
  /* - Chrome 56,
    - Safari 5-10.0
    - iOS Safari 4.2-10.2
    - Opera 15-43
    - Opera Mobile >12
    - Android Browser 2.1-4.4.4
    - Samsung Internet
    - UC Browser for Android
    - QQ Browser */
  /* Firefox 4-18 */
  /* Firefox 19-50 */
  /* - Internet Explorer 1011
    - Internet Explorer Mobile 10-11 */
}
eon-date[theme="claro"][disabled="true"] .eon-date-current,
eon-overlay[theme="claro"][disabled="true"] .eon-date-current,
div[data-theme="claro"] eon-date[disabled="true"] .eon-date-current,
body[data-theme="claro"] eon-date[disabled="true"] .eon-date-current {
  background: #f1fbff;
}
eon-date[theme="claro"] .eon-fg1-hoverable:hover,
eon-overlay[theme="claro"] .eon-fg1-hoverable:hover,
div[data-theme="claro"] eon-date .eon-fg1-hoverable:hover,
body[data-theme="claro"] eon-date .eon-fg1-hoverable:hover {
  -webkit-text-fill-color: #47cce2;
}
eon-date[theme="claro"] .eon-date-underline:before,
eon-overlay[theme="claro"] .eon-date-underline:before,
div[data-theme="claro"] eon-date .eon-date-underline:before,
body[data-theme="claro"] eon-date .eon-date-underline:before,
eon-date[theme="claro"] .eon-date-underline:after,
eon-overlay[theme="claro"] .eon-date-underline:after,
div[data-theme="claro"] eon-date .eon-date-underline:after,
body[data-theme="claro"] eon-date .eon-date-underline:after {
  background: #47cce2;
}
eon-date[theme="claro"].eon-date-focus .eon-date-label,
eon-overlay[theme="claro"].eon-date-focus .eon-date-label,
div[data-theme="claro"] eon-date.eon-date-focus .eon-date-label,
body[data-theme="claro"] eon-date.eon-date-focus .eon-date-label {
  color: #47cce2;
}
eon-date[theme="claro"].eon-date-error .eon-date-underline:before,
eon-overlay[theme="claro"].eon-date-error .eon-date-underline:before,
div[data-theme="claro"] eon-date.eon-date-error .eon-date-underline:before,
body[data-theme="claro"] eon-date.eon-date-error .eon-date-underline:before,
eon-date[theme="claro"].eon-date-error .eon-date-underline:after,
eon-overlay[theme="claro"].eon-date-error .eon-date-underline:after,
div[data-theme="claro"] eon-date.eon-date-error .eon-date-underline:after,
body[data-theme="claro"] eon-date.eon-date-error .eon-date-underline:after {
  background: #c33232;
}
eon-date[theme="claro"].eon-date-error .eon-date-main,
eon-overlay[theme="claro"].eon-date-error .eon-date-main,
div[data-theme="claro"] eon-date.eon-date-error .eon-date-main,
body[data-theme="claro"] eon-date.eon-date-error .eon-date-main {
  border-color: #c33232;
}
eon-date[theme="claro"].eon-date-error .eon-date-label,
eon-overlay[theme="claro"].eon-date-error .eon-date-label,
div[data-theme="claro"] eon-date.eon-date-error .eon-date-label,
body[data-theme="claro"] eon-date.eon-date-error .eon-date-label,
eon-date[theme="claro"].eon-date-error .eon-date-description,
eon-overlay[theme="claro"].eon-date-error .eon-date-description,
div[data-theme="claro"] eon-date.eon-date-error .eon-date-description,
body[data-theme="claro"] eon-date.eon-date-error .eon-date-description {
  color: #c33232;
}
eon-date[theme="claro"][disabled="true"] ::-webkit-input-placeholder,
eon-overlay[theme="claro"][disabled="true"] ::-webkit-input-placeholder,
div[data-theme="claro"] eon-date[disabled="true"] ::-webkit-input-placeholder,
body[data-theme="claro"] eon-date[disabled="true"] ::-webkit-input-placeholder {
  color: #565656;
}
eon-date[theme="claro"][disabled="true"] :-moz-placeholder,
eon-overlay[theme="claro"][disabled="true"] :-moz-placeholder,
div[data-theme="claro"] eon-date[disabled="true"] :-moz-placeholder,
body[data-theme="claro"] eon-date[disabled="true"] :-moz-placeholder {
  color: #565656;
}
eon-date[theme="claro"][disabled="true"] ::-moz-placeholder,
eon-overlay[theme="claro"][disabled="true"] ::-moz-placeholder,
div[data-theme="claro"] eon-date[disabled="true"] ::-moz-placeholder,
body[data-theme="claro"] eon-date[disabled="true"] ::-moz-placeholder {
  color: #565656;
}
eon-date[theme="claro"][disabled="true"] :-ms-input-placeholder,
eon-overlay[theme="claro"][disabled="true"] :-ms-input-placeholder,
div[data-theme="claro"] eon-date[disabled="true"] :-ms-input-placeholder,
body[data-theme="claro"] eon-date[disabled="true"] :-ms-input-placeholder {
  color: #565656 !important;
}
          </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}          </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Date">
        <eon-date></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Days">
        <eon-date selectable="dmy" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Months">
        <eon-date selectable="my" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <eon-showcase-item title="Years">
        <eon-date selectable="y" inline="false" type="calendar"></eon-date>
      </eon-showcase-item>
      <div class="d-date-placeholder"></div>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="radio" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>RADIO</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-radio-tmp', '.d-radio-pg');">
    <div name="example">
      <eon-showcase-item title="Radio Group">
        <eon-group class="d-radio-group" name="radioOptions">
          <eon-radio class="d-top-margin" label="Red" value="Red"></eon-radio>
          <eon-radio class="d-top-margin" label="Blue" value="Blue"></eon-radio>
          <eon-radio class="d-top-margin" label="Orange" checked="true" value="Orange"></eon-radio>
        </eon-group>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-group class="d-radio-group" name="disabledRadio">
          <eon-radio class="d-top-margin" label="Read only radio" value="readOpt" checked="true" readonly="true"></eon-radio>
          <eon-radio class="d-top-margin" label="Disabled radio" value="diableOpt" disabled="true"></eon-radio>
        </eon-group>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-radio-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-radio-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        .d-top-margin {
          margin-top: 10px;
        }

        .eon-group-label {
          height: 0 !important;
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-radio"] = "eon/ui/eon-radio/";
        eon.registry.registerTheme("eon-radio", "claro");

        eon.imports.paths["eon-group"] = "eon/ui/eon-group/";
        eon.registry.registerTheme("eon-group", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-radio", "eon-group", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-radio-config">
        <template class="eon-unselectable">
  <div class="eon-radio-radio">
    <input class="eon-radio-input eon-unselectable" type="radio">
    <label class="eon-radio-label eon-fg1 eon-unselectable" onclick="">
      <div class="eon-radio-labelText"></div>
    </label>
  </div>
</template>

<script>
  eon.element({

    name: "eon-radio",
    style: "",

    themed: true,

    properties: {
      /*
        @property {String} value 
        @description Radio value
      */
      value: {
        value: "",
        reflect: true
      },
      /*
        @property {String} label 
        @description Radio label
      */
      label: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} disabled 
        @description Radio deactivation
        Values can be: true or false
        Default: false
      */
      disabled: {
        value: false,
        reflect: true
      },
      /*
        @property {Boolean} readonly 
        @description Toggles the readonly status of the radio element
        Default: false
      */
      readonly: {
        value: false,
        reflect: true
      },
      /*
        @property {Boolean} checked
        @description Radio checked status
        Values can be: true or false
      */
      checked: {
        value: "",
        reflect: true
      },
      /*
      @property {Boolean} default
      @description Sets checked status by default when the element is reset
      Values can be: true or false
      */
      default: {
        value: "",
        reflect: true
      },
      /*
       @property {Boolean} inline 
       @description Space that occupy the radio inside parent container.
       By default, its size adapts to its content
       Values can be: true or false
       Default: true
     */
      inline: {
        value: true,
        reflect: true
      },
    },

    privateProperties: {
      /*
        @property (private) {Object} _refs 
        @description Object with  references
      */
      refs: {
        value: {}
      }
    },
    functions: {
      /*
      @function clear
      @description Unchecks the element
      */
      clear: function () {
        this.checked = false;
      },
      /*
      @function reset
      @description Resets checked status of the element to the default one
      */
      reset: function () {
        var el = this;

        if (eon.util.isTrue(el.default)) {
          el.checked = el.default;
        } else {
          el.clear();
        }

      }
    },
    privateFunctions: {
      /*
        @function (private) _setValue
        @description Set new radio value
        @param {String} newVal [new radio value]
      */
      setValue: function () {
        var el = this;

        el._refs.input.setAttribute("value", el.value);
        el._refs.input.setAttribute("id", el.value);
        el._refs.label.setAttribute("for", el.value);

        eon.triggerCallback("onChange", this);
      },
      /*
        @function (private) _updateDisabled
        @description Update disabled status
      */
      updateDisabled: function () {

        // Radio disabled
        if (!eon.util.isTrue(this.disabled)) {

          this._refs.input.disabled = false;
          this._refs.input.classList.remove("eon-radio-disabledRadio", "eon-radio-checkedDisabledRadio");

          // Radio NOT disabled
        } else {

          this._refs.input.disabled = true;
          this._refs.input.classList.add("eon-radio-disabledRadio");

        }
      },

      /*
      @function (private) _updateReadonly
      @description Updates readonly status
      */
      updateReadonly: function () {
        var el = this;

        if (eon.util.isTrue(el.readonly)) {
          el._refs.input.setAttribute("readonly", "true");
        } else {
          el._refs.input.removeAttribute("readonly");
        }

      },

      /*
        @function (private) _setCheck
        @description Call method to update check status  
      */
      // setCheck: function (oldVal) {
      setCheck: function () {
        if (eon.util.isTrue(this.checked)) {
          this._handleCheck();
        } else {
          this._handleUncheck();
        }
      },

      /*
        @function (private) _handleCheck
        @description Changes different element values to check status
      */
      handleCheck: function (radioGroupHost) {
        if (this.parentNode.tagName.toLowerCase() == "eon-group") {
          var radioGroupHost = this.parentNode;
        }
        if (radioGroupHost) {
          var previousChecked = eon.Radio.checkedRadios[radioGroupHost.name];
          var previousSpan;

          // Uncheck previousRadio
          if (previousChecked) {
            previousSpan = previousChecked.querySelector(".eon-radio-outspan");
            previousChecked._refs.input.checked = false;
            previousChecked._checked = false;
            previousChecked.setAttribute("checked", "false");
            previousChecked._refs.input.classList.remove("eon-radio-checkRadio");
            previousSpan.classList.remove("eon-radio-checked");
            eon.createCallback("onUncheck", this);

          }

          radioGroupHost.value = this.value;
          radioGroupHost._checked = true;
          radioGroupHost.disabled = eon.util.isTrue(this.disabled) ? true : false;
          eon.Radio.checkedRadios[radioGroupHost.name] = this;
        }

        // Check new Radio
        this._refs.input.checked = true;
        this._refs.input.classList.add("eon-radio-checkRadio");
        this._refs.span.classList.add("eon-radio-checked");
        eon.triggerCallback("onCheck", this);
      },

      /*
        @function (private) _handleUncheck
        @description Changes different element values to uncheck status 
      */
      handleUncheck: function () {
        if (this.parentNode.tagName.toLowerCase() == "eon-group") {
          var radioGroupHost = this.parentNode;
        }

        if (radioGroupHost) {
          radioGroupHost.value = "";
          // Group checked
          radioGroupHost._checked = false;
          radioGroupHost.disabled = eon.util.isTrue(this.disabled) ? true : false;
          eon.Radio.checkedRadios[radioGroupHost.name] = "";
        }

        this._refs.input.checked = false;
        this._refs.input.classList.remove("eon-radio-checkRadio");
        this._refs.span.classList.remove("eon-radio-checked");
        eon.triggerCallback("onCheck", this);
      },


      /*
        @function (private) _createRefs
        @description Creates fast access to elements
      */
      createRefs: function () {
        var el = this;

        el._refs.input = el.template.querySelector(".eon-radio-input");
        el._refs.label = el.template.querySelector(".eon-radio-label");
        el._refs.span = document.createElement("span");
        el._refs.inspan = document.createElement("span");
      }

    },

    onCreated: function () {
      eon.Radio = eon.Radio || {
        checkedRadios: {}
      };

      eon.createCallback("onChange", this);
      eon.createCallback("onCheck", this);
      eon.createCallback("onUncheck", this);

      this._createRefs();
    },

    onRender: function () {
      var el = this;

      if (this.parentNode.tagName.toLowerCase() == "eon-group") {
        var radioGroupHost = el.parentNode;
        el._refs.input.setAttribute("name", radioGroupHost.name);
      }

      el._refs.span.classList.add("eon-radio-outspan", "eon-bg3-border");
      el._refs.inspan.classList.add("eon-radio-inspan");
      el._refs.label.insertBefore(el._refs.span, el._refs.label.firstChild);
      el._refs.span.appendChild(el._refs.inspan);

      el.checked = el.default != "" && el.checked == "" ? el.default : el.checked;
      el._setValue();
      el._updateDisabled();
      el._updateReadonly();
      el._setCheck();
      el.querySelector(".eon-radio-labelText").innerHTML = el.label;

      // Checking a radio option
      el._refs.label.addEventListener("click", function (e) {
        if ((!eon.util.isTrue(el.disabled) && !eon.util.isTrue(el.readonly)) || el.disabled == null) {
          el.checked = true;
        }

      }, false);

    },

    onPropertyChanged: function (attrName, oldVal, newVal) {
      switch (attrName) {
        case "disabled":
          this._updateDisabled();
          break;
        case "readonly":
          this._updateReadonly();
          break;
        case "checked":
          this._setCheck();
          break;
        case "label":
          this.querySelector(".eon-radio-labelText").innerHTML = newVal;
          break;
        case "value":
          this._setValue();
          break;
      }
    }

  });

</script>
        <style>
          eon-radio {
  position: relative;
}
eon-radio[inline="true"] {
  display: inline-block;
}
eon-radio[inline="true"] .eon-radio-radio {
  width: auto;
}
eon-radio[readonly="true"] .eon-radio-input {
  pointer-events: none;
}
eon-radio[readonly="true"] .eon-radio-label {
  pointer-events: none;
  cursor: auto;
}
.eon-radio-radio {
  width: 100%;
  display: flex;
}
.eon-radio-input {
  display: none;
}
.eon-radio-label {
  display: flex;
  cursor: pointer;
  align-items: flex-start;
}
.eon-radio-outspan {
  box-sizing: border-box;
  min-width: 18px;
  min-height: 18px;
  margin: 0 5px 0 0;
  padding: 2px;
  border-width: 2px;
  border-style: solid;
  border-radius: 100%;
  display: flex;
}
.eon-radio-inspan {
  box-sizing: border-box;
  width: 10px;
  height: 10px;
  visibility: hidden;
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
  border-radius: 100%;
}
.eon-radio-input:checked + .eon-radio-label .eon-radio-inspan {
  visibility: visible;
  -webkit-transition: 0.3s ease all;
  -moz-transition: 0.3s ease all;
  transition: 0.3s ease all;
}
.eon-radio-input:disabled + .eon-radio-label,
.eon-radio-input[type="radio"]:disabled + .eon-radio-label .eon-radio-outspan {
  cursor: auto;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-radio[theme="claro"],
div[data-theme="claro"] eon-radio,
body[data-theme="claro"] eon-radio {
  /* Change the radio style when it's checked */
  /* Change the inside radio style when it's checked */
  /* Style of the circle when the radio it's disabled */
  /* Circle style when the radio it's checked and disabled */
}
eon-radio[theme="claro"] .eon-radio-input:checked + .eon-radio-label .eon-radio-outspan,
div[data-theme="claro"] eon-radio .eon-radio-input:checked + .eon-radio-label .eon-radio-outspan,
body[data-theme="claro"] eon-radio .eon-radio-input:checked + .eon-radio-label .eon-radio-outspan {
  border-color: #47cce2;
}
eon-radio[theme="claro"] .eon-radio-input:checked + .eon-radio-label .eon-radio-inspan,
div[data-theme="claro"] eon-radio .eon-radio-input:checked + .eon-radio-label .eon-radio-inspan,
body[data-theme="claro"] eon-radio .eon-radio-input:checked + .eon-radio-label .eon-radio-inspan {
  border-color: #47cce2;
  background-color: #47cce2;
}
eon-radio[theme="claro"] .eon-radio-input:disabled + .eon-radio-label .eon-radio-outspan,
div[data-theme="claro"] eon-radio .eon-radio-input:disabled + .eon-radio-label .eon-radio-outspan,
body[data-theme="claro"] eon-radio .eon-radio-input:disabled + .eon-radio-label .eon-radio-outspan {
  border-color: #cecece;
}
eon-radio[theme="claro"] .eon-radio-input:disabled + .eon-radio-label,
div[data-theme="claro"] eon-radio .eon-radio-input:disabled + .eon-radio-label,
body[data-theme="claro"] eon-radio .eon-radio-input:disabled + .eon-radio-label,
eon-radio[theme="claro"] .eon-radio-input[type="radio"]:disabled + .eon-radio-label .eon-radio-outspan,
div[data-theme="claro"] eon-radio .eon-radio-input[type="radio"]:disabled + .eon-radio-label .eon-radio-outspan,
body[data-theme="claro"] eon-radio .eon-radio-input[type="radio"]:disabled + .eon-radio-label .eon-radio-outspan {
  color: #cecece;
}
eon-radio[theme="claro"] .eon-radio-checkedDisabledRadio:checked + .eon-radio-label .eon-radio-inspan,
div[data-theme="claro"] eon-radio .eon-radio-checkedDisabledRadio:checked + .eon-radio-label .eon-radio-inspan,
body[data-theme="claro"] eon-radio .eon-radio-checkedDisabledRadio:checked + .eon-radio-label .eon-radio-inspan,
eon-radio[theme="claro"] .eon-radio-disabledRadio[type="radio"]:checked + .eon-radio-label .eon-radio-inspan,
div[data-theme="claro"] eon-radio .eon-radio-disabledRadio[type="radio"]:checked + .eon-radio-label .eon-radio-inspan,
body[data-theme="claro"] eon-radio .eon-radio-disabledRadio[type="radio"]:checked + .eon-radio-label .eon-radio-inspan {
  border-color: #cecece;
  background-color: #cecece;
}
        </style>
      </div>
      <div class="eon-group-config">
        <style>
  .eon-group-label {
    font-size: 15px;
    height: 18px;
    margin-bottom: 5px;
    display: block;
  }
</style>

<template>
  <label class="eon-group-label"></label>
</template>

<script>
  eon.element({

    name: "eon-group",

    properties: {
      /*
        @property {String} name 
        @description Group name
      */
      name: {
        value: "",
        reflect: true
      },
      /*
        @property {String} value 
        @description Group value
      */
      value: {
        value: "",
        reflect: true
      },
      /*
        @property (private) {Boolean} disabled 
        @description Sets its value to true when the selected element is disabled
      */
      disabled: {
        value: false
      },

      /*
        @property {String} label
        @description Label for the element
      */
      label: {
        value: "",
        reflect: true,
        reflectDefault: true
      },

    },

    privateProperties: {
      /*
        @property (private) {Boolean} _checked 
        @description Sets its value to true when checks an element
      */
      checked: {
        value: false
      },
      /*
        @property (private) {String} _formElement 
        @description Set that group is a form element
        Value: radio
      */
      formElement: {
        value: "radio"
      }
    },

    privateFunctions: {
      /*
        @function (private) _updateLabel
        @description Updates the label node with the new label
      */
      updateLabel: function () {

        var el = this;

        if (el.label != "") {
          el.querySelector(".eon-group-label").innerHTML = el.label;
        }

      },
    },

    onRender: function () {
      var el = this;
      var sourceNodes = this.getSourceElements();
      var documentFragment = document.createDocumentFragment();
      var length = sourceNodes.length;
      var currentEl;

      el._updateLabel();

      while (sourceNodes.length) {
        currentEl = sourceNodes.shift();
        documentFragment.appendChild(currentEl);
      }

      el.appendChild(documentFragment);

    },

    onPropertyChanged: function (key, oldVal, newVal) {

      switch (key) {
        case "label":
          this._updateLabel();
          break;
      }

    }

  });
</script>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Radio Group">
        <eon-group class="d-radio-group" name="radioOptions">
          <eon-radio class="d-top-margin" label="Red" value="Red"></eon-radio>
          <eon-radio class="d-top-margin" label="Blue" value="Blue"></eon-radio>
          <eon-radio class="d-top-margin" label="Orange" checked="true" value="Orange"></eon-radio>
        </eon-group>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-group class="d-radio-group" name="disabledRadio">
          <eon-radio class="d-top-margin" label="Read only radio" value="readOpt" checked="true" readonly="true"></eon-radio>
          <eon-radio class="d-top-margin" label="Disabled radio" value="diableOpt" disabled="true"></eon-radio>
        </eon-group>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="slider" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>SLIDER</h1>

  <!-- SHOWCASE -->
  <eon-viewer class="viewer-slider" load="initializeShowcase('.d-slider-tmp', '.d-slider-pg');">
    <div name="example">
      <eon-showcase-item title="Slider">
        <eon-slider></eon-slider>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-slider display-visibility="true" disabled="true"></eon-slider>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-slider-pg"></eon-showcase>
    </div>
  </eon-viewer>
  
  <!-- Showcase content -->
  <template class="d-slider-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        .d-left-margin {
          margin-left: 10px;
        }

        .d-top-margin {
          margin-top: 10px;
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-slider"] = "eon/ui/eon-slider/";
        eon.registry.registerTheme("eon-slider", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-slider", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-slider-config">
        <template>

  <div class="eon-slider-wrapper eon-fg1 eon-unselectable">
    <div class="eon-slider-shell">

      <div class="eon-slider-track eon-bg5"></div>
      <input class="eon-slider-slider" type="range" />
      <div class="eon-slider-fill">
        <div class="eon-slider-thumb"></div>
      </div>

    </div>

    <div class="eon-slider-display">0</div>
  </div>

  <div class="eon-slider-description"></div>

</template>

<script>
  eon.element({

    name: "eon-slider",
    style: "",

    themed: true,

    properties: {

      /*
        @property {String} name 
        @description Slider name
      */
      name: {
        value: "",
        reflect: true
      },
      /*
        @property {String} value 
        @description Slider value
      */
      value: {
        value: "",
        reflect: true
      },
      /*
      @property {Number} default
      @description Value of the element when the element is reseted, if will also be the value of the element if no value is provided
      */
      default: {
        value: "",
        reflect: true
      },
      /*
        @property {Number} min 
        @description Slider minimum range value
        Value must be an integer
      */
      min: {
        value: 0,
        reflect: true
      },
      /*
        @property {Number} max 
        @description Slider maximum range value
        Value must be an integer
      */
      max: {
        value: 100,
        reflect: true
      },
      /*
        @property {Boolean} disabled 
        @description Slider deactivation
        Default: false
      */
      disabled: {
        value: false,
        reflect: true
      },
      /*
        @property {Boolean} readonly 
        @description Toggles the readonly status of the spinner
        Default: false
      */
      readonly: {
        value: false,
        reflect: true
      },
      /*
        @property {String} orientation 
        @description Slider orientation
        Values can be: horizontal or vertical
        Default: horizontal
      */
      orientation: {
        value: "horizontal",
        reflect: true
      },
      /*
        @property {String} size 
        @description Slider size respect to container
        Value must be number percentage
        Default: 50%
      */
      size: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} displayVisibility 
        @description Slider range value visibility
        Default: false
      */
      displayVisibility: {
        value: false,
        reflect: true
      },
      /*
        @property {String} displayAlign 
        @description Slider range value align
        Different depending the orientation of the slider
        Vertical slider: center
        Horizontal slider: center, left or right
        Default: right
      */
      displayAlign: {
        value: "right",
        reflect: true
      },
      /*
        @property {String} displayPosition 
        @description Slider range value position
        Different depending the orientation of the slider
        Vertical slider: top, bottom, left or right
        Horizontal slider: top & bottom
        Default: bottom
      */
      displayPosition: {
        value: "bottom",
        reflect: true
      },
      /*
       @property {Boolean} inline 
       @description Space that occupy the slider inside parent container.
       By default, its size adapts to its content
       Values can be: true or false
       Default: true
     */
      inline: {
        value: true,
        reflect: true
      },
      /*
      @property {String} tooltip
      @description Text to be shown for the element
      */
      tooltip: {
        value: "",
        reflect: true,
        reflectDefault: false
      },
      /*
      @property {Boolean} invalid
      @description Whether the element meets the requirements or not
      */
      invalid: {
        value: false,
        reflect: true,
        reflectDefault: false
      }
    },

    privateProperties: {
      /*
        @property (private) {String} _formElement 
        @description Set that slider is a form element
        Value: slider
      */
      formElement: {
        value: "slider"
      },
      /*
        @property (private) {String} _currentValue
        @description Current slider value
     */
      currentValue: {
        value: ""
      },
      /*
        @property (private) {Object} _thumbEvent
        @description Store slider thumb event
      */
      thumbEvent: {
        value: {}
      },
      /*
        @property (private) {Object} _refs 
        @description Object with  references
      */
      refs: {
        value: {}
      },
      /*
        @property (private) {Object} _misc 
        @description Stores slider useful data.
      */
      misc: {
        value: {}
      },
    },
    functions: {
      /*
      @function clear
      @description Empties the value
      */
      clear: function () {
        this.value = 0;
      },
      /*
      @function reset
      @description Resets the value of the element to the default one, if no default is provided then empties the value
      */
      reset: function () {
        var el = this;

        if (el.default != "") {
          el.value = el.default;
        } else {
          el.clear();
        }

      },

      /*
      @function updateDescription
      @description Updates the description value for the element
      */
      updateDescription: function (text) {
        this._misc.descriptionText = text;
        this._refs.description.innerHTML = this._misc.descriptionText;
      },
      /*
      @function resetDescription
      @description Updates the description value for the element
      */
      resetDescription: function () {

        var el = this;
        var description = el.tooltip != "" ? el.tooltip : "";

        el._misc.descriptionText = description;
        el._refs.description.innerHTML = description;

      }
    },
    privateFunctions: {

      /*
      @function (private) {String} _setupDescription
      @description Creates the touch blur
      */
      setupDescription: function () {

        var el = this;

        if (el.tooltip != "") {
          el.updateDescription(el.tooltip);
        }

      },

      /*
        @function (private) _setValue
        @param {String} newVal [new slider value]
      */
      setValue: function () {
        var el = this;
        el._refs.slider.value = el.value;
        el._currentValue = el.value;
        el._updateSlider(true);

        if (el.orientation == "vertical") {
          el._updateVerticalHeight();
        }

        eon.triggerCallback("onChange", el);

      },
      /*
        @function (private) _createRefs
        @description Creates fast access to elements
      */
      createRefs: function () {
        var el = this;

        el._refs.shell = el.template.querySelector(".eon-slider-shell");
        el._refs.track = el.template.querySelector(".eon-slider-track");
        el._refs.slider = el.template.querySelector(".eon-slider-slider");
        el._refs.fill = el.template.querySelector(".eon-slider-fill");
        el._refs.thumb = el.template.querySelector(".eon-slider-thumb");
        el._refs.range = el.template.querySelector(".eon-slider-display");
        el._refs.description = el.template.querySelector(".eon-slider-description");
      },
      /*
        @function (private) _updateSlider
        @description Update slider view
        @param {Boolean} privateValueKey [Whether the value key will be the private or the public one]
      */
      updateSlider: function (privateValueKey) {
        var el = this;

        var sliderVal = el._refs.slider.value;
        var thumbPosition = -5.7;
        el._misc.percentValue = (sliderVal - el._refs.slider.min) / (el._refs.slider.max - el._refs.slider.min); /* percentage slider value */
        var valueKey = privateValueKey ? "__value" : "value";

        el._refs.range.innerHTML = sliderVal;
        (el.orientation == "horizontal") ? el._horizontalSlider() : el._verticalSlider();
        el[valueKey] = el._refs.slider.value;
        el._refs.slider.setAttribute("value", el._refs.slider.value);
      },


      /*
      @function (private) _horizontalSlider
      @description Specify horizontal slider view style
      */
      horizontalSlider: function () {
        var el = this;
        var trackSize = 100;

        el.style.width = (el.size) ? el.size : el.offsetWidth;
        el._refs.fill.style.width = (el._misc.percentValue * trackSize) + "%";
        el._refs.track.style.width = trackSize + "%"; /* adjust for border */
      },

      /*
        @function (private) _verticalSlider
        @description Specify vertical slider view style
      */
      verticalSlider: function () {
        var el = this;

        // If its the first the verticalSlider is called then we have
        // to invert the width and height
        if (el._misc.first) {
          // Stores the width of the input when it is horizontal,
          // then use it as height when it is vertical
          var actualNodeWidth = el.offsetWidth;
          el._misc.first = false;

          // Sets an automatic width for the vertical slider, because the value of the height when
          // it was horizontal may not be a correct measurement
          el.style.width = "auto";

          // Sets height of slider depending on the properties inline and size 
          if (eon.util.isTrue(el.inline)) {
            el.style.height = el.size == "" ? "auto" : el.size;
          } else {
            el.style.height = el.size;
          }

          // Sets the property to place the slider in vertical for IE and Firefox browsers
          (eon.util.getBrowser() == "Firefox" || eon.util.getBrowser() == "IE") ? el._refs.slider.setAttribute("orient", "vertical") : null;
        }

      },

      /*
        @function (private) _thumbMotion
        @description Slider thumb movement and update slider value
      */
      thumbMotion: function () {
        var el = this;

        el._refs.thumb.addEventListener("pointerdown", startThumb, false);
        el._thumbEvent = startThumb;

        function startThumb(e) {
          if (!eon.util.isTrue(el.readonly)) {
            el._startY = e.clientY;
            document.addEventListener("pointermove", moveThumb, false);
            document.addEventListener("pointerup", function stopThumb(e) {

              document.removeEventListener("pointermove", moveThumb, false);
              document.removeEventListener("pointerup", stopThumb, false);
            }, false);
          }
        }

        function moveThumb(e) {
          el._interactionSlider(e);
          el._updateCurrentValue();
        }

      },

      /*
        @function (private) _interactionSlider
        @description Functionality when interacting with the slider
        Only for thumb interaction and click interaction on iOS devices
        @param {Object} e [Event]
      */
      interactionSlider: function (e) {
        var el = this;
        var trackSize;
        var max = parseInt(el.max);
        var min = parseInt(el.min);

        if (el.orientation == "horizontal") {
          trackSize = el._refs.slider.offsetWidth;
          var shellLeft = el._refs.shell.getBoundingClientRect().left;
          var trackRight = shellLeft + trackSize;

          if (e.clientX <= trackRight && e.clientX >= shellLeft) {
            el._refs.slider.value = (((e.clientX - shellLeft) / trackSize) * (max - min)) + min;
            el._updateSlider();
          }

        } else {
          trackSize = el._refs.slider.offsetHeight;
          var shellTop = el._refs.shell.getBoundingClientRect().top;
          var trackBottom = shellTop + trackSize;
          var sliderNode = parseInt(el._refs.slider.value);
          var positionDiff;

          if (e.clientY <= trackBottom && e.clientY >= shellTop) {

            // When interaction is moving the thumb
            if (el._startY) {
              positionDiff = el._startY - e.clientY;
              el._startY = e.clientY;

              // Vertical click slider on iOS
            } else {
              positionDiff = el._refs.fill.getBoundingClientRect().top - e.clientY;
            }

            el._refs.fill.style.height = (el._refs.fill.offsetHeight + positionDiff) + "px";
            el._refs.slider.value = ((el._refs.fill.offsetHeight / trackSize) * (max - min)) + min;
            el._refs.range.innerHTML = el._refs.slider.value;
            el.value = el._refs.slider.value;
          }
        }
      },

      /*
        @function (private) _setSliderListeners
        @description Sets slider listeners
      */
      setSliderListeners: function () {
        var el = this;

        // On IE, Safari and IOS devices not work event "input"
        // So is necessary a click event
        el._refs.slider.addEventListener("click", function (e) {
          if (!eon.util.isTrue(el.readonly)) {
            if (eon.util.getBrowser() == "IE" || eon.util.getBrowser() == "Safari" || /iPad|iPhone|iPod/.test(navigator.platform)) {
              // On iOS devices and IE clicking on the input does not update its status
              // Is is necessary  to do it programmatically
              el._interactionSlider(e);
              el._updateCurrentValue();
            }
            // For the vertical slider it is necessary to update its height when clicking
            el._updateVerticalHeight();

          }
        }, false);

        el._refs.slider.addEventListener("input", function (e) {
          if (!eon.util.isTrue(el.readonly)) {
            el._updateSlider();
            el._updateCurrentValue();
          }
        }, false);
      },

      /*
        @function (private) _updateDisabled
        @description Updates disabled status and activates the thumb motion when it is not disabled
      */
      updateDisabled: function () {
        var el = this;

        if (!eon.util.isTrue(el.disabled)) {
          el._refs.slider.removeAttribute("disabled");
          el._refs.shell.classList.remove("eon-slider-disabled");
          el._refs.fill.classList.remove("eon-bg5-disabled");
          el._refs.fill.classList.add("eon-fg3");
          el._refs.thumb.classList.remove("eon-bg5-disabled");
          el._refs.thumb.classList.add("eon-fg3");
          el._refs.track.classList.remove("eon-bg5-disabled");

          el._thumbMotion();

        } else {
          el._refs.slider.setAttribute("disabled", "true");
          el._refs.shell.classList.add("eon-slider-disabled");
          el._refs.fill.classList.add("eon-bg5-disabled");
          el._refs.fill.classList.remove("eon-fg3");
          el._refs.thumb.classList.add("eon-bg5-disabled");
          el._refs.thumb.classList.remove("eon-fg3");
          el._refs.track.classList.add("eon-bg5-disabled");
          el._refs.thumb.removeEventListener("pointerdown", el._thumbEvent, false);
        }

      },

      /*
      @function (private) _updateReadonly
      @description Updates readonly status
      */
      updateReadonly: function () {
        var el = this;

        if (eon.util.isTrue(el.readonly)) {
          el._refs.slider.setAttribute("readonly", "true");
        } else {
          el._refs.slider.removeAttribute("readonly");
        }

      },

      /*
      @function (private) _updateInvalid
      @description Updates the invalid status
      */
      updateInvalid: function () {

        var el = this;
        var classListFn = eon.util.isTrue(el.invalid) ? "add" : "remove";

        el.classList[classListFn]("eon-slider-error");

      },

      /*
        @function (private) _updateCurrentValue
        @description Updates slider current value and trigger onChange callback
      */
      updateCurrentValue: function () {
        var el = this;
        (el.value !== el._currentValue) ? eon.triggerCallback("onChange", el) : null;
        el._currentValue = (el.value !== el._currentValue) ? el.value : el._currentValue;
      },

      /*
       @function (private) _verifyScreenResolution
       @description Set device type
     */
      verifyScreenResolution: function () {
        var el = this;

        // Small devices view
        if (window.innerWidth <= eon.tabletWidth) {
          el.setAttribute("version", "tablet");

          // Desktop view
        } else {
          el.setAttribute("version", "desktop");
        }

        el._updateSlider();

      },

      /*
       @function (private) _updateVerticalHeight
       @description Updates fill's height on vertical sliders
     */
      updateVerticalHeight: function () {
        var el = this;

        if (el.orientation == "vertical") {
          el._refs.fill.style.height = (el._misc.percentValue * 100) + "%";
        }
      }

    },

    onCreated: function () {
      eon.createCallback("onChange", this);
      this._createRefs();

      this._misc.first = true;
      this._misc.descriptionText = "";
    },

    onRender: function () {
      var el = this;

      el.value = el.default != "" && el.value == "" ? el.default : el.value;
      el._refs.slider.setAttribute("name", el.name);
      el._refs.slider.setAttribute("value", el.value);
      el._refs.slider.setAttribute("min", el.min);
      el._refs.slider.setAttribute("max", el.max);
      el.setAttribute("touch-action", "none");
      el._verifyScreenResolution();

      el._currentValue = el.value;

      el._setSliderListeners();

      if (el.orientation == "horizontal" && el.displayAlign != "center") {
        el.displayPosition = "";
      }

      el._setupDescription();
      el._updateDisabled();
      el._updateReadonly();
      el._updateVerticalHeight();

    },

    onWindowResize: function (event) {
      this._verifyScreenResolution();
    },

    onPropertyChanged: function (attrName, oldVal, newVal) {
      switch (attrName) {
        case "disabled":
          this._updateDisabled();
          break;
        case "readonly":
          this._updateReadonly();
          break;
        case "value":
          this._setValue();
          break;
        case "invalid":
          this._updateInvalid();
          break;
      }
    },

  });

</script>
        <style>
          eon-slider {
  position: relative;
}
eon-slider[inline="true"] {
  display: inline-block;
}
eon-slider[inline="true"] .eon-slider-wrapper {
  width: auto;
}
eon-slider[orientation="vertical"] .eon-slider-wrapper {
  display: inline-flex;
  width: auto;
}
eon-slider[orientation="vertical"] .eon-slider-shell {
  width: auto;
}
eon-slider[display-visibility="true"] .eon-slider-display {
  display: flex;
}
eon-slider input[type=range] {
  overflow: hidden;
  margin: 0;
  padding: 0;
  opacity: 0;
  color: transparent;
  border: 0 none;
  background: transparent;
}
eon-slider input[type=range]::-ms-track {
  overflow: hidden;
  margin: 0;
  padding: 0;
  opacity: 0;
  color: transparent;
  border: 0 none;
  background: transparent;
}
eon-slider input[type=range]:focus::-webkit-slider-runnable-track {
  border: transparent;
  background: transparent;
}
eon-slider input[type=range]:focus {
  outline: none;
}
eon-slider input[type=range]::-ms-thumb {
  width: 20px;
  height: 20px;
  background: transparent;
}
eon-slider input[type=range]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  background: transparent;
}
eon-slider input[type=range]::-webkit-slider-thumb {
  width: 20px;
  height: 20px;
  background: transparent;
  -webkit-appearance: none;
}
eon-slider input[type=range]::-ms-fill-lower {
  border: 0 none;
  background: transparent;
}
eon-slider input[type=range]::-ms-fill-upper {
  border: 0 none;
  background: transparent;
}
eon-slider input[type=range]::-ms-tooltip {
  display: none;
}
eon-slider[disable="false"] .eon-slider-thumb:active {
  transform: scale(1.2);
}
eon-slider[orientation="horizontal"] .eon-slider-slider {
  height: 10px;
}
eon-slider[orientation="horizontal"] .eon-slider-shell {
  height: 10px;
}
eon-slider[orientation="horizontal"] .eon-slider-display {
  margin-left: 15px;
  justify-content: center;
}
eon-slider[orientation="horizontal"] .eon-slider-track {
  top: calc(50% - 2px);
}
eon-slider[orientation="horizontal"] .eon-slider-fill {
  top: calc(50% - 2px);
}
eon-slider[orientation="horizontal"] .eon-slider-thumb {
  top: -5.7px;
}
eon-slider[orientation="horizontal"][display-align="left"] .eon-slider-wrapper {
  flex-direction: row-reverse;
  align-items: center;
}
eon-slider[orientation="horizontal"][display-align="right"] .eon-slider-wrapper {
  align-items: center;
}
eon-slider[orientation="horizontal"][display-position="top"] .eon-slider-wrapper {
  flex-direction: column-reverse;
  align-items: center;
}
eon-slider[orientation="horizontal"][display-position="bottom"] .eon-slider-wrapper {
  flex-direction: column;
  align-items: center;
}
eon-slider[orientation="horizontal"][display-align="right"] .eon-slider-display {
  margin-left: 15px;
  align-items: center;
}
eon-slider[orientation="horizontal"][display-align="left"] .eon-slider-display {
  margin-right: 15px;
  align-items: center;
}
eon-slider[orientation="horizontal"][display-position="bottom"] .eon-slider-display {
  width: 100%;
  margin-top: 10px;
}
eon-slider[orientation="horizontal"][display-position="top"] .eon-slider-display {
  width: 100%;
  margin-bottom: 10px;
}
eon-slider[orientation="vertical"] .eon-slider-wrapper {
  flex-direction: column;
}
eon-slider[orientation="vertical"] .eon-slider-shell {
  height: calc(100% - 35px);
}
eon-slider[orientation="vertical"] .eon-slider-track {
  left: calc(50% - 2px);
}
eon-slider[orientation="vertical"] .eon-slider-fill {
  left: calc(50% - 2px);
}
eon-slider[orientation="vertical"] {
  min-height: 150px;
}
eon-slider[orientation="vertical"] .eon-slider-shell {
  min-height: 150px;
}
eon-slider[orientation="vertical"][inline="false"] .eon-slider-slider {
  height: 100%;
}
eon-slider[orientation="vertical"] .eon-slider-slider {
  flex-grow: 1;
  width: 10px;
  left: calc(50% - 5px);
  writing-mode: bt-lr;
  -webkit-appearance: slider-vertical;
  appearance: slider-vertical;
}
eon-slider[orientation="vertical"] .eon-slider-track {
  top: 0;
  height: 100%;
}
eon-slider[orientation="vertical"] .eon-slider-fill {
  bottom: 0;
}
eon-slider[orientation="vertical"] .eon-slider-thumb {
  left: -5.7px;
}
eon-slider[orientation="vertical"] .eon-slider-display {
  justify-content: center;
  height: 20px;
  margin-top: 15px;
}
eon-slider[orientation="vertical"][display-position="top"] .eon-slider-wrapper {
  flex-direction: column-reverse;
}
eon-slider[orientation="vertical"][display-position="left"] .eon-slider-wrapper {
  flex-direction: row-reverse;
}
eon-slider[orientation="vertical"][display-position="right"] .eon-slider-wrapper {
  flex-direction: row;
}
eon-slider[orientation="vertical"][display-position="bottom"] .eon-slider-display {
  margin-top: 15px;
}
eon-slider[orientation="vertical"][display-position="top"] .eon-slider-display {
  margin-bottom: 15px;
}
eon-slider[orientation="vertical"][display-position="left"] .eon-slider-display {
  margin-right: 15px;
}
eon-slider[orientation="vertical"][display-position="right"] .eon-slider-display {
  margin-left: 15px;
}
.eon-slider-wrapper {
  display: flex;
  width: 100%;
  height: 100%;
  align-items: center;
  flex-direction: row;
}
.eon-slider-shell {
  position: relative;
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  align-content: center;
  justify-content: center;
  flex-grow: 1;
}
.eon-slider-slider {
  position: relative;
  z-index: 10;
  top: 0;
  left: 0;
  pointer-events: all !important;
}
.eon-slider-track {
  position: absolute;
  width: 4px;
  height: 4px;
  pointer-events: none;
}
.eon-slider-fill {
  position: absolute;
  z-index: 20;
  left: 0;
  width: 4px;
  height: 4px;
  pointer-events: none;
}
.eon-slider-thumb {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 15px;
  height: 15px;
  margin: 0;
  padding: 0;
  text-align: center;
  pointer-events: all !important;
  border: 0 none;
  border-radius: 50%;
}
.eon-slider-display {
  position: relative;
  display: none;
  min-width: 30px;
  min-height: 20px;
  justify-content: center;
}
.eon-slider-description {
  font-size: 14px;
  width: 100%;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-slider[theme="claro"].eon-slider-error .eon-slider-fill,
div[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-fill,
body[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-fill,
eon-slider[theme="claro"].eon-slider-error .eon-slider-thumb,
div[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-thumb,
body[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-thumb {
  background-color: #c33232;
}
eon-slider[theme="claro"].eon-slider-error .eon-slider-fill,
div[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-fill,
body[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-fill,
eon-slider[theme="claro"].eon-slider-error .eon-slider-thumb,
div[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-thumb,
body[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-thumb {
  background-color: #c33232;
}
eon-slider[theme="claro"].eon-slider-error .eon-slider-description,
div[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-description,
body[data-theme="claro"] eon-slider.eon-slider-error .eon-slider-description {
  color: #c33232;
}
        </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Slider">
        <eon-slider></eon-slider>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-slider display-visibility="true" disabled="true"></eon-slider>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->

</div>
  <eon-anchor state="text" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>TEXT</h1>

  <!-- SHOWCASE -->
  <eon-viewer class="viewer-text" load="initializeShowcase('.d-text-tmp', '.d-text-pg');">
    <div name="example">
      <eon-showcase-item title="Text">
        <eon-text class="d-top-margin" inline="false" name="text" type="text" placeholder="Type here" label="Text field" max-length="18">Some text</eon-text>
      </eon-showcase-item>
      <eon-showcase-item title="Area">
        <eon-text class="d-top-margin" inline="false" name="description" type="area" placeholder="Type here" label="Description"
          counter="true">This is a text</eon-text>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-text-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-text-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        eon-showcase-item[title="Area"] {
          min-width: 150px;
        }
        eon-showcase-item {
          height: 120px;
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-text"] = "eon/ui/eon-text/";
        eon.registry.registerTheme("eon-text", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-text", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-text-config">
        <template>

  <div class="eon-text-data eon-fg2">
    <label class="eon-text-label"></label>
    <label class="eon-text-counter"></label>
  </div>

  <div class="eon-text-main eon-bg2 eon-fg2"></div>

  <span class="eon-text-underline"></span>

  <div class="eon-text-description"></div>

</template>

<script>
  eon.element({

    name: "eon-text",
    style: "",

    themed: true,

    dependencies: [
      "../eon-scroll"
    ],

    privateProperties: {
      /*
      @property (private) {String} _formElement 
      @description Necessary property for a form
      */
      formElement: {
        value: "textbox"
      },
      /*
      @property (private) {Object} _misc
      @description Object with useful information
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {Object} _refs
      @description Object with references to frecuently queryied nodes
      */
      refs: {
        value: {},
        reflect: false
      }

    },

    properties: {
      /*
      @property {String} name
      @description Name to identify the element in a form
      */
      name: {
        value: "",
        reflect: true
      },
      /*
      @property {String} placeholder
      @description Placeholder for the user typing area
      */
      placeholder: {
        value: "",
        reflect: true
      },
      /*
      @property {String} label
      @description Label for the element
      */
      label: {
        value: "",
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {String} type
      @description Determines the type of the element (area, text, password)
      */
      type: {
        value: "text",
        reflect: true
      },
      /*
      @property {Boolean} inline 
      @description Space that occupies the button inside its parent container.
      */
      inline: {
        value: true,
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {Number} areaHeight
      @description Determines the height of the typeable area
      */
      areaHeight: {
        value: "",
        reflect: true
      },
      /*
      @property {String} maxlength
      @description Characters input limit
      */
      maxLength: {
        value: "",
        reflect: true
      },
      /*
      @property {String} counter
      @description Whether the user wants a counter or not
      */
      counter: {
        value: "false",
        reflect: true,
        reflectDefault: true
      },
      /*
      @property {String} value
      @description Value of the element
      */
      value: {
        value: "",
        reflect: true
      },
      /*
      @property {String} default
      @description Value of the element when the element is reseted, if will also be the value of the element if no value is provided
      */
      default: {
        value: "",
        reflect: true
      },
      /*
      @property {string} readonly
      @description Toggles the readonly status of the element
      */
      readonly: {
        value: false,
        reflect: true
      },
      /*
      @property {String} disabled
      @description Toggles the disabled status of the element
      */
      disabled: {
        value: false,
        reflect: true
      },
      /*
      @property {String} tooltip
      @description Text to be shown for the element
      */
      tooltip: {
        value: "",
        reflect: true,
        reflectDefault: false
      },
      /*
      @property {Boolean} invalid
      @description Whether the element meets the requirements or not
      */
      invalid: {
        value: false,
        reflect: true,
        reflectDefault: false
      }
    },

    privateFunctions: {
      /*
      @function (private) _setup
      @description Sets up all the necessary stuff for the element
      */
      setup: function () {

        var el = this;

        el._setupRefs();
        el._setupCounter();
        el._setupForType();

        el._initDefault();
        el._initValue();

        el._setupTouchBlur();
        el._setupDescription();

        el._updateLabel();
        el._updateDisabled();
        el._updateReadOnly();
        el._updateInvalid();

      },
      /*
      @function (private) _setupRefs
      @description Creates references for relevant nodes
      */
      setupRefs: function () {

        var el = this;

        el._refs.data = el.querySelector(".eon-text-data");
        el._refs.main = el.querySelector(".eon-text-main");
        el._refs.description = el.querySelector(".eon-text-description");

      },
      /*
      @function (private) _setupForType
      @description Depending on the specified type we will determine the needed setup
      */
      setupForType: function () {

        var el = this;

        if (el.type != "area") {
          el._setupAsInput();
        } else {
          el._setupAsTextarea();
        }

      },
      /*
      @function (private) _setupAsTextarea
      @description Created all nodes and events for the area type element
      */
      setupAsTextarea: function () {

        var el = this;

        el._misc.area.isNative = navigator.userAgent.match(/Tablet|Android|iPhone|iPad|iPod/i);

        if (!el._misc.area.isNative) {
          el._setupAsCustomArea();
        } else {
          el._setupAsNativeArea();
        }

        el._setupAreaEvents();

      },
      /*
      @function (private) _setupAsNativeArea
      @description Prepares the element to work as a native textarea for touch devices
      */
      setupAsNativeArea: function () {

        var el = this;

        var main = el.querySelector(".eon-text-main");
        var editable = document.createElement("div");

        // If the user has specified a height for the textarea we set up some style and listeners for its functionality
        if (el.areaHeight != "") {
          main.style.height = el.areaHeight + "px";
          main.style.cursor = "text";
        }

        editable = document.createElement("textarea");
        editable.classList.add("eon-text-editable", "eon-fg2");
        editable.setAttribute("placeholder", el.placeholder);
        editable.setAttribute("resize", false);
        editable.setAttribute("maxlength", el.maxLength);

        el._misc.area.update = function () {
          el._misc.area.preventUpdate = true;
          el.value = el._refs.editableArea.value;
          el._updateCounter();
        };

        el._refs.editableArea = editable;

        main.appendChild(editable);

      },
      /*
      @function (private) _setupAsCustomArea
      @description Prepares the element to work as a custom textarea with custom scroll
      */
      setupAsCustomArea: function () {

        var el = this;

        var main = el.querySelector(".eon-text-main");
        var scroll = document.createElement("eon-scroll");
        var editableContainer = document.createElement("div");
        var editable = document.createElement("div");

        // If the user has specified a height for the textarea we set up some style and listeners for its functionality
        if (el.areaHeight != "") {
          main.style.height = el.areaHeight + "px";
          main.style.cursor = "text";
        }

        el._misc.area.update = function () {
          var value = el._getValue();
          el._misc.area.preventUpdate = true;
          el.value = value;
          el._saveAreaInnerHTML();
          el._updateCounter();
        };

        el._refs.editableArea = editable;

        scroll.setAttribute("thickness", "8");
        scroll.setAttribute("type", "vertical");

        editable.classList.add("eon-text-editable");
        editable.setAttribute("contenteditable", "true");
        editable.setAttribute("placeholder", el.placeholder);

        eon.registerPathListener(editable);

        main.addEventListener("click", function () {

          // If the users clicks on the main node that is not covered by the editable
          if (!editable.isOnPath) {
            el._placeCaretAtEnd(editable);
          }

        });

        // Appends the new nodes
        editableContainer.appendChild(editable);
        scroll.appendChild(editableContainer);
        main.appendChild(scroll);

      },
      /*
      @function (private) _setupAreaEvents
      @description Creates the keyboard events for the area
      */
      setupAreaEvents: function () {

        var el = this;

        el._refs.editableArea.addEventListener("keydown", function (e) {

          // Checks if the key press corresponds to ENTER
          if (e.keyCode == 13) {
            eon.triggerCallback("onEnter", el)
          }

          setTimeout(function () {
            el._misc.area.update();
          }, 0);

        });

        // Updates everything needed for new inputs and prevents keyup from triggering
        el._refs.editableArea.addEventListener("input", function (e) {
          el._misc.area.inputEventTriggered = true;
        });

        // As some browsers doesnt handle spaces and different keys with the input event we also created the keyup event, 
        // which will only do stuff if the input event was not triggered
        el._refs.editableArea.addEventListener("keyup", function (e) {
          el._misc.area.inputEventTriggered = false;
        });

        el._refs.editableArea.addEventListener("focus", function () {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el.classList.add("focus");
            eon.triggerCallback("onFocus", el);
          }
        });

        el._refs.editableArea.addEventListener("blur", function () {
          el._restoreAreaInnerHTML();
          el.classList.remove("focus");
          eon.triggerCallback("onBlur", el);
        });

      },
      /*
      @function (private) _setupAsTextarea
      @description Created all nodes and events for all the types except the area
      */
      setupAsInput: function () {

        var el = this;

        var main = el.querySelector(".eon-text-main");
        var input = document.createElement("input");

        el._refs = el._refs || {};
        el._refs.input = input;

        input.setAttribute("type", el.type);
        input.setAttribute("placeholder", el.placeholder);
        input.setAttribute("maxlength", el.maxLength);
        input.classList.add("eon-fg2");

        input.addEventListener("keypress", function (e) {

          // Checks if the key press corresponds to ENTER
          if (e.keyCode == 13) {
            eon.triggerCallback("onEnter", el)
          }

        });

        input.addEventListener("input", function (e) {
          el.value = input.value;
          el._updateCounter();
        });

        input.addEventListener("focus", function (e) {
          if (!eon.util.isTrue(el.readonly) && !eon.util.isTrue(el.disabled)) {
            el.classList.add("focus");
            eon.triggerCallback("onFocus", el);
          }
        });

        input.addEventListener("blur", function (e) {
          el.classList.remove("focus");
          eon.triggerCallback("onBlur", el);
        });

        main.appendChild(input)

      },
      /*
      @function (private) _setupCounter
      @description Fills the counter with the maxlength
      */
      setupCounter: function () {

        var el = this;

        if (el.counter != "false" && el.maxLength != "") {
          var counter = el.querySelector(".eon-text-counter");
          counter.innerHTML = el.maxLength;
        }

      },
      /*
      @function (private) {String} _setupTouchBlur
      @description Creates the touch blur
      */
      setupTouchBlur: function () {

        var el = this;

        eon.registerPathListener(el);

        document.addEventListener("touchstart", function () {
          if (!el.isOnPath) {
            var typingNode = el.type == "area" ? el._refs.editableArea : el._refs.input;
            el.classList.remove("focus");
            typingNode.blur();
          }
        });

      },
      /*
      @function (private) {String} _setupDescription
      @description Creates the touch blur
      */
      setupDescription: function () {

        var el = this;

        if (el.tooltip != "") {
          el.updateDescription(el.tooltip);
        }

      },
      /*
      @function (private) {String} _saveAreaInnerHTML
      @description Triggered when typing, it saves the innerHTML of the area while the user has not exceeded the max length
      */
      saveAreaInnerHTML: function () {

        var el = this;

        if (!el._misc.area.isNative && el.maxLength != "" && !el._valueExceedsLength()) {
          el._misc.area.validValueInnerHTML = el._refs.editableArea.innerHTML;
        }

      },
      /*
      @function (private) {String} _saveAreaInnerHTML
      @description Triggered when the element is blured, if the typed value exceeds the max length it restores the previous valid innerHTML
      */
      restoreAreaInnerHTML: function () {

        var el = this;

        if (!el._misc.area.isNative && el.maxLength != "" && el._valueExceedsLength()) {

          el._refs.editableArea.innerHTML = el._misc.area.validValueInnerHTML;
          var value = el._getValue();
          el._misc.area.preventUpdate = true;
          el.value = value;
          el._updateCounter();

        }

      },
      /*
      @function (private) _initDefault
      @description If a value has been provided by the user we set it for our element
      */
      initDefault: function () {
        this.value = this.default != "" && this.value == "" ? this.default : this.value;
      },
      /*
      @function (private) _initValue
      @description Sets the initial value depending if an innerText or a value has been provided
      */
      initValue: function () {

        var el = this;

        el._misc.initialText = el.value != "" ? el.value : el._misc.initialText;

        if (el._misc.initialText != "") {

          if (el._misc.initialText.length > parseInt(el.maxLength)) {
            el._misc.initialText = el._misc.initialText.substring(0, el.maxLength);
          }

        }

        if (el.type != "area") {
          el._refs.input.value = el._misc.initialText;
        } else {
          el._refs.editableArea.innerText = el._misc.initialText;
        }

        el.__value = el._misc.initialText;

        el._updateCounter();

      },
      /*
      @function (private) {String} _getValue
      @description Returns the proper value for the element
      */
      getValue: function () {

        var value;

        if (eon.util.getBrowser() == "IE" && this.type == "area") {

          // As innerText is not usefull in IE, we take its innerHTML and parse it to give us the value
          value = this._refs.editableArea.innerHTML
            .replace(new RegExp("</p><p>", "g"), "\r\n")
            .replace(new RegExp("<br></p><p>", "g"), "\r\n")
            .replace(new RegExp("<p>", "g"), "")
            .replace(new RegExp("</p>", "g"), "")
            .replace(new RegExp("<br>", "g"), "");

        } else {

          value = this._refs.editableArea.innerText;

        }

        return value;
      },
      /*
      @function (private) {Number} _getValueLength
      @description Returns the length of the value
      */
      getValueLength: function () {

        var el = this;
        var value, valueLength;

        if (eon.util.getBrowser() == "IE" && this.type == "area") {

          // As innerText is not usefull in IE, we take its innerHTML and parse it to give us the value
          valueLength = el._refs.editableArea.innerHTML
            .replace(new RegExp("</p><p>", "g"), "~")
            .replace(new RegExp("<br></p><p>", "g"), "~")
            .replace(new RegExp("<p>", "g"), "")
            .replace(new RegExp("</p>", "g"), "")
            .replace(new RegExp("<br>", "g"), "").length;

        } else {

          value = el.value.toString();
          valueLength = Array.prototype.slice.apply(value.match(/\n/g) || []).length > 1 ? value.length - 1 : value.length;

        }

        return valueLength;
      },
      /*
      @function (private) {Boolean} _valueExceedsLength
      @description Returns a boolean whether the current value is already exceeding the maxlength or not
      */
      valueExceedsLength: function () {
        return this._getValueLength() > parseInt(this.maxLength);
      },
      /*
      @function (private) {Object} _getSelectionCoords
      @description Returns an object with the absolute position of the cursor
      */
      getSelectionCoords: function () {

        var win = window;
        var doc = win.document;
        var sel = doc.selection, range, rects, rect;
        var left = 0, top = 0, right = 0, bottom = 0;

        if (sel) {

          if (sel.type != "Control") {

            range = sel.createRange();
            range.collapse(true);
            left = range.boundingLeft;
            top = range.boundingTop;
            right = range.boundingRight;
            bottom = range.boundingBottom;

          }

        } else if (win.getSelection) {

          sel = win.getSelection();

          if (sel.rangeCount) {

            range = sel.getRangeAt(0).cloneRange();

            if (range.getClientRects) {

              range.collapse(true);
              rects = range.getClientRects();

              if (rects.length > 0) {

                rect = rects[0];

                left = rect.left;
                top = rect.top;
                right = rect.right;
                bottom = rect.bottom;
              }

            }
            // Fall back to inserting a temporary element
            if (left == 0 && top == 0) {

              var span = doc.createElement("span");

              if (span.getClientRects) {
                // Ensure span has dimensions and position by
                // adding a zero-width space character
                span.appendChild(doc.createTextNode("\u200b"));
                range.insertNode(span);
                rect = span.getClientRects()[0];
                left = rect.left;
                top = rect.top;
                right = rect.right;
                bottom = rect.bottom;
                var spanParent = span.parentNode;
                spanParent.removeChild(span);

                // Glue any broken text nodes back together
                spanParent.normalize();
              }
            }
          }
        }

        return { left: left, top: top, right: right, bottom: bottom };
      },
      /*
      @function (private) {Object} _getSelectionRange
      @description Returns the actual range of the selection
      */
      getSelectionRange: function () {
        var sel;
        if (window.getSelection) {
          sel = window.getSelection();
          if (sel.rangeCount) {
            return sel.getRangeAt(0);
          }
        } else if (document.selection) {
          return document.selection.createRange();
        }
        return null;
      },
      /*
      @function (private) {Boolean} _placeCaretAtEnd
      @description Places the caret at the end of the element
      */
      placeCaretAtEnd: function (div) {

        div.focus();

        if (typeof window.getSelection != "undefined"
          && typeof document.createRange != "undefined") {
          var range = document.createRange();
          range.selectNodeContents(div);
          range.collapse(false);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (typeof document.body.createTextRange != "undefined") {
          var textRange = document.body.createTextRange();
          textRange.moveToElementText(div);
          textRange.collapse(false);
          textRange.select();
        }
      },
      /*
      @function (private) _updateCounter
      @description Updates the counter with the current characters count left for typing
      */
      updateCounter: function () {

        var el = this;

        if (el.counter != "false") {
          el.querySelector(".eon-text-counter").innerHTML = el.maxLength != "" ? (parseInt(el.maxLength) - el._getValueLength()) : el._getValueLength();
        }

      },
      /*
      @function (private) _updateLabel
      @description Updates the label node with the new label
      */
      updateLabel: function () {

        var el = this;

        if (el.label != "") {
          el.querySelector(".eon-text-label").innerHTML = el.label;
        }

      },
      /*
      @function (private) _updateDisabled
      @description Updates disabled status
      */
      updateDisabled: function () {

        var el = this;
        var typingNode = el.type == "area" ? el._refs.editableArea : el._refs.input;

        if (!eon.util.isTrue(el.disabled)) {

          typingNode.classList.add("eon-fg2");
          typingNode.classList.remove("eon-fg2-disabled");

          el._refs.data.classList.remove("eon-fg2-disabled");
          el._refs.main.classList.remove("eon-fg2-disabled");

          el.removeAttribute("disabled");
          typingNode.removeAttribute("disabled");

        } else {

          typingNode.setAttribute("disabled", "true");

          typingNode.classList.remove("eon-fg2");
          typingNode.classList.add("eon-fg2-disabled");

          el._refs.data.classList.add("eon-fg2-disabled");
          el._refs.main.classList.add("eon-fg2-disabled");

        }
      },
      /*
      @function (private) _updateReadOnly
      @description Updates readonly status
      */
      updateReadOnly: function () {

        var el = this;
        var typingNode = el.type == "area" ? el._refs.editableArea : el._refs.input;

        if (eon.util.isTrue(el.readonly)) {

          if (el.type != "area" || el._misc.area.isNative) {
            typingNode.setAttribute("readonly", "true");
          } else {
            el._refs.editableArea.setAttribute("contenteditable", "false");
          }

        } else {

          if (el.type != "area" || el._misc.area.isNative) {
            typingNode.removeAttribute("readonly");
          } else {
            el._refs.editableArea.setAttribute("contenteditable", "true");
          }

        }

      },
      /*
      @function (private) _updateValue
      @description Updates the value
      */
      updateValue: function () {

        var el = this;

        if (el.type == "area") {
          // This is set to true when the value propertyChanged is triggered from the textarea change, 
          // in those scenarios we dont want to update the area again
          if (!el._misc.area.preventUpdate) {
            el._refs.editableArea.innerText = el.value;
            el._updateCounter();
          }

          el._misc.area.preventUpdate = false;

        } else {

          el.onReady(function () {
            el._refs.input.value = el.value;
          });

        }

      },
      /*
      @function (private) _updateInvalid
      @description Updates the invalid status
      */
      updateInvalid: function () {

        var el = this;
        var classListFn = eon.util.isTrue(el.invalid) ? "add" : "remove";

        el.classList[classListFn]("eon-text-error");

      }

    },

    functions: {
      /*
      @function clear
      @description Empties the value
      */
      clear: function () {
        this.value = "";
      },
      /*
      @function reset
      @description Resets the value of the element to the default one, if no default is provided then empties the value
      */
      reset: function () {

        var el = this;

        if (el.default != "") {
          el.value = el.default;
        } else {
          el.clear();
        }

      },
      /*
      @function updateDescription
      @description Updates the description value for the element
      */
      updateDescription: function (text) {
        this._misc.descriptionText = text;
        this._refs.description.innerHTML = this._misc.descriptionText;
      },
      /*
      @function resetDescription
      @description Updates the description value for the element
      */
      resetDescription: function () {

        var el = this;
        var description = el.tooltip != "" ? el.tooltip : "";

        el._misc.descriptionText = description;
        el._refs.description.innerHTML = description;

      },
      // @function focus (public) [Give focus to vc-text]
      focus: function () {
        var el = this;
        el.onReady(function () {
          if (el.type != "area") {
            el._refs.input.focus();
          } else {
            if (el._misc.area.isNative) {
              el._refs.editableArea.focus();
            }
          }
        });
      }
    },

    onCreated: function () {

      var el = this;

      el._misc.initialText = this.source.textContent;
      el._misc.descriptionText = "";

      el.value = el.value == "" && el._misc.initialText != "" ? el._misc.initialText : el.value;

      el._misc.area = {};
      el._misc.area.inputEventTriggered = false;
      el._misc.area.verticalSize = 0;
      el._misc.area.horizontalSize = 0;

      el.source.textContent = "";

      eon.createCallback("onEnter", this);
      eon.createCallback("onBlur", this);
      eon.createCallback("onFocus", this);

    },

    onBubbleRender: function () {
      this._setup();
    },

    onPropertyChanged: function (key, oldVal, newVal) {

      switch (key) {
        case "label":
          this._updateLabel();
          break;
        case "counter":
          this._updateCounter();
          break;
        case "disabled":
          this._updateDisabled();
          break;
        case "readonly":
          this._updateReadOnly();
          break;
        case "value":
          this._updateValue();
          break;
        case "invalid":
          this._updateInvalid();
          break;
      }

    }

  })

</script>
        <style>
          eon-text[inline="true"] {
  display: inline-block;
  width: 200px;
}
eon-text[label=""][counter="false"] .eon-text-data {
  display: none;
}
eon-text[type="area"] .eon-text-main {
  display: block;
}
eon-text input {
  width: 100%;
  background-color: transparent;
  border: none;
  outline: none;
}
eon-text textarea.eon-text-editable {
  height: 100%;
  width: 100%;
  background: transparent;
  overflow: auto;
  resize: none;
}
eon-text.focus .eon-text-underline:before,
eon-text.focus .eon-text-underline:after {
  width: 50%;
}
eon-text[disabled="true"] {
  pointer-events: none;
}
eon-text.disabled .eon-text-editable:empty:before {
  content: attr(placeholder);
}
.eon-text-data {
  height: 18px;
  margin-bottom: 5px;
  flex-grow: 0;
  display: flex;
}
.eon-text-label {
  font-size: 15px;
  height: 100%;
  flex-grow: 1;
}
.eon-text-counter {
  height: 100%;
  flex-grow: 0;
  font-size: 11px;
  display: flex;
  justify-content: center;
  align-items: flex-end;
}
.eon-text-main {
  flex-grow: 1;
  padding: 10px;
  box-sizing: border-box;
  display: flex;
  border-bottom-width: 1px;
  border-bottom-style: solid;
}
.eon-text-editable:empty:before {
  content: attr(placeholder);
}
.eon-text-editable,
input {
  font-family: sans-serif;
  font-size: 15px;
  padding: 0;
  -webkit-user-select: text;
  user-select: text;
}
.eon-text-editable {
  outline: none;
  cursor: text;
  word-wrap: break-word;
  margin: 0 !important;
  padding: 0 !important;
  border: none !important;
  overflow: hidden;
}
.eon-text-editable div {
  max-width: 100%;
  word-wrap: break-word;
}
.eon-text-editable p {
  margin: 0;
}
.eon-text-underline {
  position: relative;
  display: block;
  width: auto;
}
.eon-text-underline:before,
.eon-text-underline:after {
  position: absolute;
  bottom: 0px;
  width: 0;
  height: 2px;
  content: "";
  -webkit-transition: 0.5s ease all;
  -moz-transition: 0.5s ease all;
  transition: 0.5s ease all;
}
.eon-text-underline:before {
  left: 50%;
}
.eon-text-underline:after {
  right: 50%;
}
.eon-text-description {
  margin-top: 5px;
  font-size: 14px;
  width: 100%;
}
          </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-text[theme="claro"],
div[data-theme="claro"] eon-text,
body[data-theme="claro"] eon-text {
  /* - Chrome 56,
  - Safari 5-10.0
  - iOS Safari 4.2-10.2
  - Opera 15-43
  - Opera Mobile >12
  - Android Browser 2.1-4.4.4
  - Samsung Internet
  - UC Browser for Android
  - QQ Browser */
  /* Firefox 4-18 */
  /* Firefox 19-50 */
  /* - Internet Explorer 1011
  - Internet Explorer Mobile 10-11 */
  /* - Chrome 56,
  - Safari 5-10.0
  - iOS Safari 4.2-10.2
  - Opera 15-43
  - Opera Mobile >12
  - Android Browser 2.1-4.4.4
  - Samsung Internet
  - UC Browser for Android
  - QQ Browser */
  /* Firefox 4-18 */
  /* Firefox 19-50 */
  /* - Internet Explorer 1011
  - Internet Explorer Mobile 10-11 */
}
eon-text[theme="claro"] .eon-text-editable:empty:before,
div[data-theme="claro"] eon-text .eon-text-editable:empty:before,
body[data-theme="claro"] eon-text .eon-text-editable:empty:before {
  content: attr(placeholder);
  color: #9a9a9a;
}
eon-text[theme="claro"] ::-webkit-input-placeholder,
div[data-theme="claro"] eon-text ::-webkit-input-placeholder,
body[data-theme="claro"] eon-text ::-webkit-input-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"] :-moz-placeholder,
div[data-theme="claro"] eon-text :-moz-placeholder,
body[data-theme="claro"] eon-text :-moz-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"] ::-moz-placeholder,
div[data-theme="claro"] eon-text ::-moz-placeholder,
body[data-theme="claro"] eon-text ::-moz-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"] :-ms-input-placeholder,
div[data-theme="claro"] eon-text :-ms-input-placeholder,
body[data-theme="claro"] eon-text :-ms-input-placeholder {
  color: #9a9a9a !important;
}
eon-text[theme="claro"] .eon-text-underline:before,
div[data-theme="claro"] eon-text .eon-text-underline:before,
body[data-theme="claro"] eon-text .eon-text-underline:before,
eon-text[theme="claro"] .eon-text-underline:after,
div[data-theme="claro"] eon-text .eon-text-underline:after,
body[data-theme="claro"] eon-text .eon-text-underline:after {
  background: #47cce2;
}
eon-text[theme="claro"].focus .eon-text-label,
div[data-theme="claro"] eon-text.focus .eon-text-label,
body[data-theme="claro"] eon-text.focus .eon-text-label,
eon-text[theme="claro"].focus .eon-text-counter,
div[data-theme="claro"] eon-text.focus .eon-text-counter,
body[data-theme="claro"] eon-text.focus .eon-text-counter {
  color: #47cce2;
}
eon-text[theme="claro"].eon-text-error .eon-text-label,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-label,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-label,
eon-text[theme="claro"].eon-text-error .eon-text-counter,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-counter,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-counter,
eon-text[theme="claro"].eon-text-error .eon-text-description,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-description,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-description {
  color: #c33232;
}
eon-text[theme="claro"].eon-text-error .eon-text-main,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-main,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-main {
  border-bottom: 1px solid #c33232;
}
eon-text[theme="claro"].eon-text-error .eon-text-underline:before,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-underline:before,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-underline:before,
eon-text[theme="claro"].eon-text-error .eon-text-underline:after,
div[data-theme="claro"] eon-text.eon-text-error .eon-text-underline:after,
body[data-theme="claro"] eon-text.eon-text-error .eon-text-underline:after {
  background: #c33232;
}
eon-text[theme="claro"][disabled="true"] .eon-text-editable:empty:before,
div[data-theme="claro"] eon-text[disabled="true"] .eon-text-editable:empty:before,
body[data-theme="claro"] eon-text[disabled="true"] .eon-text-editable:empty:before {
  color: #9a9a9a;
}
eon-text[theme="claro"][disabled="true"] ::-webkit-input-placeholder,
div[data-theme="claro"] eon-text[disabled="true"] ::-webkit-input-placeholder,
body[data-theme="claro"] eon-text[disabled="true"] ::-webkit-input-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"][disabled="true"] :-moz-placeholder,
div[data-theme="claro"] eon-text[disabled="true"] :-moz-placeholder,
body[data-theme="claro"] eon-text[disabled="true"] :-moz-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"][disabled="true"] ::-moz-placeholder,
div[data-theme="claro"] eon-text[disabled="true"] ::-moz-placeholder,
body[data-theme="claro"] eon-text[disabled="true"] ::-moz-placeholder {
  color: #9a9a9a;
}
eon-text[theme="claro"][disabled="true"] :-ms-input-placeholder,
div[data-theme="claro"] eon-text[disabled="true"] :-ms-input-placeholder,
body[data-theme="claro"] eon-text[disabled="true"] :-ms-input-placeholder {
  color: #9a9a9a !important;
}
eon-text[theme="claro"] input:disabled,
div[data-theme="claro"] eon-text input:disabled,
body[data-theme="claro"] eon-text input:disabled {
  -webkit-text-fill-color: #cecece;
  /* Override iOS / Android font color change */
  -webkit-opacity: 1;
  /* Override iOS opacity change affecting text & background color */
}
          </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}          </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Text">
        <eon-text inline="false" name="text" type="text" placeholder="Type here" label="Text field" max-length="18">Some
          text</eon-text>
      </eon-showcase-item>
      <eon-showcase-item title="Area">
        <eon-text class="d-top-margin" inline="false" name="description" type="area" placeholder="Type here" label="Description"
          counter="true">This is a text</eon-text>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
    //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="toggle" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>TOGGLE</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-toggle-tmp', '.d-toggle-pg');">
    <div name="example">
      <eon-showcase-item title="Toggle">
        <eon-toggle class="d-top-margin" label="Uncheck toggle" value="toggle2" name="toggleOptions" id="option2">
        </eon-toggle>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-toggle class="d-top-margin" label="Disabled toggle" value="toggle3" name="toggleOptions" id="option3"
          disabled="true">
        </eon-toggle>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-toggle-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-toggle-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        eon-showcase-item[title="Area"] {
          min-width: 150px;
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
      </script>
      <!-- EON elements import configuration -->
      <script>
        eon.imports = eon.imports || {
          count: 0,
          total: 0,
          ready: false
        };
        eon.imports.style = eon.imports.style || "";
        eon.imports.scripts = eon.imports.scripts || {};
        eon.imports.links = eon.imports.links || {};
        eon.imports.templates = eon.imports.templates || {};
        eon.imports.paths = eon.imports.paths || {};
        eon.imports.config = eon.imports.config || {};

        eon.imports.paths["eon-toggle"] = "eon/ui/eon-toggle/";
        eon.registry.registerTheme("eon-toggle", "claro");

        eon.imports.paths["eon-showcase-item"] = "eon/custom/eon-showcase-item/";
        var elements = ["eon-toggle", "eon-showcase-item"];
      </script>

      <!-- Inject eon elements -->
      <div class="eon-toggle-config">
        <template>

    <div class="eon-toggle-toggle eon-fg1">
        <input class="eon-toggle-input" type="checkbox">
        <label class="eon-toggle-label">
            <div class="eon-toggle-span eon-bg6 eon-bg6-boxshadow">
                <div class="eon-toggle-circle"></div>
            </div>
            <div class="eon-toggle-nameLabel eon-unselectable"></div>
        </label>

    </div>
</template>

<script>
    eon.element({
        
        name: "eon-toggle",
        style: "",
        
        themed: true,

        properties: {
            /*
              @property {String} name labelWrapper
              @description Toggle name for the form functionality
            */
            name: {
                value: "",
                reflect: true
            },
            /*
              @property {String} value 
              @description Toggle value for the form functionality
            */
            value: {
                value: "",
                reflect: true
            },
            /*
              @property {String} label 
              @description Toggle label
            */
            label: {
                value: "",
                reflect: true
            },
            /*
              @property {Boolean} disabled 
              @description Toggle deactivation
              Default: false
            */
            disabled: {
                value: false,
                reflect: true
            },
            /*
              @property {Boolean} readonly 
              @description Toggles the readonly status of the checkbox
              Default: false
            */
            readonly: {
                value: false,
                reflect: true
            },
            /*
              @property {Boolean} checked 
              @description Checkbox checked status
              Values can be: true or false
            */
            checked: {
                value: "",
                reflect: true
            },
            /*
            @property {Boolean} default
            @description Sets checked status by default when the element is reset
            Values can be: true or false
            */
            default: {
                value: "",
                reflect: true
            },
            /*
             @property {Boolean} inline 
             @description Space that occupy the toggle inside parent container.
             By default, its size adapts to its content
             Values can be: true or false
             Default: true
           */
            inline: {
                value: true,
                reflect: true
            },
            /*
             @property {Boolean} labelPosition 
             @description Space that occupy the toggle inside parent container.
             By default, its size adapts to its content
             Values can be: "left" or "right"
             Default: "right"
           */
            labelPosition: {
                value: "right",
                reflect: true,
                reflectDefault: true
            }
        },

        privateProperties: {
            /*
              @property (private) {String} _formElement 
              @description Set that toggle is a form element
              Value: checkbox
            */
            formElement: {
                value: "checkbox"
            },
            /*
              @property (private) {Object} _refs 
              @description Object with  references
            */
            refs: {
                value: {}
            }
        },

        functions: {
            /*
            @function clear
            @description Unchecks the element
            */
            clear: function () {
                this.checked = false;
            },
            /*
            @function reset
            @description Resets checked status of the element to the default one
            */
            reset: function () {
                var el = this;

                if (eon.util.isTrue(el.default)) {
                    el.checked = el.default;
                } else {
                    el.clear();
                }

            }
        },

        privateFunctions: {
            /*
              @function (private) _setValue
              @description Set new checkbox value
              @param {String} newVal [New checkbox value]
            */
            setValue: function () {
                this._currentValue = this.value;
                eon.triggerCallback("onChange", this);

            },
            /*
              @function (private) _createRefs
              @description Creates fast access to elements
            */
            createRefs: function () {
                var el = this;

                el._refs.input = el.template.querySelector(".eon-toggle-input");
                el._refs.label = el.template.querySelector(".eon-toggle-label");
                el._refs.span = el.template.querySelector(".eon-toggle-span");
                el._refs.nameLabel = el.template.querySelector(".eon-toggle-nameLabel");
            },
            /*
              @function (private) _updateDisabled
              @description Update disabled status
            */
            updateDisabled: function () {
                !eon.util.isTrue(this.disabled) ? this._refs.input.removeAttribute("disabled") : this._refs.input.setAttribute("disabled", "true");
            },

            /*
            @function (private) _updateReadonly
            @description Updates readonly status
            */
            updateReadonly: function () {
                var el = this;

                if (eon.util.isTrue(el.readonly)) {
                    el._refs.input.setAttribute("readonly", "true");
                } else {
                    el._refs.input.removeAttribute("readonly");
                }

            },

            /*
              @function (private) _updateCheck
              @description Update checked status
            */
            updateCheck: function () {
                
                if (!eon.util.isTrue(this.checked)) {
                    this._refs.input.removeAttribute("checked");
                    this._refs.label.classList.remove("checked");
                    eon.triggerCallback("onUncheck", this);

                } else {
                    this._refs.input.setAttribute("checked", "true");
                    this._refs.label.classList.add("checked");
                    eon.triggerCallback("onCheck", this);

                }
            },
        },

        onCreated: function () {
            eon.createCallback("onCheck", this);
            eon.createCallback("onUncheck", this);

            this._createRefs();
        },

        onRender: function () {
            var el = this;

            // el._refs.input.setAttribute("name", el.name);
            el.checked = el.default != "" && el.checked == "" ? el.default : el.checked;
            el._refs.nameLabel.innerHTML = el.label;


            // Checking or unchecking the checkbox
            el._refs.label.addEventListener("click", function (e) {
                // The click event is triggered by two elements, the real input and the
                // visual custom element. So it is necessary to control one of the two elements
                // fot not activate the action twice.
                if (!eon.util.isTrue(el.disabled) && e.target.type !== "checkbox") {
                    el.checked = (eon.util.isTrue(el.checked)) ? false : true;
                }

            }, false);

            el._updateDisabled();
            el._updateReadonly();
            el._updateCheck();

        },

        onPropertyChanged: function (attrName, oldVal, newVal) {

            switch (attrName) {
                case "disabled":
                    this._updateDisabled();
                    break;
                case "readonly":
                    this._updateReadonly();
                    break;
                case "checked":
                    this._updateCheck();
                    break;
                case "label":
                    this._refs.nameLabel.innerHTML = newVal;
                    break;
                case "value":
                    this._setValue();
                    break;
            }
        }
    });

</script>
        <style>
          eon-toggle {
  position: relative;
}
eon-toggle[label-position="left"] .eon-toggle-label {
  flex-direction: row-reverse;
}
eon-toggle[label-position="left"] .eon-toggle-label .eon-toggle-span {
  margin: 0 0 0 5px;
}
eon-toggle[label-position="right"] .eon-toggle-label .eon-toggle-span {
  margin: 0 5px 0 0;
}
eon-toggle[inline="true"] {
  display: inline-block;
}
eon-toggle[inline="true"] .eon-toggle-toggle {
  width: auto;
}
eon-toggle[readonly="true"] .eon-toggle-label {
  cursor: auto;
  pointer-events: none;
}
eon-toggle[disabled="true"] .eon-toggle-label {
  cursor: auto;
}
eon-toggle[checked="true"] .eon-toggle-circle {
  left: 20px;
}
.eon-toggle-toggle {
  height: 22px;
  display: flex;
  align-items: center;
  position: relative;
}
.eon-toggle-input[type="checkbox"] {
  display: none;
}
.eon-toggle-label {
  display: flex;
  align-items: center;
  cursor: pointer;
}
.eon-toggle-input[type="checkbox"] + .eon-toggle-label .eon-toggle-span {
  width: 40px;
  height: 15px;
  border-radius: 100px;
  transition: all 0.3s ease;
  position: relative;
}
.eon-toggle-circle {
  position: absolute;
  top: -3px;
  left: 0;
  transition: all 0.3s ease;
  width: 20px;
  height: 20px;
  content: "";
  border-radius: 100%;
}
.eon-toggle-input:disabled ~ .eon-toggle-span {
  pointer-events: none;
}
        </style>
        <style>
          /*TEST*/
/* Set 1 - Containers (appmenu, searchbar, datepicker, appmenu, grid, headerpanel,
           loadingmask, menu, swiper, tab, tabs, togglemenu, video) */
/* Set 2 - Elements (button, checkbox, combobox, spinner, text, 
           radio, contextmenu, slider, treenode) */
eon-toggle[theme="claro"] .eon-toggle-circle,
div[data-theme="claro"] eon-toggle .eon-toggle-circle,
body[data-theme="claro"] eon-toggle .eon-toggle-circle {
  background: #888888;
}
eon-toggle[theme="claro"][checked="true"] .eon-toggle-circle,
div[data-theme="claro"] eon-toggle[checked="true"] .eon-toggle-circle,
body[data-theme="claro"] eon-toggle[checked="true"] .eon-toggle-circle {
  background: #47cce2;
}
eon-toggle[theme="claro"] .eon-toggle-input:checked ~ .eon-toggle-label .eon-toggle-span,
div[data-theme="claro"] eon-toggle .eon-toggle-input:checked ~ .eon-toggle-label .eon-toggle-span,
body[data-theme="claro"] eon-toggle .eon-toggle-input:checked ~ .eon-toggle-label .eon-toggle-span {
  background: #bef2ff;
}
eon-toggle[theme="claro"] .eon-toggle-input:disabled ~ .eon-toggle-label .eon-toggle-span,
div[data-theme="claro"] eon-toggle .eon-toggle-input:disabled ~ .eon-toggle-label .eon-toggle-span,
body[data-theme="claro"] eon-toggle .eon-toggle-input:disabled ~ .eon-toggle-label .eon-toggle-span {
  background: #cecece;
}
eon-toggle[theme="claro"] .eon-toggle-input:disabled ~ .eon-toggle-label::after,
div[data-theme="claro"] eon-toggle .eon-toggle-input:disabled ~ .eon-toggle-label::after,
body[data-theme="claro"] eon-toggle .eon-toggle-input:disabled ~ .eon-toggle-label::after {
  background: #9a9a9a;
}
eon-toggle[theme="claro"] .eon-toggle-input[type="checkbox"]:disabled + .eon-toggle-label::after,
div[data-theme="claro"] eon-toggle .eon-toggle-input[type="checkbox"]:disabled + .eon-toggle-label::after,
body[data-theme="claro"] eon-toggle .eon-toggle-input[type="checkbox"]:disabled + .eon-toggle-label::after {
  background: #9a9a9a;
}
eon-toggle[theme="claro"] .eon-toggle-input[type="checkbox"]:disabled ~ .eon-toggle-label .eon-toggle-circle,
div[data-theme="claro"] eon-toggle .eon-toggle-input[type="checkbox"]:disabled ~ .eon-toggle-label .eon-toggle-circle,
body[data-theme="claro"] eon-toggle .eon-toggle-input[type="checkbox"]:disabled ~ .eon-toggle-label .eon-toggle-circle {
  background: #cecece;
}
        </style>
      </div>
      <div class="eon-showcase-item-config">
        <template>

  <div class="eon-showcase-item-title"></div>
  <div class="eon-showcase-item-content"></div>

</template>

<script type="text/javascript">
  eon.element({

    name: "eon-showcase-item",
    style: "",

    themed: false,

    properties: {
      /*
        @property {String} title
        @description 
      */
      title: {
        value: "",
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property {object} _refs
        @description 
      */
      refs: {
        value: {},
        reflect: false
      },
      /*
        @property (private) {Object} _misc
        @description 
      */
      misc: {
        value: {},
        reflect: false
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUpRefs
        @description 
      */
      setUpRefs: function () {
        var el = this;

        el._refs.title = el.template.querySelector(".eon-showcase-item-title");
        el._refs.content = el.template.querySelector(".eon-showcase-item-content");
      },
      /*
        @function (private) _setTitle
        @description 
      */
      setTitle: function () {
        var el = this;
        el._refs.title.innerHTML = el.title;
      },
      /*
        @function (private) _setContent
        @description 
      */
      setContent: function () {
        var el = this;
        var srcNodes = el.getSourceElements();
        var srcNode;

        // Showcase item style
        el.classList.add("eon-bg1");

        // Move source children to the content element safely
        while (srcNodes.length) {
          // Get the shifted element
          srcNode = srcNodes.shift();
          // Append them to the tree
          el._refs.content.appendChild(srcNode);
        }
      }
    },
    onCreated: function () {
      var el = this;
      el._setUpRefs();
    },
    onInit: function () {
      var el = this;
      el._setTitle();
      el._setContent();
    },
    onRender: function () {
      var el = this;

    }
  });
</script>
        <style>
          eon-showcase-item {
  position: relative;
  display: inline-block;
  vertical-align: top;
  padding: 20px;
  box-sizing: border-box
}
.eon-showcase-item-title {
  font-size: 20px;
  margin-bottom: 10px;
  font-weight: bold;
}
.eon-showcase-item-content {
  height: calc(100% - 33px);
}        </style>
      </div>
      <script>
        // Insert and declare
        for (var i = 0; i < elements.length; i++) {
          var elementName = elements[i];
          if (!(elementName in eon.imports.templates)) {
            // Increment total
            eon.imports.total++;
            // Avoid duplicated imports while waiting XMLHttpRequest callback.
            eon.imports.templates[elementName] = null;
            eon.declare(elementName);
            eon.insertFragment(elementName, document.querySelector("." + elementName + "-config").innerHTML);
          }
        }
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Toggle">
        <eon-toggle class="d-top-margin" label="Uncheck toggle" value="toggle2" name="toggleOptions" id="option2">
        </eon-toggle>
      </eon-showcase-item>
      <eon-showcase-item title="Disabled">
        <eon-toggle class="d-top-margin" label="Disabled toggle" value="toggle3" name="toggleOptions" id="option3"
          disabled="true">
        </eon-toggle>
      </eon-showcase-item>
    </div>
    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>

    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
  <eon-anchor state="form" eon-scroll="eon-scroll" type="top"></eon-anchor>
<div class="card">
  <h1>FORM</h1>

  <!-- SHOWCASE -->
  <eon-viewer load="initializeShowcase('.d-form-tmp', '.d-form-pg');">
    <div name="example">
      <eon-showcase-item title="Demo form">
        <eon-form action="#" method="get">

          <eon-text class="d-form-marginTop" inline="false" name="text" type="text" placeholder="Name and ast name" label="Client name"
            max-length="18"></eon-text>

          <eon-group name="sex" class="d-form-marginTop" label="Themes">
            <eon-radio class="d-radio-radioSpacing" label="Material" value="material"></eon-radio>
            <eon-radio class="d-radio-radioSpacing" label="Noire" value="noire"></eon-radio>
          </eon-group>

          <eon-checkbox class="d-form-marginTop" label="Global" name="global" value="global" checked="true"></eon-checkbox>

          <eon-combobox class="d-form-marginTop" label="Base color" name="selectorTest2" trigger="focus" placeholder="Placeholder"
            filter="false">
            <eon-item value="blue" displayValue="Blue"></eon-item>
            <eon-item value="red" displayValue="Red"></eon-item>
            <eon-item value="orange" displayValue="Orange"></eon-item>
          </eon-combobox>

          <eon-date label="Expiration" class="d-form-marginTop"> </eon-date>

          <span class="d-form-marginTop">Color-scheme</span>
          <eon-slider></eon-slider>

          <eon-spinner class="d-form-marginTop" label="Border" value="15" min="9" max="111"></eon-spinner>

          <eon-toggle class="d-form-marginTop" label="Accept policy" checked="true" value="toggle1" name="toggleOptions" id="option1">
          </eon-toggle>

          <eon-button inline="true" class="d-form-marginTop" type="submit" value="Submit">
          </eon-button>

        </eon-form>
      </eon-showcase-item>
    </div>
    <div name="showcase">
      <!-- Showcase declaration -->
      <eon-showcase class="d-pg d-form-pg"></eon-showcase>
    </div>
  </eon-viewer>

  <!-- Showcase content -->
  <template class="d-form-tmp">
    <div class="template-head">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <style>
        .radioSpacing {
          margin-top: 10px;
        }
        .d-margin-top {
          margin-top: 20px !important;
        }
      </style>
      <!-- Import eon-js  -->
      <script>
        // ** Eon polyfill path fix
        document.currentScript.src = window.location.href + "eon";
        // Inject js with meta
        eon = eon || {};
eon.debug = eon.debug || {};
eon.debug.polyfill = eon.debug.polyfill || false;

eon = eon || {};
eon.polyfills = eon.polyfills || {};

eon.polyfills.customElements = true;
eon.polyfills.template = true;
eon.polyfills.CSSScope = true;
eon.polyfills.assign = true;
eon.polyfills.promises = true;
eon.polyfills.localeString = true;
eon.polyfills.classList = true;
eon.polyfills.pep = true;

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

if (eon.polyfills.needCustomElementsPolyfill()) {
    (function() {
  "use strict";
  var g = new function() {}();
  var aa = new Set(
    "annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(
      " "
    )
  );
  function k(b) {
    var a = aa.has(b);
    b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
    return !a && b;
  }
  function l(b) {
    var a = b.isConnected;
    if (void 0 !== a) return a;
    for (; b && !(b.__CE_isImportDocument || b instanceof Document); )
      b =
        b.parentNode ||
        (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
    return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
  }
  function m(b, a) {
    for (; a && a !== b && !a.nextSibling; ) a = a.parentNode;
    return a && a !== b ? a.nextSibling : null;
  }
  function n(b, a, e) {
    e = e ? e : new Set();
    for (var c = b; c; ) {
      if (c.nodeType === Node.ELEMENT_NODE) {
        var d = c;
        a(d);
        var h = d.localName;
        if ("link" === h && "import" === d.getAttribute("rel")) {
          c = d.import;
          if (c instanceof Node && !e.has(c))
            for (e.add(c), c = c.firstChild; c; c = c.nextSibling) n(c, a, e);
          c = m(b, d);
          continue;
        } else if ("template" === h) {
          c = m(b, d);
          continue;
        }
        if ((d = d.__CE_shadowRoot))
          for (d = d.firstChild; d; d = d.nextSibling) n(d, a, e);
      }
      c = c.firstChild ? c.firstChild : m(b, c);
    }
  }
  function q(b, a, e) {
    b[a] = e;
  }
  function r() {
    this.a = new Map();
    this.m = new Map();
    this.f = [];
    this.b = !1;
  }
  function ba(b, a, e) {
    b.a.set(a, e);
    b.m.set(e.constructor, e);
  }
  function t(b, a) {
    b.b = !0;
    b.f.push(a);
  }
  function v(b, a) {
    b.b &&
      n(a, function(a) {
        return w(b, a);
      });
  }
  function w(b, a) {
    if (b.b && !a.__CE_patched) {
      a.__CE_patched = !0;
      for (var e = 0; e < b.f.length; e++) b.f[e](a);
    }
  }
  function x(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
    }
  }
  function z(b, a) {
    var e = [];
    n(a, function(b) {
      return e.push(b);
    });
    for (a = 0; a < e.length; a++) {
      var c = e[a];
      1 === c.__CE_state && b.disconnectedCallback(c);
    }
  }
  function A(b, a, e) {
    e = e ? e : new Set();
    var c = [];
    n(
      a,
      function(d) {
        if ("link" === d.localName && "import" === d.getAttribute("rel")) {
          var a = d.import;
          a instanceof Node && "complete" === a.readyState
            ? ((a.__CE_isImportDocument = !0), (a.__CE_hasRegistry = !0))
            : d.addEventListener("load", function() {
                var a = d.import;
                a.__CE_documentLoadHandled ||
                  ((a.__CE_documentLoadHandled = !0),
                  (a.__CE_isImportDocument = !0),
                  (a.__CE_hasRegistry = !0),
                  e.delete(a),
                  A(b, a, e));
              });
        } else c.push(d);
      },
      e
    );
    if (b.b) for (a = 0; a < c.length; a++) w(b, c[a]);
    for (a = 0; a < c.length; a++) y(b, c[a]);
  }
  function y(b, a) {
    if (void 0 === a.__CE_state) {
      var e = b.a.get(a.localName);
      if (e) {
        e.constructionStack.push(a);
        var c = e.constructor;
        try {
          try {
            if (new c() !== a)
              throw Error(
                "The custom element constructor did not produce the element being upgraded."
              );
          } finally {
            e.constructionStack.pop();
          }
        } catch (f) {
          throw ((a.__CE_state = 2), f);
        }
        a.__CE_state = 1;
        a.__CE_definition = e;
        if (e.attributeChangedCallback)
          for (e = e.observedAttributes, c = 0; c < e.length; c++) {
            var d = e[c],
              h = a.getAttribute(d);
            null !== h && b.attributeChangedCallback(a, d, null, h, null);
          }
        l(a) && b.connectedCallback(a);
      }
    }
  }
  r.prototype.connectedCallback = function(b) {
    var a = b.__CE_definition;
    a.connectedCallback && a.connectedCallback.call(b);
  };
  r.prototype.disconnectedCallback = function(b) {
    var a = b.__CE_definition;
    a.disconnectedCallback && a.disconnectedCallback.call(b);
  };
  r.prototype.attributeChangedCallback = function(b, a, e, c, d) {
    var h = b.__CE_definition;
    h.attributeChangedCallback &&
      -1 < h.observedAttributes.indexOf(a) &&
      h.attributeChangedCallback.call(b, a, e, c, d);
  };
  function B(b, a) {
    this.c = b;
    this.a = a;
    this.b = void 0;
    A(this.c, this.a);
    "loading" === this.a.readyState &&
      ((this.b = new MutationObserver(this.f.bind(this))),
      this.b.observe(this.a, { childList: !0, subtree: !0 }));
  }
  function C(b) {
    b.b && b.b.disconnect();
  }
  B.prototype.f = function(b) {
    var a = this.a.readyState;
    ("interactive" !== a && "complete" !== a) || C(this);
    for (a = 0; a < b.length; a++)
      for (var e = b[a].addedNodes, c = 0; c < e.length; c++) A(this.c, e[c]);
  };
  function ca() {
    var b = this;
    this.b = this.a = void 0;
    this.f = new Promise(function(a) {
      b.b = a;
      b.a && a(b.a);
    });
  }
  function D(b) {
    if (b.a) throw Error("Already resolved.");
    b.a = void 0;
    b.b && b.b(void 0);
  }
  function E(b) {
    this.i = !1;
    this.c = b;
    this.l = new Map();
    this.j = function(b) {
      return b();
    };
    this.g = !1;
    this.h = [];
    this.s = new B(b, document);
  }
  E.prototype.define = function(b, a) {
    var e = this;
    if (!(a instanceof Function))
      throw new TypeError("Custom element constructors must be functions.");
    if (!k(b))
      throw new SyntaxError("The element name '" + b + "' is not valid.");
    if (this.c.a.get(b))
      throw Error(
        "A custom element with name '" + b + "' has already been defined."
      );
    if (this.i) throw Error("A custom element is already being defined.");
    this.i = !0;
    var c, d, h, f, u;
    try {
      var p = function(b) {
          var a = P[b];
          if (void 0 !== a && !(a instanceof Function))
            throw Error("The '" + b + "' callback must be a function.");
          return a;
        },
        P = a.prototype;
      if (!(P instanceof Object))
        throw new TypeError(
          "The custom element constructor's prototype is not an object."
        );
      c = p("connectedCallback");
      d = p("disconnectedCallback");
      h = p("adoptedCallback");
      f = p("attributeChangedCallback");
      u = a.observedAttributes || [];
    } catch (ua) {
      return;
    } finally {
      this.i = !1;
    }
    ba(this.c, b, {
      localName: b,
      constructor: a,
      connectedCallback: c,
      disconnectedCallback: d,
      adoptedCallback: h,
      attributeChangedCallback: f,
      observedAttributes: u,
      constructionStack: []
    });
    this.h.push(b);
    this.g ||
      ((this.g = !0),
      this.j(function() {
        if (!1 !== e.g)
          for (e.g = !1, A(e.c, document); 0 < e.h.length; ) {
            var b = e.h.shift();
            (b = e.l.get(b)) && D(b);
          }
      }));
  };
  E.prototype.get = function(b) {
    if ((b = this.c.a.get(b))) return b.constructor;
  };
  E.prototype.whenDefined = function(b) {
    if (!k(b))
      return Promise.reject(
        new SyntaxError("'" + b + "' is not a valid custom element name.")
      );
    var a = this.l.get(b);
    if (a) return a.f;
    a = new ca();
    this.l.set(b, a);
    this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
    return a.f;
  };
  E.prototype.u = function(b) {
    C(this.s);
    var a = this.j;
    this.j = function(e) {
      return b(function() {
        return a(e);
      });
    };
  };
  window.CustomElementRegistry = E;
  E.prototype.define = E.prototype.define;
  E.prototype.get = E.prototype.get;
  E.prototype.whenDefined = E.prototype.whenDefined;
  E.prototype.polyfillWrapFlushCallback = E.prototype.u;
  var F = window.Document.prototype.createElement,
    da = window.Document.prototype.createElementNS,
    ea = window.Document.prototype.importNode,
    fa = window.Document.prototype.prepend,
    ga = window.Document.prototype.append,
    G = window.Node.prototype.cloneNode,
    H = window.Node.prototype.appendChild,
    I = window.Node.prototype.insertBefore,
    J = window.Node.prototype.removeChild,
    K = window.Node.prototype.replaceChild,
    L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
    M = window.Element.prototype.attachShadow,
    N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
    O = window.Element.prototype.getAttribute,
    Q = window.Element.prototype.setAttribute,
    R = window.Element.prototype.removeAttribute,
    S = window.Element.prototype.getAttributeNS,
    T = window.Element.prototype.setAttributeNS,
    U = window.Element.prototype.removeAttributeNS,
    V = window.Element.prototype.insertAdjacentElement,
    ha = window.Element.prototype.prepend,
    ia = window.Element.prototype.append,
    ja = window.Element.prototype.before,
    ka = window.Element.prototype.after,
    la = window.Element.prototype.replaceWith,
    ma = window.Element.prototype.remove,
    na = window.HTMLElement,
    W = Object.getOwnPropertyDescriptor(
      window.HTMLElement.prototype,
      "innerHTML"
    ),
    X = window.HTMLElement.prototype.insertAdjacentElement;
  function oa() {
    var b = Y;
    window.HTMLElement = (function() {
      function a() {
        var a = this.constructor,
          c = b.m.get(a);
        if (!c)
          throw Error(
            "The custom element being constructed was not registered with `customElements`."
          );
        var d = c.constructionStack;
        if (!d.length)
          return (
            (d = F.call(document, c.localName)),
            Object.setPrototypeOf(d, a.prototype),
            (d.__CE_state = 1),
            (d.__CE_definition = c),
            w(b, d),
            d
          );
        var c = d.length - 1,
          h = d[c];
        if (h === g)
          throw Error(
            "The HTMLElement constructor was either called reentrantly for this constructor or called multiple times."
          );
        d[c] = g;
        Object.setPrototypeOf(h, a.prototype);
        w(b, h);
        return h;
      }
      a.prototype = na.prototype;
      return a;
    })();
  }
  function pa(b, a, e) {
    a.prepend = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.o.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
    a.append = function(a) {
      for (var d = [], c = 0; c < arguments.length; ++c)
        d[c - 0] = arguments[c];
      c = d.filter(function(b) {
        return b instanceof Node && l(b);
      });
      e.append.apply(this, d);
      for (var f = 0; f < c.length; f++) z(b, c[f]);
      if (l(this))
        for (c = 0; c < d.length; c++)
          (f = d[c]), f instanceof Element && x(b, f);
    };
  }
  function qa() {
    var b = Y;
    q(Document.prototype, "createElement", function(a) {
      if (this.__CE_hasRegistry) {
        var e = b.a.get(a);
        if (e) return new e.constructor();
      }
      a = F.call(this, a);
      w(b, a);
      return a;
    });
    q(Document.prototype, "importNode", function(a, e) {
      a = ea.call(this, a, e);
      this.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Document.prototype, "createElementNS", function(a, e) {
      if (
        this.__CE_hasRegistry &&
        (null === a || "http://www.w3.org/1999/xhtml" === a)
      ) {
        var c = b.a.get(e);
        if (c) return new c.constructor();
      }
      a = da.call(this, a, e);
      w(b, a);
      return a;
    });
    pa(b, Document.prototype, { o: fa, append: ga });
  }
  function ra() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "textContent", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);
          else {
            var d = void 0;
            if (this.firstChild) {
              var e = this.childNodes,
                u = e.length;
              if (0 < u && l(this))
                for (var d = Array(u), p = 0; p < u; p++) d[p] = e[p];
            }
            c.set.call(this, a);
            if (d) for (a = 0; a < d.length; a++) z(b, d[a]);
          }
        }
      });
    }
    q(Node.prototype, "insertBefore", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = I.call(this, a, c);
        if (l(this)) for (c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      d = l(a);
      c = I.call(this, a, c);
      d && z(b, a);
      l(this) && x(b, a);
      return c;
    });
    q(Node.prototype, "appendChild", function(a) {
      if (a instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(a.childNodes);
        a = H.call(this, a);
        if (l(this)) for (var d = 0; d < c.length; d++) x(b, c[d]);
        return a;
      }
      c = l(a);
      d = H.call(this, a);
      c && z(b, a);
      l(this) && x(b, a);
      return d;
    });
    q(Node.prototype, "cloneNode", function(a) {
      a = G.call(this, a);
      this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
      return a;
    });
    q(Node.prototype, "removeChild", function(a) {
      var c = l(a),
        d = J.call(this, a);
      c && z(b, a);
      return d;
    });
    q(Node.prototype, "replaceChild", function(a, c) {
      if (a instanceof DocumentFragment) {
        var d = Array.prototype.slice.apply(a.childNodes);
        a = K.call(this, a, c);
        if (l(this)) for (z(b, c), c = 0; c < d.length; c++) x(b, d[c]);
        return a;
      }
      var d = l(a),
        e = K.call(this, a, c),
        f = l(this);
      f && z(b, c);
      d && z(b, a);
      f && x(b, a);
      return e;
    });
    L && L.get
      ? a(Node.prototype, L)
      : t(b, function(b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function() {
              for (var a = [], b = 0; b < this.childNodes.length; b++)
                a.push(this.childNodes[b].textContent);
              return a.join("");
            },
            set: function(a) {
              for (; this.firstChild; ) J.call(this, this.firstChild);
              H.call(this, document.createTextNode(a));
            }
          });
        });
  }
  function sa(b) {
    var a = Element.prototype;
    a.before = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ja.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.after = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      d = c.filter(function(a) {
        return a instanceof Node && l(a);
      });
      ka.apply(this, c);
      for (var e = 0; e < d.length; e++) z(b, d[e]);
      if (l(this))
        for (d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.replaceWith = function(a) {
      for (var c = [], d = 0; d < arguments.length; ++d)
        c[d - 0] = arguments[d];
      var d = c.filter(function(a) {
          return a instanceof Node && l(a);
        }),
        e = l(this);
      la.apply(this, c);
      for (var f = 0; f < d.length; f++) z(b, d[f]);
      if (e)
        for (z(b, this), d = 0; d < c.length; d++)
          (e = c[d]), e instanceof Element && x(b, e);
    };
    a.remove = function() {
      var a = l(this);
      ma.call(this);
      a && z(b, this);
    };
  }
  function ta() {
    var b = Y;
    function a(a, c) {
      Object.defineProperty(a, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function(a) {
          var d = this,
            e = void 0;
          l(this) &&
            ((e = []),
            n(this, function(a) {
              a !== d && e.push(a);
            }));
          c.set.call(this, a);
          if (e)
            for (var f = 0; f < e.length; f++) {
              var h = e[f];
              1 === h.__CE_state && b.disconnectedCallback(h);
            }
          this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
          return a;
        }
      });
    }
    function e(a, c) {
      q(a, "insertAdjacentElement", function(a, d) {
        var e = l(d);
        a = c.call(this, a, d);
        e && z(b, d);
        l(a) && x(b, d);
        return a;
      });
    }
    M
      ? q(Element.prototype, "attachShadow", function(a) {
          return (this.__CE_shadowRoot = a = M.call(this, a));
        })
      : console.warn(
          "Custom Elements: `Element#attachShadow` was not patched."
        );
    if (N && N.get) a(Element.prototype, N);
    else if (W && W.get) a(HTMLElement.prototype, W);
    else {
      var c = F.call(document, "div");
      t(b, function(b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function() {
            return G.call(this, !0).innerHTML;
          },
          set: function(a) {
            var b = "template" === this.localName ? this.content : this;
            for (c.innerHTML = a; 0 < b.childNodes.length; )
              J.call(b, b.childNodes[0]);
            for (; 0 < c.childNodes.length; ) H.call(b, c.childNodes[0]);
          }
        });
      });
    }
    q(Element.prototype, "setAttribute", function(a, c) {
      if (1 !== this.__CE_state) return Q.call(this, a, c);
      var d = O.call(this, a);
      Q.call(this, a, c);
      c = O.call(this, a);
      b.attributeChangedCallback(this, a, d, c, null);
    });
    q(Element.prototype, "setAttributeNS", function(a, c, e) {
      if (1 !== this.__CE_state) return T.call(this, a, c, e);
      var d = S.call(this, a, c);
      T.call(this, a, c, e);
      e = S.call(this, a, c);
      b.attributeChangedCallback(this, c, d, e, a);
    });
    q(Element.prototype, "removeAttribute", function(a) {
      if (1 !== this.__CE_state) return R.call(this, a);
      var c = O.call(this, a);
      R.call(this, a);
      null !== c && b.attributeChangedCallback(this, a, c, null, null);
    });
    q(Element.prototype, "removeAttributeNS", function(a, c) {
      if (1 !== this.__CE_state) return U.call(this, a, c);
      var d = S.call(this, a, c);
      U.call(this, a, c);
      var e = S.call(this, a, c);
      d !== e && b.attributeChangedCallback(this, c, d, e, a);
    });
    X
      ? e(HTMLElement.prototype, X)
      : V
        ? e(Element.prototype, V)
        : console.warn(
            "Custom Elements: `Element#insertAdjacentElement` was not patched."
          );
    pa(b, Element.prototype, { o: ha, append: ia });
    sa(b);
  } /*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
  var Z = window.customElements;
  if (
    !Z ||
    Z.forcePolyfill ||
    "function" != typeof Z.define ||
    "function" != typeof Z.get
  ) {
    var Y = new r();
    oa();
    qa();
    ra();
    ta();
    document.__CE_hasRegistry = !0;
    var customElements = new E(Y);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }
}.call(self));

//# sourceMappingURL=custom-elements.min.js.map

}

if (eon.polyfills.needTemplatePolyfill()) {
    /**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
(function() {
  var needsTemplate = typeof HTMLTemplateElement === "undefined";

  // NOTE: Patch document.importNode to work around IE11 bug that
  // casues children of a document fragment imported while
  // there is a mutation observer to not have a parentNode (!?!)
  // It's important that this is the first patch to `importNode` so that
  // dom produced for later patches is correct.
  if (/Trident/.test(navigator.userAgent)) {
    (function() {
      var Native_importNode = Document.prototype.importNode;
      Document.prototype.importNode = function() {
        var n = Native_importNode.apply(this, arguments);
        // Copy all children to a new document fragment since
        // this one may be broken
        if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          var f = this.createDocumentFragment();
          f.appendChild(n);
          return f;
        } else {
          return n;
        }
      };
    })();
  }

  // NOTE: we rely on this cloneNode not causing element upgrade.
  // This means this polyfill must load before the CE polyfill and
  // this would need to be re-worked if a browser supports native CE
  // but not <template>.
  var Native_cloneNode = Node.prototype.cloneNode;
  var Native_createElement = Document.prototype.createElement;
  var Native_importNode = Document.prototype.importNode;

  // returns true if nested templates cannot be cloned (they cannot be on
  // some impl's like Safari 8 and Edge)
  // OR if cloning a document fragment does not result in a document fragment
  var needsCloning = (function() {
    if (!needsTemplate) {
      var t = document.createElement("template");
      var t2 = document.createElement("template");
      t2.content.appendChild(document.createElement("div"));
      t.content.appendChild(t2);
      var clone = t.cloneNode(true);
      return (
        clone.content.childNodes.length === 0 ||
        clone.content.firstChild.content.childNodes.length === 0 ||
        !(
          document.createDocumentFragment().cloneNode() instanceof
          DocumentFragment
        )
      );
    }
  })();

  var TEMPLATE_TAG = "template";
  var PolyfilledHTMLTemplateElement = function() {};

  if (needsTemplate) {
    var contentDoc = document.implementation.createHTMLDocument("template");
    var canDecorate = true;

    var templateStyle = document.createElement("style");
    templateStyle.textContent = TEMPLATE_TAG + "{display:none;}";

    var head = document.head;
    head.insertBefore(templateStyle, head.firstElementChild);

    /**
      Provides a minimal shim for the <template> element.
    */
    PolyfilledHTMLTemplateElement.prototype = Object.create(
      HTMLElement.prototype
    );

    // if elements do not have `innerHTML` on instances, then
    // templates can be patched by swizzling their prototypes.
    var canProtoPatch = !document
      .createElement("div")
      .hasOwnProperty("innerHTML");

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    PolyfilledHTMLTemplateElement.decorate = function(template) {
      // if the template is decorated, return fast
      if (template.content) {
        return;
      }
      template.content = contentDoc.createDocumentFragment();
      var child;
      while ((child = template.firstChild)) {
        template.content.appendChild(child);
      }
      // NOTE: prefer prototype patching for performance and
      // because on some browsers (IE11), re-defining `innerHTML`
      // can result in intermittent errors.
      if (canProtoPatch) {
        template.__proto__ = PolyfilledHTMLTemplateElement.prototype;
      } else {
        template.cloneNode = function(deep) {
          return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
        };
        // add innerHTML to template, if possible
        // Note: this throws on Safari 7
        if (canDecorate) {
          try {
            defineInnerHTML(template);
          } catch (err) {
            canDecorate = false;
          }
        }
      }
      // bootstrap recursively
      PolyfilledHTMLTemplateElement.bootstrap(template.content);
    };

    function defineInnerHTML(obj) {
      Object.defineProperty(obj, "innerHTML", {
        get: function() {
          var o = "";
          for (var e = this.content.firstChild; e; e = e.nextSibling) {
            o += e.outerHTML || escapeData(e.data);
          }
          return o;
        },
        set: function(text) {
          contentDoc.body.innerHTML = text;
          PolyfilledHTMLTemplateElement.bootstrap(contentDoc);
          while (this.content.firstChild) {
            this.content.removeChild(this.content.firstChild);
          }
          while (contentDoc.body.firstChild) {
            this.content.appendChild(contentDoc.body.firstChild);
          }
        },
        configurable: true
      });
    }

    defineInnerHTML(PolyfilledHTMLTemplateElement.prototype);

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    PolyfilledHTMLTemplateElement.bootstrap = function(doc) {
      var templates = doc.querySelectorAll(TEMPLATE_TAG);
      for (
        var i = 0, l = templates.length, t;
        i < l && (t = templates[i]);
        i++
      ) {
        PolyfilledHTMLTemplateElement.decorate(t);
      }
    };

    // auto-bootstrapping for main document
    document.addEventListener("DOMContentLoaded", function() {
      PolyfilledHTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    Document.prototype.createElement = function() {
      "use strict";
      var el = Native_createElement.apply(this, arguments);
      if (el.localName === "template") {
        PolyfilledHTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "\u00A0":
          return "&nbsp;";
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  }

  // make cloning/importing work!
  if (needsTemplate || needsCloning) {
    PolyfilledHTMLTemplateElement._cloneNode = function(template, deep) {
      var clone = Native_cloneNode.call(template, false);
      // NOTE: decorate doesn't auto-fix children because they are already
      // decorated so they need special clone fixup.
      if (this.decorate) {
        this.decorate(clone);
      }
      if (deep) {
        // NOTE: use native clone node to make sure CE's wrapped
        // cloneNode does not cause elements to upgrade.
        clone.content.appendChild(
          Native_cloneNode.call(template.content, true)
        );
        // now ensure nested templates are cloned correctly.
        this.fixClonedDom(clone.content, template.content);
      }
      return clone;
    };

    PolyfilledHTMLTemplateElement.prototype.cloneNode = function(deep) {
      return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
    };

    // Given a source and cloned subtree, find <template>'s in the cloned
    // subtree and replace them with cloned <template>'s from source.
    // We must do this because only the source templates have proper .content.
    PolyfilledHTMLTemplateElement.fixClonedDom = function(clone, source) {
      // do nothing if cloned node is not an element
      if (!source.querySelectorAll) return;
      // these two lists should be coincident
      var s$ = source.querySelectorAll(TEMPLATE_TAG);
      var t$ = clone.querySelectorAll(TEMPLATE_TAG);
      for (var i = 0, l = t$.length, t, s; i < l; i++) {
        s = s$[i];
        t = t$[i];
        if (this.decorate) {
          this.decorate(s);
        }
        t.parentNode.replaceChild(s.cloneNode(true), t);
      }
    };

    // override all cloning to fix the cloned subtree to contain properly
    // cloned templates.
    Node.prototype.cloneNode = function(deep) {
      var dom;
      // workaround for Edge bug cloning documentFragments
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8619646/
      if (this instanceof DocumentFragment) {
        if (!deep) {
          return this.ownerDocument.createDocumentFragment();
        } else {
          dom = this.ownerDocument.importNode(this, true);
        }
      } else {
        dom = Native_cloneNode.call(this, deep);
      }
      // template.content is cloned iff `deep`.
      if (deep) {
        PolyfilledHTMLTemplateElement.fixClonedDom(dom, this);
      }
      return dom;
    };

    // NOTE: we are cloning instead of importing <template>'s.
    // However, the ownerDocument of the cloned template will be correct!
    // This is because the native import node creates the right document owned
    // subtree and `fixClonedDom` inserts cloned templates into this subtree,
    // thus updating the owner doc.
    Document.prototype.importNode = function(element, deep) {
      if (element.localName === TEMPLATE_TAG) {
        return PolyfilledHTMLTemplateElement._cloneNode(element, deep);
      } else {
        var dom = Native_importNode.call(this, element, deep);
        if (deep) {
          PolyfilledHTMLTemplateElement.fixClonedDom(dom, element);
        }
        return dom;
      }
    };

    if (needsCloning) {
      window.HTMLTemplateElement.prototype.cloneNode = function(deep) {
        return PolyfilledHTMLTemplateElement._cloneNode(this, deep);
      };
    }
  }

  if (needsTemplate) {
    window.HTMLTemplateElement = PolyfilledHTMLTemplateElement;
  }
})();

}

if (eon.polyfills.needCSSScopePolyfill()) {
    (function(doc, proto) {
  try {
    // check if browser supports :scope natively
    doc.querySelector(":scope body");
  } catch (err) {
    // polyfill native methods if it doesn't
    ["querySelector", "querySelectorAll"].forEach(function(method) {
      var nativ = proto[method];
      proto[method] = function(selectors) {
        if (/(^|,)\s*:scope/.test(selectors)) {
          // only if selectors contains :scope
          var id = this.id; // remember current element id
          this.id = "ID_" + Date.now(); // assign new unique id
          selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id); // replace :scope with #ID
          var result = doc[method](selectors);
          this.id = id; // restore previous id
          return result;
        } else {
          return nativ.call(this, selectors); // use native code for other selectors
        }
      };
    });
  }
})(window.document, Element.prototype);

}

if (eon.polyfills.needObjectAssignPolyfill()) {
    if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) {
      "use strict";
      if (target === undefined || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }

      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        var keysArray = Object.keys(nextSource);
        for (
          var nextIndex = 0, len = keysArray.length;
          nextIndex < len;
          nextIndex++
        ) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}

}

if (eon.polyfills.needPromisesPolyfill()) {
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ES6Promise=e()}(this,function(){"use strict";function t(t){var e=typeof t;return null!==t&&("object"===e||"function"===e)}function e(t){return"function"==typeof t}function n(t){B=t}function r(t){G=t}function o(){return function(){return process.nextTick(a)}}function i(){return"undefined"!=typeof z?function(){z(a)}:c()}function s(){var t=0,e=new J(a),n=document.createTextNode("");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}function u(){var t=new MessageChannel;return t.port1.onmessage=a,function(){return t.port2.postMessage(0)}}function c(){var t=setTimeout;return function(){return t(a,1)}}function a(){for(var t=0;t<W;t+=2){var e=V[t],n=V[t+1];e(n),V[t]=void 0,V[t+1]=void 0}W=0}function f(){try{var t=Function("return this")().require("vertx");return z=t.runOnLoop||t.runOnContext,i()}catch(e){return c()}}function l(t,e){var n=this,r=new this.constructor(p);void 0===r[Z]&&O(r);var o=n._state;if(o){var i=arguments[o-1];G(function(){return P(o,r,i,n._result)})}else E(n,r,t,e);return r}function h(t){var e=this;if(t&&"object"==typeof t&&t.constructor===e)return t;var n=new e(p);return g(n,t),n}function p(){}function v(){return new TypeError("You cannot resolve a promise with itself")}function d(){return new TypeError("A promises callback cannot return that same promise.")}function _(t){try{return t.then}catch(e){return nt.error=e,nt}}function y(t,e,n,r){try{t.call(e,n,r)}catch(o){return o}}function m(t,e,n){G(function(t){var r=!1,o=y(n,e,function(n){r||(r=!0,e!==n?g(t,n):S(t,n))},function(e){r||(r=!0,j(t,e))},"Settle: "+(t._label||" unknown promise"));!r&&o&&(r=!0,j(t,o))},t)}function b(t,e){e._state===tt?S(t,e._result):e._state===et?j(t,e._result):E(e,void 0,function(e){return g(t,e)},function(e){return j(t,e)})}function w(t,n,r){n.constructor===t.constructor&&r===l&&n.constructor.resolve===h?b(t,n):r===nt?(j(t,nt.error),nt.error=null):void 0===r?S(t,n):e(r)?m(t,n,r):S(t,n)}function g(e,n){e===n?j(e,v()):t(n)?w(e,n,_(n)):S(e,n)}function A(t){t._onerror&&t._onerror(t._result),T(t)}function S(t,e){t._state===$&&(t._result=e,t._state=tt,0!==t._subscribers.length&&G(T,t))}function j(t,e){t._state===$&&(t._state=et,t._result=e,G(A,t))}function E(t,e,n,r){var o=t._subscribers,i=o.length;t._onerror=null,o[i]=e,o[i+tt]=n,o[i+et]=r,0===i&&t._state&&G(T,t)}function T(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,o=void 0,i=t._result,s=0;s<e.length;s+=3)r=e[s],o=e[s+n],r?P(n,r,o,i):o(i);t._subscribers.length=0}}function M(t,e){try{return t(e)}catch(n){return nt.error=n,nt}}function P(t,n,r,o){var i=e(r),s=void 0,u=void 0,c=void 0,a=void 0;if(i){if(s=M(r,o),s===nt?(a=!0,u=s.error,s.error=null):c=!0,n===s)return void j(n,d())}else s=o,c=!0;n._state!==$||(i&&c?g(n,s):a?j(n,u):t===tt?S(n,s):t===et&&j(n,s))}function x(t,e){try{e(function(e){g(t,e)},function(e){j(t,e)})}catch(n){j(t,n)}}function C(){return rt++}function O(t){t[Z]=rt++,t._state=void 0,t._result=void 0,t._subscribers=[]}function k(){return new Error("Array Methods must be provided an Array")}function F(t){return new ot(this,t).promise}function Y(t){var e=this;return new e(U(t)?function(n,r){for(var o=t.length,i=0;i<o;i++)e.resolve(t[i]).then(n,r)}:function(t,e){return e(new TypeError("You must pass an array to race."))})}function q(t){var e=this,n=new e(p);return j(n,t),n}function D(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}function K(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}function L(){var t=void 0;if("undefined"!=typeof global)t=global;else if("undefined"!=typeof self)t=self;else try{t=Function("return this")()}catch(e){throw new Error("polyfill failed because global object is unavailable in this environment")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(e){}if("[object Promise]"===r&&!n.cast)return}t.Promise=it}var N=void 0;N=Array.isArray?Array.isArray:function(t){return"[object Array]"===Object.prototype.toString.call(t)};var U=N,W=0,z=void 0,B=void 0,G=function(t,e){V[W]=t,V[W+1]=e,W+=2,2===W&&(B?B(a):X())},H="undefined"!=typeof window?window:void 0,I=H||{},J=I.MutationObserver||I.WebKitMutationObserver,Q="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),R="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,V=new Array(1e3),X=void 0;X=Q?o():J?s():R?u():void 0===H&&"function"==typeof require?f():c();var Z=Math.random().toString(36).substring(2),$=void 0,tt=1,et=2,nt={error:null},rt=0,ot=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(p),this.promise[Z]||O(this.promise),U(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?S(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&S(this.promise,this._result))):j(this.promise,k())}return t.prototype._enumerate=function(t){for(var e=0;this._state===$&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===h){var o=_(t);if(o===l&&t._state!==$)this._settledAt(t._state,e,t._result);else if("function"!=typeof o)this._remaining--,this._result[e]=t;else if(n===it){var i=new n(p);w(i,t,o),this._willSettleAt(i,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===$&&(this._remaining--,t===et?j(r,n):this._result[e]=n),0===this._remaining&&S(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;E(t,void 0,function(t){return n._settledAt(tt,e,t)},function(t){return n._settledAt(et,e,t)})},t}(),it=function(){function t(e){this[Z]=C(),this._result=this._state=void 0,this._subscribers=[],p!==e&&("function"!=typeof e&&D(),this instanceof t?x(this,e):K())}return t.prototype["catch"]=function(t){return this.then(null,t)},t.prototype["finally"]=function(t){var n=this,r=n.constructor;return e(t)?n.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})}):n.then(t,t)},t}();return it.prototype.then=l,it.all=F,it.race=Y,it.resolve=h,it.reject=q,it._setScheduler=n,it._setAsap=r,it._asap=G,it.polyfill=L,it.Promise=it,it.polyfill(),it});
}

if (eon.polyfills.needLocaleStringPolyfill()) {
    (function (proxied) {
    Date.prototype.toLocaleString = function (locale, options) {

      if (options.month && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.months[options.month][this.getMonth()];
      } else if (options.weekday && Object.keys(options).length == 1) {
        return eon.time.defaultLocale.weekdays[options.weekday][this.getDay()];
      }

      return proxied.apply(this, arguments);
    };
  })(Date.prototype.toLocaleString);
}

if (eon.polyfills.needClassListAddPolyfill()) {
    (function (proxied) {

    DOMTokenList.prototype.add = function () {
      
      if(arguments.length > 1) {
        
        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }
        
      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.add);
  
  (function (proxied) {

    DOMTokenList.prototype.remove = function () {

      if (arguments.length > 1) {

        for (var i = 0; i < arguments.length; i++) {
          proxied.apply(this, [arguments[i]]);
        }

      } else {
        return proxied.apply(this, arguments);
      }

    };
  })(DOMTokenList.prototype.remove);
}

/*!
 * PEP v0.4.3 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
      ? define(factory)
      : (global.PointerEventsPolyfill = factory());
})(this, function() {
  "use strict";

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",
    "pageX",
    "pageY"
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent("Event");
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.twist = inDict.twist || 0;
    e.tangentialPressure = inDict.tangentialPressure || 0;
    e.pointerType = inDict.pointerType || "";
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [
    // MouseEvent
    "bubbles",
    "cancelable",
    "view",
    "detail",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "ctrlKey",
    "altKey",
    "shiftKey",
    "metaKey",
    "button",
    "relatedTarget",

    // DOM Level 3
    "buttons",

    // PointerEvent
    "pointerId",
    "width",
    "height",
    "pressure",
    "tiltX",
    "tiltY",
    "pointerType",
    "hwTimestamp",
    "isPrimary",

    // event instance
    "type",
    "target",
    "currentTarget",
    "which",
    "pageX",
    "pageY",
    "timeStamp"
  ];

  var CLONE_DEFAULTS = [
    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    "",
    0,
    false,

    // event instance
    "",
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    pointerover: 1,
    pointerout: 1,
    pointerenter: 1,
    pointerleave: 1
  };

  var HAS_SVG_INSTANCE = typeof SVGElementInstance !== "undefined";

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; i < l && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */ function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {
        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerdown", inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointermove", inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerup", inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerenter", inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent("pointerleave", inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerover", inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointerout", inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent("pointercancel", inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */ function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */ function(
      target,
      eventName
    ) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {
      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === "target" || p === "relatedTarget")) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];

      // Order of conditions due to document.contains() missing in IE.
      while (target !== document && !target.contains(event.relatedTarget)) {
        targets.push(target);
        target = target.parentNode;

        // Touch: Do not propagate if node is detached.
        if (!target) {
          return;
        }
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget, skipDispatch) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId, skipDispatch);
      }

      this.captureInfo[inPointerId] = inTarget;
      this.implicitRelease = this.releaseCapture.bind(
        this,
        inPointerId,
        skipDispatch
      );
      document.addEventListener("pointerup", this.implicitRelease);
      document.addEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("gotpointercapture");
      e.pointerId = inPointerId;
      e._target = inTarget;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    releaseCapture: function(inPointerId, skipDispatch) {
      var t = this.captureInfo[inPointerId];
      if (!t) {
        return;
      }

      this.captureInfo[inPointerId] = undefined;
      document.removeEventListener("pointerup", this.implicitRelease);
      document.removeEventListener("pointercancel", this.implicitRelease);

      var e = new PointerEvent("lostpointercapture");
      e.pointerId = inPointerId;
      e._target = t;

      if (!skipDispatch) {
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */ function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector("shadow");
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {
          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {
            // check for older shadows
            sr = this.olderShadow(sr);
          } else {
            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (
        s.nodeType !== Node.DOCUMENT_NODE &&
        s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE
      ) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = "[touch-action]";
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ["touch-action"]
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {
      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== "complete") {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener(
        "readystatechange",
        function() {
          if (document.readyState === "complete") {
            this.installNewSubtree(document);
          }
        }.bind(this)
      );
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {
      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === "childList") {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === "attributes") {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return "body /shadow-deep/ " + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return "{ -ms-touch-action: " + v + "; touch-action: " + v + "; }";
  }
  var attrib2css = [
    "none",
    "auto",
    "pan-x",
    "pan-y",
    {
      rule: "pan-x pan-y",
      selectors: ["pan-x pan-y", "pan-y pan-x"]
    }
  ];
  var styles = "";

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot =
    !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + "\n";
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + "\n";
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + "\n";
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + "\n";
          }
        }
      });

      var el = document.createElement("style");
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: "mouse",
    events: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout"],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) {
            e.buttons |= p.buttons;
          }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          this.prepareButtonsForMove(e, inEvent);
        }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = "touch-action";
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: ["touchstart", "touchmove", "touchend", "touchcancel"],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {
      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: "none",
      XSCROLLER: "pan-x",
      YSCROLLER: "pan-y",
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === "none") {
        return "none";
      } else if (t === st.XSCROLLER) {
        return "X";
      } else if (t === st.YSCROLLER) {
        return "Y";
      } else if (st.SCROLLER.exec(t)) {
        return "XY";
      }
    },
    POINTER_TYPE: "touch",
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {
      // set primary touch if there no pointers, or the only pointer is the mouse
      if (
        pointermap$1.size === 0 ||
        (pointermap$1.size === 1 && pointermap$1.has(1))
      ) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === "touchstart" || type === "touchmove") {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = (e.pointerId = inTouch.identifier + 2);
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = (inTouch.radiusX || inTouch.webkitRadiusX || 0) * 2;
      e.height = (inTouch.radiusY || inTouch.webkitRadiusY || 0) * 2;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === "none") {
          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === "XY") {
          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === "Y" ? "X" : "Y";
          var da = Math.abs(t["client" + a] - this.firstXY[a]);
          var doa = Math.abs(t["client" + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {
          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }.bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(
    touchEvents.elementAdded,
    touchEvents.elementRemoved,
    touchEvents.elementChanged,
    touchEvents
  );

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE =
    window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === "number";
  var msEvents = {
    events: [
      "MSPointerDown",
      "MSPointerMove",
      "MSPointerUp",
      "MSPointerOut",
      "MSPointerOver",
      "MSPointerCancel",
      "MSGotPointerCapture",
      "MSLostPointerCapture"
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("lostpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent("gotpointercapture", inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {
    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource("ms", msEvents);
      } else {
        Object.defineProperty(window.navigator, "maxTouchPoints", {
          value: 0,
          enumerable: true
        });
        dispatcher.registerSource("mouse", mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource("touch", touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  var h;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error("InvalidPointerId");
      error.name = "InvalidPointerId";
      throw error;
    }
  }
  function assertConnected(elem) {
    var parent = elem.parentNode;
    while (parent && parent !== elem.ownerDocument) {
      parent = parent.parentNode;
    }
    if (!parent) {
      var error = new Error("InvalidStateError");
      error.name = "InvalidStateError";
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this, true);
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, true);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId);
    };
  }
  h = function hasPointerCapture(pointerId) {
    return !!dispatcher.captureInfo[pointerId];
  };

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        setPointerCapture: {
          value: s
        },
        releasePointerCapture: {
          value: r
        },
        hasPointerCapture: {
          value: h
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;
});

var eon = eon || {};

(function () {
    var eon = this;

    // NOTE: template import order matters!    
    // ############################################################################################
// DEBUG
// ############################################################################################

eon.debug = eon.debug || {};

eon.debug.polyfill = eon.debug.polyfill || false;

eon.warn = eon.warn || {};

eon.error = eon.error || {};

eon.debug.log = function(condition, message) {
  if (eon.debug[condition]) {
    console.log(condition + ": " + message);
  }
};

eon.warn.log = function(condition, message) {
  if (eon.warn[condition]) {
    console.warn(condition + ": " + message);
  }
};

eon.error.log = function(condition, message) {
  if (eon.error[condition]) {
    console.error(condition + ": " + message);
  }
};

eon.debug.adapterEvents = eon.debug.adapterEvents || false;
eon.debug.configEvents = eon.debug.configEvents || false;
eon.debug.elementEvents = eon.debug.elementEvents || false;

eon.warn.store = eon.warn.store || true;
eon.error.store = eon.error.store || true;
    
    // ############################################################################################
// BASE
// ############################################################################################
eon.getCurrentScript = function() {
    if (document.currentScript) {
      return document.currentScript.src;
    } else {
      var scripts = document.getElementsByTagName("script");
      return scripts[scripts.length - 1].src;
    }
  };
  
  eon.__setBase = function() {
    var path = eon.getCurrentScript().replace("/eon.js", "");
    path = path.replace(/.*:\/\//g, "");
    path = path.split("/");
    path = path.slice(1, path.length);
  
    var basePath = "";
    for (i = 0; i < path.length; i++) {
      basePath += "/";
      basePath += path[i];
    }
  
    eon.basePath = basePath;
  };
  
  // Attempt to find basePath if not set
  if (!eon.basePath) {
    eon.__setBase();
  }
      
    // ############################################################################################
// STYLE
// ############################################################################################

// Creates a style node and saves the reference
eon.style = document.createElement("style");
eon.rules = {};

// Appends the style to the head
document.head.appendChild(eon.style);

// Hides initial elements
eon.style.sheet.insertRule(".eon-until-rendered { opacity: 0; }", 0);
// Hide eon-script
eon.style.sheet.insertRule("eon-script { display: none; }", 0);

// ############################################################################################
// RESPONSIVE
// ############################################################################################

eon.mobileWidth = 450;
eon.tabletWidth = 800;

eon.addViewportMeta = eon.addViewportMeta || true;

if (eon.addViewportMeta) {
    document.write(
        '<meta name="viewport" content="width=device-width, initial-scale=1.0">'
    );
}

// ############################################################################################
// DEFAULT THEME
// ############################################################################################
if (!eon.theme) {
    eon.theme = "noire";
}    
    eon.polyfills = eon.polyfills || {};

// ############################################################################################
// POLYFILL DETECTION
// ############################################################################################

eon.polyfills.injectPolyfill = function (url) {
  document.write("<script type='text/javascript' src='" + url + "'><\/script>");
};

eon.polyfills.needCustomElementsPolyfill = function () {
  var __customElements = window.hasOwnProperty("customElements");
  if (eon.debug.polyfill) {
    console.log("Polyfill custom-elements", !__customElements);
  }
  return !__customElements;
};

eon.polyfills.needTemplatePolyfill = function () {
  var __template = "content" in document.createElement("template") === true;
  if (eon.debug.polyfill) {
    console.log("Polyfill template", !__template);
  }
  return !__template;
};

eon.polyfills.needCSSScopePolyfill = function () {
  var needPolyfill = false;
  try {
    doc.querySelector(":scope body");
  } catch (err) {
    needPolyfill = true;
  }
  if (eon.debug.polyfill) {
    console.log("Polyfill CSS Scope", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needObjectAssignPolyfill = function () {
  var needPolyfill = !Object.assign;
  if (eon.debug.polyfill) {
    console.log("Polyfill Object Assign", needPolyfill);
  }
  return needPolyfill;
};

eon.polyfills.needLocaleStringPolyfill = function () {
  return (new Date(1994, 1, 9).toLocaleString("en", { weekday: "short" }) != "Wed");
}

eon.polyfills.needPromisesPolyfill = function () {
  if(typeof Promise !== "undefined" && Promise.toString().indexOf("[native code]") !== -1){
    return false;
  }
  return true;
}
eon.polyfills.needClassListAddPolyfill = function () {
  var div = document.createElement("div");
  div.classList.add("class1", "class2");

  return div.classList.contains("class2") ? false : true;
}

// ############################################################################################
// POLYFILL IMPORTS
// ############################################################################################

// Custom Elements - https://github.com/webcomponents/custom-elements
if (!eon.polyfills.customElements && eon.polyfills.needCustomElementsPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/custom-elements/custom-elements.min.js");
}

// Template - https://github.com/webcomponents/template
if (!eon.polyfills.template && eon.polyfills.needTemplatePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/template/template.js");
}

// CSS :scope
if (!eon.polyfills.CSSScope && eon.polyfills.needCSSScopePolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/css/scope.js");
}

// Object.assign
if (!eon.polyfills.assign && eon.polyfills.needObjectAssignPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/object/assign.js");
}

// Promises
if (!eon.polyfills.promises && eon.polyfills.needPromisesPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/promises/promises.js");
}

// Date locale polyfill
if (!eon.polyfills.localeString && eon.polyfills.needLocaleStringPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/locale-string/locale-string.js");
}

//
if (!eon.polyfills.classList && eon.polyfills.needClassListAddPolyfill()) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/class-list/class-list.js");
}

// Pointer events (Must run always)
if (!eon.polyfills.pep) {
  eon.polyfills.injectPolyfill(eon.basePath + "/polyfill/pointer-events/pep.js");
}



    
    // ############################################################################################
// IMPORT JS - AMD (RequireJS)
// ############################################################################################

// Creates a namespace for requirejs
eon.amd = eon.amd || {};

(function () {

  // Import requirejs file
  // ------------------------------------------------------------------------------------
    /** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.3.5 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, https://github.com/requirejs/requirejs/blob/master/LICENSE
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global, setTimeout) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.3.5',
        commentRegExp = /\/\*[\s\S]*?\*\/|([^:"'=]|^)\/\/.*$/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    //Could match something like ')//comment', do not lose the prefix to comment.
    function commentReplace(match, singlePrefix) {
        return singlePrefix || '';
    }

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (isNormalized) {
                        normalizedName = name;
                    } else if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                var resLoadMaps = [];
                                each(this.depMaps, function (depMap) {
                                    resLoadMaps.push(depMap.normalizedMap || depMap);
                                });
                                req.onResourceLoad(context, this.map, resLoadMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap,
                                                      true);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.map.normalizedMap = normalizedMap;
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                // Convert old style urlArgs string to a function.
                if (typeof cfg.urlArgs === 'string') {
                    var urlArgs = cfg.urlArgs;
                    cfg.urlArgs = function(id, url) {
                        return (url.indexOf('?') === -1 ? '?' : '&') + urlArgs;
                    };
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|^blob\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs && !/^blob\:/.test(url) ?
                       url + config.urlArgs(moduleName, url) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    var parents = [];
                    eachProp(registry, function(value, key) {
                        if (key.indexOf('_@r') !== 0) {
                            each(value.depMaps, function(depMap) {
                                if (depMap.id === data.id) {
                                    parents.push(key);
                                    return true;
                                }
                            });
                        }
                    });
                    return onError(makeError('scripterror', 'Script error for "' + data.id +
                                             (parents.length ?
                                             '", needed by: ' + parents.join(', ') :
                                             '"'), evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/requirejs/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/requirejs/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //Calling onNodeCreated after all properties on the node have been
            //set, but before it is placed in the DOM.
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation is that a build has been done so
                //that only one script needs to be loaded anyway. This may need
                //to be reevaluated if other use cases become common.

                // Post a task to the event loop to work around a bug in WebKit
                // where the worker gets garbage-collected after calling
                // importScripts(): https://webkit.org/b/153317
                setTimeout(function() {}, 0);
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one,
                //but only do so if the data-main value is not a loader plugin
                //module ID.
                if (!cfg.baseUrl && mainScript.indexOf('!') === -1) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, commentReplace)
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));  // ------------------------------------------------------------------------------------

  this.require = require;
  this.define = define;

}).apply(eon.amd);
    
    // MODE: INTERPRETER
// - client (browser)
// - server (node)
//
// MODE: COMMAND	(node)


var vimlet = vimlet || {};

vimlet.meta = vimlet.meta || {};

// Hooks for sanbox functions
// vimlet.meta.sandbox

(function () {
  // Node require
  var require_fs;
  var require_vm;

  // Engine [browser, node]
  vimlet.meta.engine = vimlet.meta.engine || "browser";

  // Tags Array [tagOpen, tagClose, tagEcho]
  vimlet.meta.tags = vimlet.meta.tags || ["", "="];

  //Line break replacement
  vimlet.meta.lineBreak = vimlet.meta.lineBreak || null;

  // Decode html
  vimlet.meta.decodeHTML = vimlet.meta.decodeHTML || true;
  vimlet.meta.__decodeEntityRegex = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/ig;

  vimlet.meta.parse = function (scope, text, data, callback) {

    if (vimlet.meta.decodeHTML) {
      text = vimlet.meta.__decodeHTMLEntities(text);
    }

    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parse(text);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  vimlet.meta.parseTemplate = function (scope, template, data, callback) {
    vimlet.meta.__setTags();
    var __sandbox = vimlet.meta.__createSandbox(scope);
    __sandbox.data = data || {};
    var result = __sandbox.__parseTemplate(template);
    vimlet.meta.__destroySandbox(__sandbox);
    callback(result);
  };

  // Decode html entities
  vimlet.meta.__decodeHTMLEntities = function (str) {

    if (vimlet.meta.engine === "browser") {

      if (!vimlet.meta.__decodeElement) {
        vimlet.meta.__decodeElement = document.createElement("div");
      }

      if (str && typeof str === "string") {

        // find and replace all the html entities
        str = str.replace(vimlet.meta.__decodeEntityRegex, function (match) {
          vimlet.meta.__decodeElement.innerHTML = match;
          return vimlet.meta.__decodeElement.textContent;
        });

        // reset the value
        vimlet.meta.__decodeElement.textContent = "";

      }

    }

    return str;

  }

  // Initialize tags
  vimlet.meta.__setTags = function () {
    // Tags
    vimlet.meta.__tagOpen = vimlet.meta.tags[0];
    vimlet.meta.__tagClose = vimlet.meta.tags[1];
    vimlet.meta.__tagEcho = vimlet.meta.tags[2];

    // Regex
    vimlet.meta.__regex = new RegExp(
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      "(?:(?!" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagOpen) +
      ")[\\s\\S])*" +
      vimlet.meta.__escapeRegExp(vimlet.meta.__tagClose) +
      "(\\r\\n|\\r|\\n){0,1}",
      "g"
    );
  };

  // Escape special characters from tags
  vimlet.meta.__escapeRegExp = function (str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  // Sanitize given string.
  vimlet.meta.sanitize = function (s) {
    s = s.replace(vimlet.meta.__tagOpen, "");
    s = s.replace(vimlet.meta.__tagClose, "");
    return s;
  };

  vimlet.meta.__getFile = function (path, callback) {
    if (vimlet.meta.engine == "node") {
      // node command
      if (!require_fs) {
        require_fs = require("fs");
      }

      if (callback) {
        // Must be asynchronous
        require_fs.readFile(path, "utf8", function (error, buf) {
          if (error) {
            console.log(error);
          } else {
            callback(buf.toString());
          }
        });
      } else {
        // Must be synchronous
        return require_fs.readFileSync(path, "utf8").toString();
      }
    } else {
      // TODO replace XMLHttpRequest by window.fetch with synchronous support
      // Browser
      var xhttp = new XMLHttpRequest();

      xhttp.onreadystatechange = function () {
        if (this.readyState === 4) {
          if (this.status === 200) {
            if (callback) {
              // Must be asynchronous
              callback(xhttp.responseText);
            }
          } else {
            console.log("File error: " + this.status);
          }
        }
      };

      if (callback) {
        // Must be asynchronous
        xhttp.open("GET", path, true);
        xhttp.send();
      } else {
        // Must be synchronous
        xhttp.open("GET", path, false);
        xhttp.send();
        return xhttp.responseText;
      }
    }
  };

  vimlet.meta.__createSandbox = function (scope) {
    var sandbox = eval.call(null, "this");

    if (vimlet.meta.engine == "node") {
      if (!require_vm) {
        require_vm = require("vm");
      }

      // Clone node global scope to baseContext
      var baseContext = Object.assign({}, sandbox);

      // Add other node global modules to baseContext

      // exports
      // require
      // module
      // __filename
      // __dirname

      baseContext.exports = exports;
      baseContext.require = require;
      baseContext.module = module;
      baseContext.__filename = __filename;
      baseContext.__dirname = __dirname;

      sandbox = new require_vm.createContext(baseContext);
    } else {
      // Browser sandbox
      iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.setAttribute(
        "sandbox",
        "allow-same-origin allow-scripts allow-popups allow-forms allow-modals"
      );
      document.body.appendChild(iframe);
      sandbox = iframe.contentWindow;
    }

    // Inject scope
    if (scope) {
      sandbox.context = scope;
    }

    // Inject sandbox functions
    vimlet.meta.__injectSandboxFunctions(sandbox);

    return sandbox;
  };

  vimlet.meta.__destroySandbox = function (sandbox) {
    if (vimlet.meta.engine == "browser") {
      var iframe = sandbox.frameElement;
      iframe.parentNode.removeChild(iframe);
    }

    sandbox = null;
  };

  vimlet.meta.__injectSandboxFunctions = function (sandbox) {
    sandbox.__output = "";

    sandbox.__basePath = "";

    sandbox.echo = function (s) {
      sandbox.__output += s;
    };

    sandbox.template = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var storedOutput = sandbox.__output;
      var parsedTemplate = sandbox.__parseTemplate(__fullPath);
      sandbox.__output = storedOutput + parsedTemplate;
    };

    sandbox.include = function (t) {
      var __fullPath = sandbox.__basePath + "/" + t;
      var parsedTemplate = sandbox.__includeTemplate(__fullPath);
    };

    sandbox.__eval = function (s, basepath) {
      sandbox.__output = "";
      sandbox.__basePath = basepath;

      if (vimlet.meta.engine == "node") {
        var script = new require_vm.Script(s);
        script.runInContext(sandbox);
      } else {
        sandbox.eval.call(null, s);
      }

      return sandbox.__output;
    };

    sandbox.__parse = function (t, templatePath) {
      var result = "";

      if (!templatePath) {
        templatePath = "";
      }

      // Eval matches
      var endOfLine = "";

      // Replace template with evalMatches
      result = t.replace(vimlet.meta.__regex, function (match) {
        endOfLine = vimlet.meta.__preserveNewLineIfNeeded(match);
        match = vimlet.meta.__cleanMatch(match);
        return sandbox.__eval(match, vimlet.meta.__getBasePath(templatePath)) + endOfLine;
      });

      //Replace line break.
      if (vimlet.meta.lineBreak) {
        result = result.replace(
          new RegExp("[\\r\\n|\\r|\\n]+", "g"),
          vimlet.meta.lineBreak
        );
      }

      return result;
    };

    sandbox.__parseTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser
      return sandbox.__parse(tContent, templatePath);
    };

    sandbox.__includeTemplate = function (templatePath) {
      // Get file must be synchronous
      var tContent = vimlet.meta.__getFile(templatePath);
      // Call template parser with wrapped in tags since its code that must run inside sandboxed scope
      return sandbox.__parse(vimlet.meta.tags[0] + " " + tContent + " " + vimlet.meta.tags[1], templatePath);
    };

    // Inject custom properties so they are available to the sandbox
    if (vimlet.meta.sandbox) {
      var customSandboxKeys = Object.keys(vimlet.meta.sandbox);
      var key;
      var value;
      for (var i = 0; i < customSandboxKeys.length; i++) {
        key = customSandboxKeys[i];
        value = vimlet.meta.sandbox[key];
        if (typeof value === "function") {
          // Inject sandbox scope if its a function
          sandbox[key] = function () {
            value.apply(sandbox, arguments);
          };
        } else {
          // Inject directly for any other property
          sandbox[key] = value;
        }
      }
    }

  };

  vimlet.meta.__getBasePath = function (f) {
    // Replace Windows separators
    var standarPath = f.replace(/\\/g, "/");
    var path = standarPath.split("/");

    var base = "";

    if (standarPath.indexOf("/") > -1) {
      // Remove last part of the path
      for (var i = 0; i < path.length - 1; i++) {
        base += "/" + path[i];
      }

      // Remove first /
      base = base.substring(1, base.length);
    }

    return base;
  };

  vimlet.meta.__cleanMatch = function (match) {
    // Remove new line
    match = match.trim();

    // Remove tags
    match = match
      .substring(
        vimlet.meta.__tagOpen.length,
        match.length - vimlet.meta.__tagClose.length
      )
      .trim();

    // Echo shortcut if starts with echo tag
    if (match.indexOf(vimlet.meta.__tagEcho, 0) === 0) {
      match = "echo(" + match.substring(vimlet.meta.__tagEcho.length, match.length).trim() + ");";
    }

    // Allow the creation of custom shortcuts
    if (vimlet.meta.shortcut) {
      var shortcutKeys = Object.keys(vimlet.meta.shortcut);
      var shortcutTag;
      var shortcutHandler;
      for (var i = 0; i < shortcutKeys.length; i++) {
        shortcutTag = shortcutKeys[i];
        shortcutHandler = vimlet.meta.shortcut[shortcutTag];
        if (match.indexOf(shortcutTag, 0) === 0) {
          match = shortcutHandler(match.substring(shortcutTag.length, match.length).trim());
        }
      }
    }

    return match;
  };

  vimlet.meta.__preserveNewLineIfNeeded = function (match) {

    // Remove start spaces with regex since trimLeft is not IE compatible
    match = match.replace(/^\s+/, "");

    var endOfLine = "";

    // Return endOfLine if echo found
    if (match.match(new RegExp("(^" + vimlet.meta.__tagOpen + vimlet.meta.__tagEcho + "|echo(.*);|template(.*);)", "g"))) {

      // Determine match end of line
      var endsWithNewLine = match.match(new RegExp("(\\r\\n$|\\r$|\\n$)", "g"));

      if (endsWithNewLine) {
        endOfLine = endsWithNewLine[0];
      }

    }

    return endOfLine;
  };

}.apply(vimlet.meta));  
    
// ############################################################################################
// CORE MODULES
// ############################################################################################

// ** First line not read by meta
eon.object = eon.object || {};

eon.object.assignToPath = function(obj, path, value) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < (pathArray.length - 1); i++) {
    if(!target[pathArray[i]]) {
      target[pathArray[i]] = {};
    }

    target = target[pathArray[i]];    
  }

  target[pathArray[pathArray.length - 1]] = value;
};

eon.object.readFromPath = function(obj, path) {
  var pathArray = path.split(".");
  var target = obj;

  for (var i = 0; i < pathArray.length; i++) {
    if (target) {
      target = target[pathArray[i]];    
    }
  }

  return target;
};



//  --- Types ---
//  always: (default)     Call stored functions always when triggered.
//  once:                Call stored functions once when triggered.
//  ready:              Call stored functions when triggered and force future functions to run immediately.
eon.createCallback = function (callback, obj, type) {
  // Set callback type
  if (!obj["__" + callback + "__type"]) {
    // Set always as the default type when undefined
    if (typeof type === "undefined") {
      type = "always";
    }
    obj["__" + callback + "__type"] = type;
  }
  // Set callback triggered flag
  if (!obj["__" + callback + "__triggered"]) {
    obj["__" + callback + "__triggered"] = false;
  }
  // Stored functions array
  if (!obj["__" + callback]) {
    obj["__" + callback] = [];
  }
  // Add callback function to array
  if (!obj[callback]) {
    obj[callback] = function (fn, scope, args) {

      // If ready and triggered inmediately call the function else store it
      if (
        obj["__" + callback + "__type"] === "ready" &&
        obj["__" + callback + "__triggered"] === true
      ) {
        fn.apply(
          obj["__" + callback + "__scope"],
          obj["__" + callback + "__args"]
        );
      } else {
        // callback wrapper object
        obj["__" + callback].push({
          fn: fn,
          scope: scope,
          args: args
        });
      }
    };
  }
};

eon.triggerCallback = function (callback, obj, scope, args) {

  // Check if callback exsists
  if (obj["__" + callback]) {
    // Check if callback functions need to be triggered
    if (obj["__" + callback + "__type"] === "always" || obj["__" + callback + "__triggered"] === false) {

      obj["__" + callback + "__triggered"] = true;

      var scopeUndefinedOrNull = typeof scope === "undefined" || scope == null;
      var argsUndefinedOrNull = typeof args === "undefined" || args == null;
      var callbackFunctions = obj["__" + callback];

      // If the callback is of "ready" type we make a copy of the functions queue to trigger them and then clear the callback queue
      if (obj["__" + callback + "__type"] == "ready") {
        callbackFunctions = obj["__" + callback].slice(0);
        obj["__" + callback] = [];
      }

      // Trigger stored functions
      for (var i = 0; i < callbackFunctions.length; i++) {

        if (scopeUndefinedOrNull) {
          scope = callbackFunctions[i].scope ? callbackFunctions[i].scope : obj;
        }

        if (argsUndefinedOrNull) {
          args = callbackFunctions[i].args ? callbackFunctions[i].args : [];
        }

        callbackFunctions[i].fn.apply(scope, args);

      }

      // Store scope, args and tag as triggered
      obj["__" + callback + "__scope"] = scope;
      obj["__" + callback + "__args"] = args;

    }
  }
};

eon.removeCallback = function (callback, obj, fn) {
  var callbacksArray = obj["__" + callback];

  for (var i = 0; i < callbacksArray.length; i++) {
    if (callbacksArray[i].fn === fn) {
      callbacksArray.splice(i, 1);
    }
  }
};



eon.dom = eon.dom || {};

// eon custom selector function
// prototype $ and $1 should not conflict with other frameworks API 

HTMLElement.prototype.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? this.querySelector(query) : this.querySelectorAll(query);
};

HTMLElement.prototype.$1 = function (query) {
  return this.querySelector(query);
};

HTMLElement.prototype.getEnclosingComponent = function () {

  var parentNode = this.parentNode;
  var nodeName, enclosingComponent;
  
  while (parentNode) {

    if (parentNode.eon) {

      enclosingComponent = parentNode;
      parentNode = undefined;
      
    } else {

      nodeName = parentNode.nodeName.toLowerCase();
      parentNode = nodeName == "body" ? undefined : parentNode.parentNode;

    }

  }

  return enclosingComponent;

};

// eon definitions will always be available
eon.$ = function (query) {
  return query.indexOf("#", 0) === 0 ? document.querySelector(query) : document.querySelectorAll(query);
};

eon.$1 = function (query) {
  return document.querySelector(query);
};

// window & document definitions will use any other framework $ and $1 if found
window.$ = window.$ || eon.$;
window.$1 = window.$1 || eon.$1;
document.$ = document.$ || eon.$;
document.$1 = document.$1 || eon.$1;

// TODO: MOVE THIS EXCEPT DOMREADY TO eon.DOM
(function () {
  var self = this;

  // eon.domReady (Doesn't wait for customElements)
  (function (funcName, baseObj) {
    "use strict";
    // The public function name defaults to window.docReady
    // but you can modify the last line of this function to pass in a different object or method name
    // if you want to put them in a different namespace and those will be used instead of
    // window.docReady(...)
    funcName = funcName || "docReady";
    baseObj = baseObj || window;
    var readyList = [];
    var readyFired = false;
    var readyEventHandlersInstalled = false;
    // call this when the document is ready
    // this function protects itself against being called more than once
    function ready() {
      if (!readyFired) {
        // this must be set to true before we start calling callbacks
        readyFired = true;
        for (var i = 0; i < readyList.length; i++) {
          // if a callback here happens to add new ready handlers,
          // the docReady() function will see that it already fired
          // and will schedule the callback to run right after
          // this event loop finishes so all handlers will still execute
          // in order and no new ones will be added to the readyList
          // while we are processing the list
          readyList[i].fn.call(window, readyList[i].ctx);
        }
        // allow any closures held by these functions to free
        readyList = [];
      }
    }

    function readyStateChange() {
      if (document.readyState === "complete") {
        ready();
      }
    }
    // This is the one public interface
    // docReady(fn, context);
    // the context argument is optional - if present, it will be passed
    // as an argument to the callback
    baseObj[funcName] = function (callback, context) {
      if (typeof callback !== "function") {
        throw new TypeError("callback for docReady(fn) must be a function");
      }
      // if ready has already fired, then just schedule the callback
      // to fire asynchronously, but right away
      if (readyFired) {
        setTimeout(function () {
          callback(context);
        }, 1);
        return;
      } else {
        // add the function and context to the list
        readyList.push({
          fn: callback,
          ctx: context
        });
      }
      // if document already ready to go, schedule the ready function to run
      // IE only safe when readyState is "complete", others safe when readyState is "interactive"
      if (
        document.readyState === "complete" ||
        (!document.attachEvent && document.readyState === "interactive")
      ) {
        setTimeout(ready, 1);
      } else if (!readyEventHandlersInstalled) {
        // otherwise if we don't have event handlers installed, install them
        if (document.addEventListener) {
          // first choice is DOMContentLoaded event
          document.addEventListener("DOMContentLoaded", ready, false);
          // backup is window load event
          window.addEventListener("load", ready, false);
        } else {
          // must be IE
          document.attachEvent("onreadystatechange", readyStateChange);
          window.attachEvent("onload", ready);
        }
        readyEventHandlersInstalled = true;
      }
    };
  })("domReady", self);

  self.getEnclosingComponent = function (el) {
    while (
      el.parentNode &&
      Object.prototype.toString.call(el.parentNode) != "[object HTMLDocument]"
    ) {
      el = el.parentNode;

      if (el.eon) {
        return el;
      }
    }

    return null;
  };

  // Register resize listener callback
  eon.createCallback("onResize", eon);
  
  window.addEventListener("resize", function (event) {
    eon.triggerCallback("onResize", eon, null, [event]);
  });

  // Register global focus
  eon.domReady(function () {
    document.body.addEventListener(
      "focus",
      function (e) {
        eon.triggerCallback("onFocus", eon, e.target, e);

        if (e.target.onFocus) {
          eon.triggerCallback("onFocus", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusin = focusHandler; //IE

    // Register global blur
    document.body.addEventListener(
      "blur",
      function (e) {
        eon.triggerCallback("onBlur", eon, e.target, e);

        if (e.target.onBlur) {
          eon.triggerCallback("onBlur", e.target, e.target, e);
        }
      },
      true
    ); //Non-IE
    //document.body.onfocusout = blurHandler; //IE
  });

  // ###########################################################################

  /**
   * The right position (in pixels) relative to the right side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetRight = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docWidth = parent.offsetWidth;
    // Get element offset left and offset width
    var elOffsetLeft = el.offsetLeft;
    var elOffsetWidth = el.offsetWidth;
    // Calculate offset right value
    var offsetRight = docWidth - (elOffsetLeft + elOffsetWidth);
    return offsetRight;
  };
  /**
   * The bottom position (in pixels) relative to the bottom side of the specified parent
   * * If no parent is specified, document body is de default one
   * @param {[type]} el     [description]
   * @param {[type]} parent [description]
   */
  eon.dom.offsetBottom = function (el, parent) {
    // Get parent the element is relative to
    parent = !parent ? document.documentElement || document.body : parent;
    var docHeight = parent.offsetHeight;
    // Get element offset top and offset height
    var elOffsetTop = el.offsetTop;
    var elOffsetHeight = el.offsetHeight;
    // Calculate offset bottom value
    var offsetBottom = docHeight - (elOffsetTop + elOffsetHeight);
    return offsetBottom;
  };
  /**
   * Get element transform axis value
   * @param  {[type]}  el   [description]
   * @param  {[type]}  axis [description]
   * @return {Boolean}      [description]
   */
  eon.dom.getTransformAxis = function (el, axis) {
    var value;
    // Get element transform property
    var transform = el.style.transform;
    if (transform) {
      // Extract specified axis from transform string
      switch (axis.toLowerCase()) {
        case "x":
          value = parseInt(transform.split(",")[0].split("(")[1]);
          break;
        case "y":
          value = parseInt(transform.split(",")[1]);
          break;
        case "z":
          value = parseInt(transform.split(",")[2].split(")")[0]);
          break;
      }
    }
    return value;
  };
  /**
   * Move a node the specified pixels distance
   * @param  {[type]} node     [description]
   * @param  {[type]} distance [description]
   * @return {[type]}          [description]
   */
  eon.dom.translate = function (el, axis, value) {
    // Set the new node translate position
    switch (axis.toLowerCase()) {
      case "x":
        el.style.transform = "translate3d(" + value + "px, 0px, 0px)";
        break;
      case "y":
        el.style.transform = "translate3d(0px, " + value + "px, 0px)";
        break;
      case "z":
        el.style.transform = "translate3d(0px, 0px, " + value + "px)";
        break;
    }
  };

  /**
   * Whether or not the class exists in the dom
   * @param  {[type]} className [description]
   * @return {[type]}          [description]
   */
  eon.dom.classExists = function (className) {
    var el = this;
    var classes = eon.style.sheet.cssRules;
    var cls;
    
    for (var i = 0; i < classes.length; i++) {
        cls = classes[i];
  
        if(cls.selectorText == className){
        return true;
        }
    }
    return false;
  };

  // Register if the element is on the path on mouse events
  self.registerPathListener = function (el) {
    el.isOnPath = false;

    el.addEventListener("pointerdown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("mousedown", function () {
      el.isOnPath = true;
    }, true);

    el.addEventListener("touchstart", function () {
      el.isOnPath = true;
    }, true);

    document.addEventListener("pointerup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("mouseup", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

    document.addEventListener("touchend", function () {
      setTimeout(function () {
        el.isOnPath = false;
      }, 0);

    }, true);

  };
}.apply(eon));


// ############################################################################################
// IMPORT ELEMENTS
// ############################################################################################

// Create imports reade callback
eon.createCallback("onImportsReady", eon, "ready");
eon.createCallback("onScriptsReady", eon, "ready");

// Imports the requested custom element file, admits arrays and strings
eon.import = function (param) {

    if (param.constructor === Array) {

        for (var i = 0; i < param.length; i++) {
            eon.insertImport(param[i]);
        }

    } else if (param.constructor === String) {

        eon.insertImport(param);

    }

};

eon.insertImport = function (href) {

    var elementName;

    elementName = (href.indexOf(".html") > -1) ? href.match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase() : href.match(/[^\/]*$/g)[0].toLowerCase();
    href = (href.indexOf(".html") > -1) ? href : href + "/" + elementName + ".html";

    // Cache
    eon.cache.add(href, { name: elementName });

    eon.imports = eon.imports || {
        count: 0,
        total: 0,
        ready: false
    };

    eon.imports.style = eon.imports.style || "";

    eon.imports.scripts = eon.imports.scripts || {};
    eon.imports.links = eon.imports.links || {};
    eon.imports.templates = eon.imports.templates || {};
    eon.imports.paths = eon.imports.paths || {};
    eon.imports.config = eon.imports.config || {};

    if (!(elementName in eon.imports.templates)) {

        // Increment total
        eon.imports.total++;

        // Avoid duplicated imports while waiting XMLHttpRequest callback.
        eon.imports.templates[elementName] = null;

        // Saves the paths of the imported elements
        eon.imports.paths[elementName] = href.substring(0, href.length - href.match(/[^\/]*$/g)[0].length);

        // Declare element
        eon.declare(elementName);

        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {
                eon.insertFragment(elementName, this.responseText);
            }
        };

        xhttp.open("GET", href);
        xhttp.send();

    }

};

eon.insertFragment = function (elementName, content) {
    var importFragment = eon.fragmentFromString(content);

    var i;

    // Store combined styles
    var styles = importFragment.querySelectorAll("style");

    for (i = 0; i < styles.length; i++) {
        eon.imports.style += styles[i].innerHTML;
    }

    // Store scripts
    var scripts = importFragment.querySelectorAll("script");

    if (scripts.length > 0) {

        eon.imports.scripts[elementName] = {};

        for (i = 0; i < scripts.length; i++) {

            if (scripts[i].getAttribute("data-src")) {
                scripts[i].src = eon.imports.paths[elementName] + scripts[i].getAttribute("data-src");
                scripts[i].removeAttribute("data-src");
            }

            eon.imports.scripts[elementName][i] = scripts[i];

        }

    }

    // Store links
    var links = importFragment.querySelectorAll("link");

    if (links.length > 0) {

        eon.imports.links[elementName] = {};

        for (i = 0; i < links.length; i++) {
            eon.imports.links[elementName][i] = links[i];
        }

    }

    // Store template
    var template = importFragment.querySelector("template");

    if (template) {
        eon.imports.templates[elementName] = template;
    }

    // Wait unity domReady to ensure all imports are done and total value is accurate
    eon.domReady(function () {

        eon.imports.count++;
        
        if (!eon.imports.ready && eon.imports.count == eon.imports.total) {

            // Appends all elements combined style
            eon.handleStyleAppend();
            // Appends the imported links
            eon.handleLinksAppend();
            // Appends the imported scripts
            eon.handleScriptsAppend();
            // When all the scripts are properly appended and ready then we import dependencies and see if we have finished all the imports
            eon.onScriptsReady(function () {

                // Handles the dependencies and returns a boolean for whether there are pending imports or not
                var hasPendingImports = eon.handleDependencies();

                // If there are no more dependencies to handle trigger onImportsReady
                if (!hasPendingImports && !eon.imports.ready && eon.imports.count == eon.imports.total && eon.imports.total == Object.keys(eon.imports.config).length) {

                    eon.imports.ready = true;

                    // Here we will register the main theme, the one declared by the user or our default one
                    eon.importMainTheme(eon.theme);
                    // Reads the themeSchema and imports the requested files
                    eon.importSchemaThemes();

                    eon.triggerCallback('onImportsReady', eon);

                } else {
                    eon.__onScriptsReady__triggered = false;
                }

            });

        }

    });
};

eon.handleDependencies = function () {

    // Automated dependencies and interpolation
    var elementNames = Object.keys(eon.imports.config);
    var hasPendingImports = false;
    var hasDependencies;

    // For every element config imported we check if it needs dependencies and interpolation
    for (var i = 0; i < elementNames.length; i++) {

        // Handle dependencies
        hasDependencies = eon.handleConfigDependencies(elementNames[i]);

        if (hasDependencies) {
            hasPendingImports = true;
        }

        // Handle interpolation
        eon.handleTemplateInterpolation(elementNames[i]);
    }

    return hasPendingImports;

};


// Handle template interpolation
eon.handleTemplateInterpolation = function (name) {
    if (eon.imports.config[name].parse) {
        eon.interpolation.prepare(eon.imports.templates[name]);
    }
};

// Imports specific componentes themes if specified
eon.importSchemaThemes = function () {
  if (eon.themeSchema) {
   
        var themes = Object.keys(eon.themeSchema);
        var documentHead = document.querySelector("head");
        var theme, themeElements, themeLink, themePath;

        // For each theme
        for (var i = 0; i < themes.length; i++) {

            theme = themes[i];
            themeElements = eon.themeSchema[theme];

            // Imports the main theme file
            eon.importMainTheme(theme);

            // Loops through the elements
            for (var j = 0; j < themeElements.length; j++) {

                eon.registry.registerTheme(themeElements[j], theme);
                themePath = eon.basePath + "/theme/" + theme + "/" + themeElements[j].toLowerCase() + ".css";

                themeLink = document.createElement("link");
                themeLink.setAttribute("rel", "stylesheet");
                themeLink.setAttribute("href", themePath);

                // Cache
                eon.cache.add(themePath, { name: themeElements[j].toLowerCase() });

                documentHead.appendChild(themeLink);

            }

        }

    }

};

eon.importMainTheme = function (theme) {

    if (theme && !eon.registry.isThemeRegistered("main", theme)) {

        var documentHead = document.querySelector("head");
        var mainLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/main.css";

        eon.registry.registerTheme("main", theme);

        mainLink.setAttribute("rel", "stylesheet");
        mainLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath);

        documentHead.appendChild(mainLink);

    }

};

eon.importElementTheme = function (config, name, theme) {

    if (theme && config.themed && !eon.registry.isThemeRegistered(name, theme)) {

        var importedDocumentHead = document.querySelector("head");
        var elementLink = document.createElement("link");
        var themePath = eon.basePath + "/theme/" + theme + "/" + name.toLowerCase() + ".css";
        
        eon.registry.registerTheme(name, theme);

        elementLink.setAttribute("rel", "stylesheet");
        elementLink.setAttribute("href", themePath);

        // Cache
        eon.cache.add(themePath, { name: name });

        importedDocumentHead.appendChild(elementLink);

    }
};

eon.handleStyleAppend = function () {

    if (eon.imports.style != "") {

        var combinedStyle = document.createElement("style");

        combinedStyle.setAttribute("data-eon", "element-styles")
        combinedStyle.innerHTML = eon.imports.style;

        // Resets style to avoid css rules style replication
        eon.imports.style = "";

        document.head.appendChild(combinedStyle);

    }

};

eon.handleScriptsAppend = function (elementIndex, scriptIndex) {

    var elementNames = Object.keys(eon.imports.scripts);
    var resume = !isNaN(elementIndex - 1) && !isNaN(scriptIndex - 1) ? true : false;
    var elementScriptsKeys, elementScripts, script;

    // If it has to resume a previous scripts append we start from that index
    for (var i = resume ? elementIndex : 0; i < elementNames.length; i++) {

        elementScripts = eon.imports.scripts[elementNames[i]];
        elementScriptsKeys = Object.keys(elementScripts);

        // If it has to resume a previous scripts append we start from that index
        for (var j = (resume && i == elementIndex) ? scriptIndex : 0; j < elementScriptsKeys.length; j++) {

            resume = false;

            if (elementScripts[elementScriptsKeys[j]].src) {

                // If the script has a src then we import it via require
                eon.amd.require([elementScripts[elementScriptsKeys[j]].src], function () {
                    eon.handleScriptsAppend(i, j + 1);
                });

                // Since we have to wait for the require to resumen our loops we break all the function execution
                return;

            } else {

                // iPad fix, if we tried to append the script saved in elementScripts directly the script was not executing
                script = document.createElement("script");
                script.innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]] = script;

                // // Here we take the current script text and add our code to remove the script once its finished
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML;
                elementScripts[elementScriptsKeys[j]].innerHTML = elementScripts[elementScriptsKeys[j]].innerHTML +
                    "var elementNames = Object.keys(eon.imports.scripts);" +
                    "var elementScripts = eon.imports.scripts[elementNames[" + i + "]];" +
                    "var scriptKey = Object.keys(elementScripts)[" + j + "];" +
                    "elementScripts[scriptKey].parentNode.removeChild(elementScripts[scriptKey]);";

                document.head.appendChild(elementScripts[elementScriptsKeys[j]]);

            }

        }

    }

    // Since we are finished looping all the current element scripts we reset our scripts object to avoid looping through them again in case more elements are being imported after
    eon.imports.scripts = {};

    var scriptsReadyScript = document.createElement("script");

    scriptsReadyScript.setAttribute("scriptsready-script", "");
    scriptsReadyScript.innerHTML = "eon.triggerCallback('onScriptsReady', eon); eon.removeScriptsReadyScripts();";

    document.head.appendChild(scriptsReadyScript);

};

eon.removeScriptsReadyScripts = function () {
    var el = this;
    var scriptReadyScripts = document.head.querySelectorAll("script[scriptsready-script]");

    for (var i = 0; i < scriptReadyScripts.length; i++) {
        scriptReadyScripts[i].parentNode.removeChild(scriptReadyScripts[i]);
    }
};

eon.handleLinksAppend = function () {

    var elementNames = Object.keys(eon.imports.links);
    var elementLinksKeys, elementLinks, link;

    for (var i = 0; i < elementNames.length; i++) {

        elementLinksKeys = Object.keys(eon.imports.links[elementNames[i]]);
        elementLinks = eon.imports.links[elementNames[i]];

        for (var j = 0; j < elementLinksKeys.length; j++) {

            link = elementLinks[elementLinksKeys[j]];

            if (link.getAttribute("data-href")) {

                link.href = eon.imports.paths[elementNames[i]] + link.getAttribute("data-href");
                link.removeAttribute("data-href");

            }

            document.head.appendChild(link);

        }

    }

};

// Handle config dependencies
eon.handleConfigDependencies = function (name) {
    var hasDependencies = false;
    var elementConfig = eon.imports.config[name];
    var dependencyName, dependencyPath, dependencyFile;
    // Loop through dependencies path and import new ones
    if (elementConfig.dependencies) {
        for (var j = 0; j < elementConfig.dependencies.length; j++) {
            dependencyName = elementConfig.dependencies[j].match(/[^\/]*$/g)[0].replace(".html", "").toLowerCase();
            dependencyPath = elementConfig.dependencies[j].charAt(0) == "/" ? eon.basePath + elementConfig.dependencies[j] : elementConfig.dependencies[j];
            if (!(dependencyName in eon.imports.templates)) {
                hasDependencies = true;
                dependencyPath = (dependencyPath.indexOf(".html") > -1) ? dependencyPath : dependencyPath + "/" + dependencyName + ".html";
                dependencyFile = elementConfig.dependencies[j].charAt(0) == "/" ? dependencyPath : eon.imports.paths[name] + dependencyPath;
                
                eon.import(dependencyFile);
            }
        }
    }
    return hasDependencies;
}

// If there are no imports in the document we will trigger onImportsReady event immediately
eon.domReady(function () {
    if (!eon.imports || (eon.imports && eon.imports.total == 0)) {
        eon.triggerCallback("onImportsReady", eon);
    }
});

eon.registry = eon.registry || {};

eon.registry.transformedQueue = [];
eon.registry.renderQueue = [];
eon.registry.bubbleRenderQueue = [];
eon.registry.readyQueue = [];

eon.registry.elementThemes = {};
eon.registry.elementCounters = {};
eon.registry.elementRegistry = {};

eon.registry.elementStatus = {
  declared: [],
  created: [],
  attached: {}, // Object is used to avoid duplication
  imported: [],
  transformed: [],
  rendered: [],
  bubbleRendered: [],
  ready: []
};

// Register eon ready callback
eon.createCallback("onReady", eon, "ready");

// Register element
eon.registry.registerElement = function (el) {
  var name = el.tagName.toLowerCase();
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var uidFull;

  if (!uid) {

    if (!eon.registry.elementCounters[name]) {
      eon.registry.elementCounters[name] = 0;
    }

    // Assign uid
    eon.registry.elementCounters[name]++;
    uid = eon.registry.elementCounters[name];
    el.setAttribute("uid", uid);
    el.uid = uid;

    uidFull = name + "-" + uid;

    // Track element status
    eon.registry.elementRegistry[uidFull] = {
      el: el,
      status: "created"
    };

    // InnerHTML support
  } else if (uid && (!el.uid || !el.getAttribute("uid"))) {
    uidFull = name + "-" + uid;

    // In case it has either the uid property or the attribute but not the other we just set them again
    el.setAttribute("uid", uid);
    el.uid = uid;

    // Updates the reference for the element
    eon.registry.elementRegistry[uidFull].el = el;
  }

  el.eon = true;

  return uidFull;
};

eon.registry.triggerTransformed = function (index) {
  eon.registry.transformedQueue[index].fn.apply(eon.registry.transformedQueue[index].el);
};

eon.registry.addToTransformedQueue = function (el, elementDoc, fn) {
  var script = document.createElement("script");
  var index;

  eon.registry.transformedQueue.push({
    el: el,
    fn: fn
  });

  index = eon.registry.transformedQueue.length - 1;

  script.innerHTML =
    "setTimeout(function(){setTimeout(function(){eon.registry.triggerTransformed(" +
    index +
    ");}, 0);}, 0);";

  eon.registry.transformedQueue[index][script] = script;

  elementDoc.querySelector("head").appendChild(script);
};

eon.registry.addToRenderQueue = function (el, fn) {
  eon.registry.renderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToBubbleRenderQueue = function (el, fn) {
  eon.registry.bubbleRenderQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.addToReadyQueue = function (el, fn) {
  eon.registry.readyQueue.push({
    el: el,
    fn: fn
  });
};

eon.registry.triggerRenders = function () {

  if (Object.keys(eon.registry.elementStatus.attached).length == eon.registry.elementStatus.transformed.length) {
    
    eon.registry.triggerRenderCallbacks();
    eon.registry.triggerBubbleRenderCallbacks();
    eon.registry.triggerReadyCallbacks();

    // Trigger global onReady
    eon.onImportsReady(function () {
      eon.triggerCallback("onReady", eon);
    });

  }

};

eon.registry.triggerRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.renderQueue.slice();
  eon.registry.renderQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerBubbleRenderCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.bubbleRenderQueue.slice();
  eon.registry.bubbleRenderQueue = [];

  // Trigger queue
  for (var i = auxQueue.length - 1; i >= 0; i--) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.triggerReadyCallbacks = function () {
  // Clone queue and clear
  var auxQueue = eon.registry.readyQueue.slice();
  eon.registry.readyQueue = [];

  // Trigger queue
  for (var i = 0; i < auxQueue.length; i++) {
    auxQueue[i].fn.apply(auxQueue[i].el);
  }
};

eon.registry.registerTheme = function (tagName, theme) {
  
  if (!eon.registry.elementThemes[theme]) {
    eon.registry.elementThemes[theme] = {};
  }

  eon.registry.elementThemes[theme][tagName] = true;
};

eon.registry.isThemeRegistered = function (tagName, theme) {
  return !eon.registry.elementThemes[theme]
    ? false
    : eon.registry.elementThemes[theme][tagName];
};

eon.registry.getUidFull = function (el) {
  var uid = el.uid ? el.uid : el.getAttribute("uid");
  var fullUid;

  if (typeof el != "string" && uid) {
    fullUid = el.tagName.toLowerCase() + "-" + uid;
  }

  return fullUid;
};

eon.registry.updateElementStatus = function (el, status) {

  if (status != "parsed") {

    var uidFull = eon.registry.getUidFull(el);

    if (status == "attached") {

      eon.registry.elementStatus[status][uidFull] = el;

      if (eon.registry.elementStatus.ready.length != Object.keys(eon.registry.elementStatus.attached).length) {
        eon["__onReady__triggered"] = false;
      }

    } else if (status != "detached") {

      eon.registry.elementStatus[status].push(el);
      
    }

    if (status != "created" && status != "declared") {
      eon.registry.elementRegistry[uidFull][status] = true;
    }

  }

};

eon.registry.isAttached = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].attached
  );
};

eon.registry.isImported = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].imported
  );
};

eon.registry.isTransformed = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].transformed
  );
};

eon.registry.isRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].rendered
  );
};

eon.registry.isBubbleRendered = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].bubbleRendered
  );
};

eon.registry.isReady = function (el) {
  return (
    eon.registry.elementRegistry[eon.registry.getUidFull(el)] &&
    eon.registry.elementRegistry[eon.registry.getUidFull(el)].ready
  );
};

// Trigger global onReady
eon.onImportsReady(function () {

  if (eon.registry.elementStatus.declared.length == 0) {
    eon.triggerCallback("onReady", eon);
  }

});

eon.interpolation = eon.interpolation || {};
eon.interpolation.tags = ["{{", "}}", "="];

window.data = window.data || {};
window.lang = window.lang || {};

// Replaces all the echo/script for its corresponding elements and prepares them
eon.interpolation.prepare = function (template) {

  // Extend vimlet.meta
  if (!vimlet.meta.sandbox) {
    vimlet.meta.sandbox = {
      "bind": function (keyPath, rootPath, global) {

        global = eon.util.isTrue(global) ? true : false;

        // If rootPath is provided we split it
        rootPath = rootPath && rootPath != "" ? rootPath.split(".") : rootPath;

        // If the first element of the rootPath is either "data" or "global"
        if (rootPath && ((rootPath[0] == "data" && !global) || (rootPath[0] == "global"))) {

          // Removes the data/global from the path
          rootPath.shift();
          // Joins the remaining path
          rootPath = rootPath.join(".");

          keyPath = rootPath != "" ? rootPath + "." + keyPath : keyPath;

        }

        this.echo('<eon-variable bind="' + keyPath + '" global="' + global + '"></eon-variable>');
      }
    };
  }

  if (!vimlet.meta.shortcut) {
    vimlet.meta.shortcut = {
      "@": function (s) {

        // Transforms the string argument into our binding parameters
        var params = s.split(" ");

        var keyPath = params.length > 1 ? params[1] : params[0];
        var rootPath = params.length > 1 ? params[0] : undefined;
        var global = rootPath && rootPath.split(".")[0] == "global" ? true : false;

        keyPath = "\"" + keyPath + "\"";
        rootPath = rootPath ? "\"" + rootPath + "\"" : rootPath;
        params = "[ " + keyPath + ", " + rootPath + ", " + global + "]";

        return "bind.apply(undefined, " + params + ");";
      }
    };
  }


  vimlet.meta.tags = eon.interpolation.tags;
  vimlet.meta.parse(window, template.innerHTML, null, function (result) {
    template.innerHTML = result;
  });

  return template;
};

// Handles all the initial state of the data and variable elements
eon.interpolation.handleInterpolationVariables = function (el, config) {
  var variables = el.template.querySelectorAll("eon-variable");
  var currentVariable;

  var isGlobal, scope, source, sourceType;
  var bindString, bindValue, root;

  var sources = {};

  sources.element = {};
  sources.global = {};

  el.__interpolations = el.__interpolations || {};

  // Loops all the inner element variables
  for (var i = 0; i < variables.length; i++) {

    currentVariable = variables[i];

    // Sets some basic variables to be used later on
    isGlobal = eon.util.isTrue(currentVariable.getAttribute("global"));
    bindString = currentVariable.getAttribute("bind");
    scope = isGlobal ? window : el;
    sourceName = isGlobal && bindString.split(".")[0] == "lang" ? "lang" : "data";

    root = sourceName != "lang" ? scope[sourceName] : scope;

    // Reads if there is already a value on the source if there is not then it assigns an empty string
    bindValue = eon.object.readFromPath(root, bindString);
    bindValue = typeof bindValue == "undefined" ? "" : bindValue;
    
    // Reassigns the value to the source, in case there was no value
    eon.object.assignToPath(root, bindString, bindValue);

    sourceType = isGlobal ? "global" : "element";

    // Creates the source object
    if (!sources[sourceType][sourceName]) {

      sources[sourceType][sourceName] = {};
      sources[sourceType][sourceName].scope = scope;
      sources[sourceType][sourceName].obj = scope[sourceName];
      sources[sourceType][sourceName].isGlobal = isGlobal;
      sources[sourceType][sourceName].isLang = (sourceName == "lang");
      

    }

  }

  var sourceTypeKeys = Object.keys(sources);
  var sourceKeys;

  for (var i = 0; i < sourceTypeKeys.length; i++) {

    sourceKeys = Object.keys(sources[sourceTypeKeys[i]]);

    for (var j = 0; j < sourceKeys.length; j++) {

      source = sources[sourceTypeKeys[i]][sourceKeys[j]];

      eon.interpolation.setupDataChangeCallback(el, source, config);
      eon.interpolation.setupDataPropDescriptors(source, sourceKeys[j]);
      eon.interpolation.interpolate(el, source, source.obj, el.__interpolations);

    }

  }

};

// Creates the descriptor for the data object itself and for all its properties
// eon.interpolation.setupDataPropDescriptors = function (el, config) {
eon.interpolation.setupDataPropDescriptors = function (source, sourceName) {
  
  var scope = source.scope;

  // Defines its own descriptor, in case the whole "data" object changes
  Object.defineProperty(
    scope,
    sourceName,
    eon.interpolation.createPropDescriptor(scope, scope, sourceName, "", scope[sourceName])
  );

  // Loops through all the keys of the object
  eon.interpolation.createObjectPropDescriptors(scope, scope[sourceName], sourceName);
}

// Simple property descriptor creation that in case its changed it will trigger our internal callback
eon.interpolation.createPropDescriptor = function (scope, keyOwnerObj, key, keyPath, value) {
  var propDescriptor = {};

  // Update property value
  keyOwnerObj["__" + key] = value;

  // Redirect get and set to __key
  propDescriptor.get = function () {
    return keyOwnerObj["__" + key];
  };

  propDescriptor.set = function (value) {
    // Trigger onDataChanged
    eon.triggerCallback("_onDataChanged", scope, scope, [keyPath + key, keyOwnerObj["__" + key], value]);

    // Update property value
    keyOwnerObj["__" + key] = value;
  };

  return propDescriptor;
}

// When the property we want to observer is an object we create its descriptor and ones for its properties
eon.interpolation.createObjectPropDescriptors = function (el, obj, keyPath) {
  var value;

  keyPath = keyPath + ".";

  for (var key in obj) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      value = obj[key];

      obj["__" + key] = value;

      Object.defineProperty(
        obj,
        key,
        eon.interpolation.createPropDescriptor(el, obj, key, keyPath, value)
      );

      // If the value is an Object then we update the keyPath and create the propDescriptors
      if (value && value.constructor === Object) {
        keyPath = keyPath + key;
        eon.interpolation.createObjectPropDescriptors(el, value, keyPath);
      }
    }
  }
}

// Creates the private onDataChanged callback to handle the public one
eon.interpolation.setupDataChangeCallback = function (el, source, config) {
  
  var scope = source.scope;

  // If the private callback doesnt exist creates it
  if (!scope._onDataChanged) {

    eon.createCallback("_onDataChanged", scope);

    // When any data changes (incluiding data itself), we manage the onDataChanged triggers depending on the situation
    scope._onDataChanged(function (keyPath, oldVal, newVal) {
      
      if (newVal.constructor === Object) {
        eon.interpolation.handleObjectChange(el, scope, keyPath, oldVal, newVal, config);
      } else {
        eon.interpolation.handleVariableChange(el, keyPath, oldVal, newVal, config);
      }

    });

  }

}

// Takes all the properties from data, finds its variable and sets its value
eon.interpolation.interpolate = function (el, source, obj, interpolations, bind) {
  var key, i, variableBind, variable;

  for (key in obj) {
    // console.log(key, obj);
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object the call ourselfs again to loop through our keys
      if (obj[key] && obj[key].constructor === Object) {

        bind = bind ? bind + "." + key : key;
        interpolations[key] = {};

        eon.interpolation.interpolate(el, source, obj[key], interpolations[key], bind);

      } else {

        variableBind = bind ? bind + "." + key : key;
        variableBind = source.isGlobal && source.isLang ? "lang." + variableBind : variableBind;
        
        // Looks for the variables matching the binding
        interpolations[key] = el.template.querySelectorAll(
          'eon-variable[bind="' + variableBind + '"][global="' + source.isGlobal + '"]'
        );

        // For each variable found previously sets its value
        for (i = 0; i < interpolations[key].length; i++) {
          variable = interpolations[key][i];
          variable.textContent = obj[key];
        }
      }
    }
  }
}

// Handles the situation when a whole object has been changed
eon.interpolation.handleObjectChange = function (el, scope, keyPath, oldData, newData, config) {
  var checked = {};

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [keyPath, oldData, newData]);

  // Checks differences between the old and the new data
  checked = eon.interpolation.backwardDataDiffing(el, scope, keyPath, oldData, newData, checked, config);

  // Checks differences between the new and the old data, escaping the already checked ones
  eon.interpolation.forwardDataDiffing(el, scope, keyPath, newData, checked, config);
  eon.interpolation.createObjectPropDescriptors(scope, newData, keyPath, config);
}

// Handles the value change of the variable element and triggers onDataChanged
eon.interpolation.handleVariableChange = function (el, keyPath, oldVal, newVal, config) {
  var pathArray = keyPath.split(".");
  var interpolationPath;
  var variablesToChange;

  // Removes the first index of the pathArray, that corresponds to "data", which we dont need for the interpolations
  pathArray.shift();
  // Sets the path back together withouth data
  interpolationPath = pathArray.join(".");
  // Takes the variable elements for the path
  variablesToChange = eon.object.readFromPath(el.__interpolations, interpolationPath);

  // If it has variable elements changes its value 
  if (variablesToChange) {
    for (var i = 0; i < variablesToChange.length; i++) {
      variablesToChange[i].textContent = newVal;
    }
  }

  eon.triggerAllCallbackEvents(el, config, "onDataChanged", [interpolationPath, oldVal, newVal]);
}

// Compares the old data with the new one and triggers the changes
eon.interpolation.backwardDataDiffing = function (el, scope, keyPath, oldData, newData, checked, config) {
  var newVal;
  // Loops through the oldData
  for (var key in oldData) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (oldData[key].constructor === Object) {
        checked[key] = eon.interpolation.backwardDataDiffing(el, scope, keyPath + "." + key, oldData[key], newData ? newData[key] : newData, {}, config);
      } else {
        // If there is no such property on the new Data we set it as an empty string
        newVal = newData ? newData[key] : "";
        // Handles the variable change
        eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldData[key], newVal, config);

        if (newData && newData.hasOwnProperty(key)) {
          checked[key] = newData[key];
        }
      }
    }
  }

  return checked;
}

// Compares the data with the already checked object
eon.interpolation.forwardDataDiffing = function (el, scope, keyPath, data, checked, config) {
  var oldVal;
  // Loops through data
  for (var key in data) {
    // We only want take into account the keys that are not used for the descriptor
    if (key.indexOf("__") == -1) {
      // If the property is an object, we enter this function again for that object
      if (data[key].constructor === Object) {
        eon.interpolation.forwardDataDiffing(el, scope, keyPath + "." + key, data[key], checked ? checked[key] : checked, config);
      } else {
        oldVal = checked ? checked[key] : "";
        // To only trigger variable change for properties that are not already checked/triggered
        if ((checked && !checked[key]) || !checked) {
          eon.interpolation.handleVariableChange(el, keyPath + "." + key, oldVal, data[key], config);
        }
      }
    }
  }
}

eon.constructClass = function (baseElement) {
  // Class adpater
  var classAdapter = function () {
    // WARNING! Reflect.construct returned value will fail to return element when browser has native
    // support for webcomponents and webcomponents polyfill is enabled at the same time
    var el;
    // Constructor
    if (window.hasOwnProperty("Reflect")) {
      el = Reflect.construct(baseElement, [], classAdapter); // ES6 Reflect is preferred when available
    } else {
      baseElement.prototype.constructor = classAdapter;
      baseElement.__proto__.constructor = classAdapter;
      el = baseElement.call(classAdapter); // ES alternative
    }
    // Trigger onCreated callback
    eon.triggerCallback("onCreated", classAdapter, el);
    return el;
  };

  // Adapt class prototype and constructor
  Object.setPrototypeOf(classAdapter, baseElement);
  Object.setPrototypeOf(classAdapter.prototype, baseElement.prototype);
  Object.setPrototypeOf(classAdapter.__proto__, baseElement.__proto__);

  // Create callbacks
  eon.createCallback("onCreated", classAdapter);
  eon.createCallback("onAttached", classAdapter);
  eon.createCallback("onDetached", classAdapter);
  eon.createCallback("onAttributeChanged", classAdapter);

  // Trigger callbacks
  classAdapter.prototype.connectedCallback = function () {
    var el = this;
    eon.triggerCallback("onAttached", classAdapter, el);
  };
  classAdapter.prototype.disconnectedCallback = function () {
    var el = this;
    eon.triggerCallback("onDetached", classAdapter, el);
  };
  classAdapter.prototype.attributeChangedCallback = function (
    attrName,
    oldVal,
    newVal
  ) {
    var el = this;
    el["__" + eon.util.hyphenToCamelCase(attrName)] = newVal;
    eon.triggerCallback("onAttributeChanged", classAdapter, el, [
      attrName,
      oldVal,
      newVal
    ]);
  };
  // TODO future callback implementation
  // classAdapter.prototype.adoptedCallback = function() {
  //
  // };
  return classAdapter;
};

eon.element = function (param1, param2) {

    var config, stylePath, name;

    if (param2) {

        config = param2.config ? param2.config : param2.constructor === Object ? param2 : {};
        name = param1;

    } else {

        config = param1.config ? param1.config : param1.constructor === Object ? param1 : {};
        name = config.name ? config.name : param1;

    }

    stylePath = config.style ? config.style : "";

    // If the user provided a style path then we create its link and append it
    if (stylePath != "" ) {
        var link = document.createElement("link");

        stylePath = eon.imports.paths[name.toLowerCase()] + stylePath;

        link.setAttribute("rel", "stylesheet");
        link.setAttribute("href", stylePath);

        // Cache
        eon.cache.add(stylePath, { name: name });

        document.head.appendChild(link);

    }

    eon.imports.config[name.toLowerCase()] = config;
    eon.triggerCallback('onScriptsReady', eon);

};

eon.define = function (config) {
    eon.amd.define(function () {
        return config;
    });
};

eon.createElement = function (name, config) {

    var el = document.createElement(name);

    if (config) {

        var callbacks = ["onCreated", "onInit", "onTransformed", "onRender", "onBubbleRender", "onReady"];

        for (var i = 0; i < callbacks.length; i++) {
            if (config[callbacks[i]]) {
                el[callbacks[i]](config[callbacks[i]]);
            }
        }

        if (config.functions) {

            var functions = Object.keys(config.functions);

            for (var j = 0; j < functions.length; j++) {
                el[functions[j]] = config.functions[functions[j]];
            }

        }

        if (config.properties) {

            var properties = Object.keys(config.properties);

            for (var k = 0; k < properties.length; k++) {
                el[properties[k]] = config.properties[properties[k]];
            }

        }

    }

    return el;

};

eon.hideElement = function (el) {
    el.classList.add("eon-until-rendered");
};

eon.unhideElement = function (el) {
    el.classList.remove("eon-until-rendered");
};

eon.declareCallbacks = function (el) {
    // Creates the callback needed for the element
    eon.createCallback("onCreated", el, "ready");
    eon.createCallback("onInit", el, "ready");
    eon.createCallback("onTransformed", el, "ready");
    eon.createCallback("onRender", el, "ready");
    eon.createCallback("onBubbleRender", el, "ready");
    eon.createCallback("onReady", el, "ready");
    eon.createCallback("onPropertyChanged", el);
    eon.createCallback("onAttributeChanged", el);
    eon.createCallback("onDataChanged", el);
};

eon.generateSourceFragment = function (el) {

    el.source = document.createDocumentFragment();

    if (el.childNodes.length == 0) {
        // Chrome only
        var observer = new MutationObserver(function (mutations) {

            mutations.forEach(function (mutation) {

                for (var i = 0; i < mutation.addedNodes.length; i++) {
                    el.source.appendChild(mutation.addedNodes[i]);
                }

            });

        });

        // Start observing
        observer.observe(el, {
            attributes: false,
            childList: true,
            characterData: false
        });

        el.__onCreatedObserver = observer;

    } else {

        // Move child to source fragment
        while (el.childNodes.length > 0) {
            el.source.appendChild(el.childNodes[0]);
        }

    }

};

eon.prepareElement = function (el, callback) {

    // Mark element as first attach
    el.isFirstAttach = true;

    // Runs the callback provided when all imports are ready
    eon.onImportsReady(function () {
        callback();
    });

};

eon.parse = function (el, config) {
    // Creates object properties for the element with data about the properties/attributes to be observed
    eon.collectObserveData(el, config);

    // Imports Data and Public/Private properties and functions
    eon.importData(el, config);
    eon.importPublic(el, config);
    eon.importPrivate(el, config);

    eon.definePath(el);
    eon.defineParentComponent(el);
    eon.defineOverlayCreation(el);
    eon.definePlaceholderCreation(el);

    eon.triggerAllCallbackEvents(el, config, "onParsed");
    eon.registry.updateElementStatus(el, "parsed");

};

eon.definePath = function (el) {
    el.importPath = eon.imports.paths[el.nodeName.toLowerCase()];
};

eon.defineParentComponent = function (el) {

    var propDescriptor = {};

    propDescriptor.get = function () {
        el.__parentComponent = el.__parentComponent ? el.__parentComponent : eon.getEnclosingComponent(el);
        return el.__parentComponent;
    };

    propDescriptor.set = function () { };

    Object.defineProperty(el, "parentComponent", propDescriptor);

};

eon.defineOverlayCreation = function (el) {

    // Defines the function for the element
    el.generateOverlayNode = function (overlay) {

        // If an overlay is provided we will prepare that one, otherwise we just create a new one
        overlay = overlay ? overlay : document.createElement("eon-overlay");

        // The properties assignation takes place in the onRender callback since if we assign a theme to the overlay
        // it will search a theme file for the overlay, and we just want to assign a theme so that the overlay can recieve
        // the main theme classes
        overlay.onRender(function () {

            // Assigns properties for the overlay
            overlay.owner = el;
            overlay.type = el.nodeName.toLowerCase();
            overlay.ownerId = eon.registry.getUidFull(el);

            if (el.hasAttribute("theme")) {
                overlay.setAttribute("theme", el.getAttribute("theme"));
            }

        })

        return overlay;

    };

};
eon.definePlaceholderCreation = function (el) {

    // Defines the function for the element
    el.generatePlaceholderNode = function (placeholder) {

        // If a placeholder is provided we will prepare that one, otherwise we just create a new one
        placeholder = placeholder ? placeholder : document.createElement("eon-placeholder");

        // The properties assignation takes place in the onRender callback since we want to make sure the owner has an uid for the ownerId property
        placeholder.onRender(function () {

            // Assigns properties for the overlay
            placeholder.owner = el;
            placeholder.type = el.nodeName.toLowerCase();
            placeholder.ownerId = eon.registry.getUidFull(el);

        })

        return placeholder;

    };

};

eon.collectObserveData = function (el, config) {

    el.__observeProperties = {};
    el.__observeAttributes = {};
    el.__reflectProperties = {};
    
    // Assigns each index of the array to the object
    eon.addObserveFromArray(el.__observeProperties, config.observeProperties);
    eon.addObserveFromArray(el.__observeAttributes, config.observeAttributes);

    // Reads properties object to add them to the observe object if needed
    if (config.properties) {

        var propertiesKeys = Object.keys(config.properties);

        for (i = 0; i < propertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.properties[propertiesKeys[i]].observe) {
                el.__observeProperties[propertiesKeys[i]] = true;
            }

            // If the property has reflect active but it has no value we set an empty string
            if (config.properties[propertiesKeys[i]].reflect && !config.properties[propertiesKeys[i]].hasOwnProperty("value")) {
                config.properties[propertiesKeys[i]].value = "";
            }

            // If the property has reflect but its value is of type object we set reflect to false
            if (config.properties[propertiesKeys[i]].reflect && typeof config.properties[propertiesKeys[i]].value == "object") {
                config.properties[propertiesKeys[i]].reflect = false;
            }

            // Add reflect to observeAttributes
            if (config.properties[propertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(propertiesKeys[i])] = true;
                el.__reflectProperties[propertiesKeys[i]] = true;
            }
        }
    }

    // Reads private properties object to add them to the observe object if needed
    if (config.privateProperties) {

        var privatePropertiesKeys = Object.keys(config.privateProperties);

        for (i = 0; i < privatePropertiesKeys.length; i++) {
            // Add observe to observeProperties
            if (config.privateProperties[privatePropertiesKeys[i]].observe) {
                el.__observeProperties["_" + privatePropertiesKeys[i]] = true;
            }

            // Add reflect to observeAttributes
            if (config.privateProperties[privatePropertiesKeys[i]].reflect) {
                el.__observeAttributes[eon.util.camelToHyphenCase(privatePropertiesKeys[i])] = true;
                el.__reflectProperties["_" + privatePropertiesKeys[i]] = true;
            }
        }
    }

};

eon.addObserveFromArray = function (observeObj, observeArray) {

    observeArray = observeArray ? observeArray : [];

    for (var i = 0; i < observeArray.length; i++) {
        observeObj[observeArray[i]] = true;
    }

};

eon.createAttributesObserver = function (el, config) {

    var observeAttributesKeys = Object.keys(el.__observeAttributes);

    // First we check if we have attributes to observe
    if (observeAttributesKeys.length > 0) {

        var property, privateProperty, value;

        // For each observe attribute if check which value should be assign to it
        for (var i = 0; i < observeAttributesKeys.length; i++) {

            property = eon.util.hyphenToCamelCase(observeAttributesKeys[i]);
            privateProperty = "__" + property;

            // If the attribute already has a value we assign this value to its corresponding property
            if (el.getAttribute(observeAttributesKeys[i])) {

                el[privateProperty] = el.getAttribute(observeAttributesKeys[i]);

                // If the attribute has no value we check if the property has it, if not we assign it an empty value
            } else {

                if (config.properties[property].reflectDefault) {

                    value = el.hasOwnProperty(privateProperty) ? el[privateProperty] : "";

                    // Only sets the attribute if the value is not of object type
                    if (typeof value != "object") {
                        el.setAttribute(observeAttributesKeys[i], value);
                    } else {
                        el.removeAttribute(observeAttributesKeys[i]);
                    }

                }

            }

        }

        // Here we override the setAttribute function for our element, to also call another callback when the user sets an attribute
        (function (proxied) {
            el.setAttribute = function () {
                setAttributeCallback(arguments[0], el.getAttribute(arguments[0]), arguments[1]);
                return proxied.apply(this, arguments);
            };
        })(el.setAttribute);

        // Callback to be triggered when the user calls to setAttribute
        var setAttributeCallback = function (attrName, oldVal, newVal) {

            var property = eon.util.hyphenToCamelCase(attrName);

            // The onAttributeChanged callback is triggered whether its observed or as a reflection of a property
            if (el.__observeAttributes[attrName] || el.__reflectProperties[property]) {
                eon.triggerAllCallbackEvents(el, config, "onAttributeChanged", [attrName, oldVal, newVal]);
            }

            // The onPropertyChanged callback is triggered when the attribute has changed and its reflect by a property
            if (el.__reflectProperties[property]) {
                el["__" + property] = newVal;
                eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [property, oldVal, newVal]);
            }

        };

    }

};

eon.handleProperty = function (el, config, reflectProperties, observeProperties, property) {

    var key = property.key;
    var value = property.value;

    var observe = observeProperties[key];
    var reflect = reflectProperties[key];

    // Complex property
    if (typeof value === "object" && value.hasOwnProperty("value")) {
        if (typeof value.value === "object") {
            value = Object.assign({}, value.value);
        } else {
            value = value.value;
        }
    }

    // Define property value before to avoid setting attributes onCreated if reflect
    el[key] = value;

    if (observe || reflect) {
        // Define property descriptor with custom get and set
        Object.defineProperty(
            el,
            key,
            eon.createPropDescriptor(el, config, key, value, reflect)
        );
        el["__" + key] = value;
    }
};

eon.createPropDescriptor = function (el, config, key, value, reflect) {
    var propDescriptor = {};
    // Redirect get and set to __key
    propDescriptor.get = function () {
        return el["__" + key];
    };

    propDescriptor.set = function (value) {
        if (reflect) {
            // Trigger onAttributeChanged, note this will trigger also onPropertyChanged if needed
            // Only sets the attribute if the value is not of object type
            if (typeof value != "object") {
                el.setAttribute(eon.util.camelToHyphenCase(key), value);
            } else {
                el.removeAttribute(eon.util.camelToHyphenCase(key));
            }

        } else {
            // Trigger onPropertyChanged
            eon.triggerAllCallbackEvents(el, config, "onPropertyChanged", [
                key,
                el["__" + key],
                value
            ]);
        }

        // Update property value
        el["__" + key] = value;
    };

    return propDescriptor;
};

eon.importData = function (el, config) {

    el.data = {};

    if (config.data) {
        el.data = config.data;
    }

}

eon.importPublic = function (el, config) {

    if (config.properties) {
        var keys = Object.keys(config.properties);
        var attributeKey;

        for (var i = 0; i < keys.length; i++) {
            attributeKey = eon.util.camelToHyphenCase(keys[i]);
            // If the element has one of the reflected attributes we send that value as the value of the property
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: keys[i],
                value: el.hasAttribute(attributeKey) ? el.getAttribute(attributeKey) : config.properties[keys[i]]
            });
        }
    }

    if (config.functions) {
        var keys = Object.keys(config.functions);

        for (var i = 0; i < keys.length; i++) {
            el[keys[i]] = config.functions[keys[i]];
        }
    }

};

eon.importPrivate = function (el, config) {

    if (config.privateProperties) {
        var keys = Object.keys(config.privateProperties);

        for (var i = 0; i < keys.length; i++) {
            eon.handleProperty(el, config, el.__reflectProperties, el.__observeProperties, {
                key: "_" + keys[i],
                value: config.privateProperties[keys[i]]
            });
        }
    }

    if (config.privateFunctions) {
        var keys = Object.keys(config.privateFunctions);

        for (var i = 0; i < keys.length; i++) {
            el["_" + keys[i]] = config.privateFunctions[keys[i]];
        }
    }

};

eon.importTemplateClasses = function (el) {

    var template = eon.imports.templates[el.tagName.toLowerCase()];

    if (template && template.classList.length != 0) {

        var elClassesArray = Array.prototype.slice.call(el.classList);
        var templateClassesArray = Array.prototype.slice.call(template.classList);

        elClassesArray = templateClassesArray.concat(elClassesArray);

        el.setAttribute("class", elClassesArray.join(" "));

    }


};

eon.triggerAllCallbackEvents = function (el, config, callback, params) {

    eon.debug.log("triggerAllCallbackEvents", callback);

    // This "if" is created for the porpuse of not allowing onPropertyChanged and onAttributeChanged
    // to be triggered once the element is render, this is so we dont have to use el.onRender() inside this callback to not crash
    if (!((callback == "onPropertyChanged" || callback == "onAttributeChanged") && eon.registry.isRendered(el) != true)) {

        if (config[callback]) {
            config[callback].apply(el, params);
        }

        eon.debug.log("elementEvents", callback);
        eon.triggerCallback(callback, el, el, params);

    }

};

eon.transform = function (el, config) {

    if (!eon.registry.isTransformed(el)) {

        // Gets the theme that will be used for this element, if it has none we set a default theme and return it
        // We pass the config so that if the element has themed: "false" but the element has a theme specified by the user it turns it into "true"
        var theme = eon.getElementTheme(el, config);
        var name = el.nodeName.toLowerCase();

        // Imports the template of the element
        eon.appendElementTemplate(el);

        // Registers the main theme of this theme if its not yet registered
        eon.importMainTheme(theme);

        // If the element has not yet registered its theme it will proceed on importing it
        eon.importElementTheme(config, name, theme);

        // Adds the element to the transformQueue
        setTimeout(function () {
            eon.triggerTransformed(el, config);
        }, 0);

    }

};

eon.getElementTheme = function (el, config) {

    var userSpecifiedTheme = el.hasAttribute("theme") || el.theme ? true : false;
    var theme = eon.theme;

    theme = document.body.dataset.theme ? document.body.dataset.theme : theme;
    theme = document.body.hasAttribute("theme") ? document.body.getAttribute("theme") : theme;
    theme = el.hasAttribute("theme") ? el.getAttribute("theme") : theme;
    theme = el.theme ? el.theme : theme;

    // If the user has specified a theme but the element is not themeable then we turn themed: "true" so
    // that it can now import a theme
    config.themed = userSpecifiedTheme && !config.themed ? true : config.themed;

    // Whether it has the attribute or not, we set it
    el.setAttribute("theme", theme);

    return theme;
}

eon.slot = function (el) {

    var sourceNodes = el.getSourceNodes();
    var slotAttribute;
    var node;
    var slottedArray = [];

    // Initiates the slots object
    el._slots = {};

    for (var i = 0; i < sourceNodes.length; i++) {

        node = sourceNodes[i];

        // If the node can have attributes then we get/remove the slot one
        if (node.getAttribute) {
            slotAttribute = node.getAttribute("slot");
            node.removeAttribute("slot");
        }

        // If it hasn't been already slotted
        if (!node.__slotted) {

            // For each source node we check if it has a slot attribute and append it to its corresponding slot
            if (slotAttribute) {

                // If we have already queried this slot we just access it through the object, otherwise we call the querySelector and save its result
                el._slots[slotAttribute] = el._slots[slotAttribute] ? el._slots[slotAttribute] : el.template.querySelector(slotAttribute);

                if (el._slots[slotAttribute]) {

                    el._slots[slotAttribute].appendChild(node);
                    node.__slotted = true;

                    slottedArray.push(i);

                } else {

                    el.template.appendChild(node);

                }

            } else {

                // if it has no slot its appended to the template root.
                if (node.parentNode.isEqualNode(el.source)) {
                    el.template.appendChild(node);
                }

            }

        }

    }

};

eon.fragmentFromString = function (str) {
    // Test createContextualFragment support
    if (!("__supportsContextualFragment" in eon)) {
        try {
            document.createRange().createContextualFragment("test");
            eon.__supportsContextualFragment = true;
        } catch (error) {
            eon.__supportsContextualFragment = false;
        }
    }
    if (eon.__supportsContextualFragment) {
        return document.createRange().createContextualFragment(str);
    } else {
        var temp = document.createElement("template");
        temp.innerHTML = str;
        return temp.content;
    }
};

eon.generateElementTemplate = function (el) {
    var name = el.nodeName.toLowerCase();
    var template = eon.imports.templates[name];
    var clone = document.createElement("template");

    // All the content related checks are made to improve compatibility with browsers that do not support template
    clone.content = document.createDocumentFragment();

    if (template) {

        if (!template.content) {
            template.content = eon.fragmentFromString(template.innerHTML);
        }

        clone = template.cloneNode(true);

        if (!clone.content) {
            clone.content = eon.fragmentFromString(clone.innerHTML);
        }

    }

    el.template = clone.content;
};

eon.appendElementTemplate = function (el) {
    el.appendChild(el.template);
    delete el.template;
};

eon.initSourceCallbacks = function (el) {
    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return Array.prototype.slice.call(el.source.childNodes);
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {
        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];
        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

};

eon.updateSourceCallbacks = function (el) {

    var sourceNodes = el.source.childNodes;

    sourceNodes = !sourceNodes[0] ? el.childNodes : sourceNodes;
    sourceNodes = Array.prototype.slice.call(sourceNodes);

    // Creates the getSourceElements function even if it has no source elements
    el.getSourceNodes = function () {
        return sourceNodes;
    }

    // Creates the getSourceNodes function even if it has no source nodes
    el.getSourceElements = function () {

        var sourceNodes = el.getSourceNodes();
        var sourceElements = [];

        for (var i = 0; i < sourceNodes.length; i++) {
            // NodeType 1 means its an Html element
            if (sourceNodes[i].nodeType == 1) {
                sourceElements.push(sourceNodes[i]);
            }

        }

        return Array.prototype.slice.call(sourceElements);
    }

}

eon.triggerTransformed = function (el, config) {

    eon.domReady(function () {

        // Triggered when it has imported the template, it doesnt care of the state
        // of the other elements
        eon.registry.updateElementStatus(el, "transformed");
        eon.triggerAllCallbackEvents(el, config, "onTransformed");

        // Triggered when all registered elements are transformed,
        // the execution is descendant, parent -> child
        eon.registry.addToRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onRender");
            eon.registry.updateElementStatus(el, "rendered");
        });

        // Triggered when all registered elements are transformed,
        // the execution is ascendant, parent <- child
        eon.registry.addToBubbleRenderQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onBubbleRender");
            eon.registry.updateElementStatus(el, "bubbleRendered");
        });

        // This callback is meant only for the users,
        // so that they can hook when the component finished rendering
        eon.registry.addToReadyQueue(el, function () {
            eon.triggerAllCallbackEvents(el, config, "onReady");
            eon.registry.updateElementStatus(el, "ready");
        });

        // Timeout forces triggerRender to wait child onTransformed
        // When render and bubbleRender are finished, it triggers onReady
        setTimeout(function () {
            eon.registry.triggerRenders();
        }, 0);

    });

};

eon.initializeDisplay = function (el, config) {

    var name = el.nodeName.toLowerCase();
    var display = config.display ? config.display : "block";
    var ruleIndex;

    if (!eon.rules[name]) {

        ruleIndex = eon.style.sheet.insertRule(name + " { display: " + display + "; }", 0);
        eon.rules[name] = eon.style.sheet.cssRules[ruleIndex];

    }

    // Remove opacity 0 rule
    el.onBubbleRender(function () {
        eon.unhideElement(this);
    });

};

eon.registerResizeListeners = function (el, config) {

    // If it has onResize callback on its config we create the onResize callback
    if (config.onResize) {

        el.onReady(function () {

            eon.createCallback("onResize", el);

            eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                eon.triggerAllCallbackEvents(el, config, "onResize", []);
            });

        });

    } else {

        // Else all eon elements will have this pseudo onResize callback, this callback will create
        // the real resize callback once its called for the first time
        el.onResize = function (callback) {
            // Once the pseudo callback has been called we set it to null so that it can create the real one
            el.onResize = null;

            eon.createCallback("onResize", el);

            // Once the element is ready, it will add the listener
            el.onReady(function () {

                eon.addResizeListener(el, el.nodeName.toLowerCase(), function () {
                    eon.triggerAllCallbackEvents(el, config, "onResize", []);
                });

                el.onResize(callback);

            });

        }

    }

    // Once the element is ready, it will add the listener
    el.onReady(function () {

        eon.createCallback("onWindowResize", el);

        eon.onResize(function () {
            eon.triggerAllCallbackEvents(el, config, "onWindowResize", []);
        }, el);

    });

};
eon.declare = function (name, baseElement) {

    // Specifies HTML element interface
    var baseElement = baseElement ? baseElement : HTMLElement;

    // Constructs the element class
    var elementClass = eon.constructClass(baseElement);

    // Element constructor: Important! never modify element attributes or children here
    elementClass.onCreated(function () {

        var el = this;
        
        eon.declareCallbacks(el);

        eon.generateSourceFragment(el);

        eon.initSourceCallbacks(el); 

        eon.prepareElement(el, function () {
            
            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // Adds eon element default config properties and functions 
            eon.parse(el, config);

            // Generates an instance of the element template and assigns it as a property of the element so we can easily access from anywhere
            eon.generateElementTemplate(el);

            // Sets a css rule with the provided display by the config, if no display is provided it will have display block by default
            eon.initializeDisplay(el, config);
            
            eon.triggerAllCallbackEvents(el, config, "onCreated");
            eon.registry.updateElementStatus(el, "created");
            
        });
        
        eon.registry.updateElementStatus(el, "declared");

    });

    elementClass.onAttached(function () {

        var el = this;

        el.onCreated(function () {

            var config = eon.imports.config[el.nodeName.toLowerCase()];

            // TODO: should also provide attribute check
            if (el.isFirstAttach) {
                
                el.isFirstAttach = false;

                eon.importTemplateClasses(el);

                eon.hideElement(el);

                // If it has an observer for the declaration of the element we disconnect it as we will no longer need it
                if (el.__onCreatedObserver) {
                    el.__onCreatedObserver.disconnect();
                }

                // Registers the element and generates uid
                eon.registry.registerElement(el);

                eon.createAttributesObserver(el, config);

                // Updates the references for the source nodes
                eon.updateSourceCallbacks(el);
                
                // Moves source-template elements to eon-template-clone elements by slot attribute query selector string
                // Unslotted source-template elements will be appended to eon-clone root
                // Note dynamic things that should be slotted must be added onCreated
                eon.slot(el);

                // Callback for the first time that the element has been attached, no template imported, only created and parsed
                eon.triggerAllCallbackEvents(el, config, "onInit");

                // Interpolation data bind
                eon.interpolation.handleInterpolationVariables(el, config);

                // Creates the on resize callbacks handler for the element
                eon.registerResizeListeners(el, config);

                // Begins the transformation process
                eon.transform(el, config);

            }

            eon.triggerAllCallbackEvents(el, config, "onAttached");

            eon.registry.updateElementStatus(el, "attached");
            eon.debug.log("adapterEvents", "onAttached");

        });

    });

    elementClass.onDetached(function () {
        this.__parentComponent = null;
    });

    elementClass.onAttributeChanged(function (attrName, oldVal, newVal) {

    });

    customElements.define(name, elementClass);

};

eon.createPropertyObserver = function (property, obj, callback, pollingRate) {
  if (typeof pollingRate == "undefined") {
    pollingRate = 300;
  }
  obj.propertyObservers = obj.propertyObservers || {};
  var startObserver = false;
  if (!obj.propertyObservers[property]) {
    obj.propertyObservers[property] = {
      value: obj[property],
      callbacks: [],
      observer: null
    };
    startObserver = true;
  }
  // Add new callback to callbacks array
  obj.propertyObservers[property].callbacks.push(callback);
  // Start observing if needed
  if (startObserver) {
    var args;
    obj.propertyObservers[property].observer = setInterval(function () {
      if (obj.propertyObservers[property].value != obj[property]) {
        //  De-reference oldValue if its type is object
        if (typeof obj.propertyObservers[property].value == "object") {
          args = [
            property,
            Object.assign({}, obj.propertyObservers[property].value),
            obj[property]
          ];
        } else {
          args = [
            property,
            obj.propertyObservers[property].value,
            obj[property]
          ];
        }
        // Update stored value
        obj.propertyObservers[property].value = obj[property];
        // Trigger callback with scope and args
        for (
          var i = 0;
          i < obj.propertyObservers[property].callbacks.length;
          i++
        ) {
          obj.propertyObservers[property].callbacks[i].apply(obj, args);
        }
      }
    }, pollingRate);
  }
};

eon.removePropertyObserver = function (property, obj) {
  if (obj.propertyObservers && obj.propertyObservers[property]) {
    // Clear interval
    window.clearInterval(obj.propertyObservers[property].observer);
    // Delete propertyObservers. property
    delete obj.propertyObservers[property];
  }
};



eon.time = eon.time || {};

eon.time.isLeapYear = function (year) {
  return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
};

eon.time.getDaysInMonth = function (year, month) {
  return [31, eon.time.isLeapYear(parseInt(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][parseInt(month)];
};

eon.time.getMonthNames = function (locale, format) {
  var monthNames = [];
  format = format ? format : "long";
  for (var i = 0; i <= 11; i++) {
    monthNames.push(eon.time.getMonthName(locale, i, format));
  }
  return monthNames;
};

eon.time.getMonthName = function (locale, month, format) {
  var dummyDate = new Date(2000, month, 15);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, { month: format });
};

eon.time.getWeekDays = function (locale, format) {
  var dayNames = [];
  var dummyDate;
  format = format ? format : "long";
  for (var i = 1; i <= 7; i++) {
    dummyDate = new Date(2000, 4, i);
    dayNames.push(dummyDate.toLocaleString(locale, { weekday: format }));
  }
  return dayNames;
};

eon.time.getWeekDay = function (year, month, day) {
  return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][new Date(year, month, day).getDay()];
};

eon.time.getFirstWeekDay = function (locale, year, month, format) {
  var dummyDate = new Date(year, month, 1);
  format = format ? format : "long";
  return dummyDate.toLocaleString(locale, {
    weekday: format
  });
};

eon.time.getFirstWeekMonday = function (locale, year, month, format) {
  var monDay, monthDays;
  var firstWeekDay = eon.time.getFirstWeekDay(locale, year, month, format);
  var weekPosition = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"].indexOf(firstWeekDay);
  // Check first month reached
  if (month == 0) {
    month = 11;
    year--;
  } else {
    month--;
  }
  // Get previous month days
  monthDays = eon.time.getDaysInMonth(year, month);
  monDay = (monthDays + 1) - weekPosition;
  return monDay;
};

eon.time.getDateWithFormat = function (date, format, locale) {
  var dayFormat = format.match(/[d|D]{1,2}/)
    ? format.match(/[d|D]{1,2}/)[0]
    : undefined;
  var monthFormat = format.match(/[M]{1,4}/)
    ? format.match(/[M]{1,4}/)[0]
    : undefined;
  var yearFormat = format.match(/[y|Y]{2,4}/)
    ? format.match(/[y|Y]{2,4}/)[0]
    : undefined;
  var dayType, monthType, yearType, dayString, monthString, yearString;
  if (yearFormat) {
    yearType = yearFormat.length > 1 ? "numeric" : "2-digit";
    yearString = formatedMonth = date.toLocaleString([locale], {
      year: yearType
    });
    format = format.replace(yearFormat, yearString);
  }
  if (dayFormat) {
    dayType = dayFormat.length > 1 ? "2-digit" : "numeric";
    dayString = formatedMonth = date.toLocaleString([locale], {
      day: dayType
    });
    format = format.replace(dayFormat, dayString);
  }
  if (monthFormat) {
    switch (monthFormat.length) {
      case 1:
        monthType = "numeric";
        break;
      case 3:
        monthType = "short";
        break;
      case 4:
        monthType = "long";
        break;
      default:
        monthType = "2-digit";
    }
    monthString = formatedMonth = date.toLocaleString([locale], {
      month: monthType
    });
    format = format.replace(monthFormat, monthString);
  }
  return format;
};

eon.time.getFormatSeparator = function (format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  format = format.replace(dayFormat, "");
  format = format.replace(monthFormat, "");
  format = format.replace(yearFormat, "");

  return format[0];

};

eon.time.getDateObjectFromString = function (value, format) {

  var el = this;

  var separator = eon.time.getFormatSeparator(format);

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var splittedValue = value.split(separator);
  var splittedFormat = format.split(separator);

  var dayIndex = splittedFormat.indexOf(dayFormat);
  var monthIndex = splittedFormat.indexOf(monthFormat);
  var yearIndex = splittedFormat.indexOf(yearFormat);

  return { day: splittedValue[dayIndex], month: splittedValue[monthIndex], year: splittedValue[yearIndex] };

};

eon.time.generateOutput = function (dateObj, format) {

  var dayFormat = (format.match(/[d|D]{1,2}/)) ? format.match(/[d|D]{1,2}/)[0] : undefined;
  var monthFormat = (format.match(/[M]{1,4}/)) ? format.match(/[M]{1,4}/)[0] : undefined;
  var yearFormat = (format.match(/[y|Y]{2,4}/)) ? format.match(/[y|Y]{2,4}/)[0] : undefined;

  var formatFn = function (text, format) {

    text = text ? text + "" : "";

    if (text.length > 0 && text.length < format.length) {
      for (var i = 0; i < (format.length - text.length); i++) {
        text = "0" + text;
      }
    }

    return text;

  };

  if (dateObj.day) {

    var day = formatFn(dateObj.day, dayFormat);
    format = format.replace(dayFormat, day);

  }

  if (dateObj.month) {

    var month = formatFn(dateObj.month, monthFormat);
    format = format.replace(monthFormat, month);

  }

  if (dateObj.year) {

    var year = formatFn(dateObj.year, yearFormat);
    format = format.replace(yearFormat, year);

  }

  return format;

};

eon.time.defaultLocale = {

  months: {

    long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]

  },

  weekdays: {

    long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    min: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]

  }

};


// Creates a namespace for requirejs
eon.resize = eon.resize || {};

(function () {
  
  /*!
 * ResizeListener
 * Detect when HTML elements change in size
 * https://github.com/ShimShamSam/ResizeListener
 *
 * Copyright 2016 Samuel Hodge
 * Released under the GPL license
 * http://www.gnu.org/copyleft/gpl.html
 */
(function scope(root) {
	'use strict';

	var name        = 'ResizeListener';
	var _private    = typeof Symbol === 'function' ? Symbol(name) : '__' + name +'__';
	var tag_name    = name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '-element';
	var massive     = 999999;
	var dirty_frame = null;
	var dirty       = [];

	var requestAnimationFrame =
		window.requestAnimationFrame ||
		window.mozRequestAnimationFrame ||
		window.webkitRequestAnimationFrame ||
		function requestAnimationFrame(callback) {
			return window.setTimeout(callback, 16);
		};

	// Sensor template setup
	var sensor_template = document.createElement(tag_name);
	var sizer_template  = sensor_template.cloneNode(true);
	var shared_css      = 'position:absolute;top:0;left:0;z-index:-' + massive + ';visibility:hidden;overflow:hidden;';

	sensor_template.style.cssText = shared_css + 'width:100%;height:100%';
	sizer_template.style.cssText  = shared_css + 'width:' + massive + 'px;height:' + massive + 'px';

	var expand_sensor = sensor_template.cloneNode(true);
	var shrink_sensor = sensor_template.cloneNode(true);
	var expand_sizer  = sizer_template.cloneNode(true);
	var shrink_sizer  = sizer_template.cloneNode(true);

	shrink_sizer.style.width = shrink_sizer.style.height = '200%';

	sensor_template.appendChild(expand_sensor);
	sensor_template.appendChild(shrink_sensor);
	expand_sensor.appendChild(expand_sizer);
	shrink_sensor.appendChild(shrink_sizer);

	// API export
	var api = {
		add : function add(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					addResizeListener(elements[i], callbacks[j]);
				}
			}
		},

		remove : function remove(elements, callbacks) {
			elements  = wrapInArray(elements);
			callbacks = wrapInArray(callbacks);

			for(var i = 0; i < elements.length; ++i) {
				for(var j = 0; j < callbacks.length; ++j) {
					removeResizeListener(elements[i], callbacks[j]);
				}
			}
		}
	};

	if(typeof define === 'function' && define.amd) {
		define(api);
	}
	else if(typeof exports === 'object') {
		module.exports = api;
	}
	else {
		root[name] = api;
	}

	/**
	 * Attaches a resize callback to an element
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function addResizeListener(element, callback) {
		var listener = getListener(element);

		if(listener) {
			listener.callbacks.push(callback);

			return;
		}

		var sensor        = sensor_template.cloneNode(true);
		var expand_sensor = sensor.childNodes[0];
		var shrink_sensor = sensor.childNodes[1];

		// Convert the element to relative positioning if it's currently static
		var position =
			element.currentStyle    ? element.currentStyle.position :
			window.getComputedStyle ? window.getComputedStyle(element, null).getPropertyValue('position') :
			element.style.position;

		if(position === 'static') {
			element.style.position = 'relative';
		}

		element.appendChild(sensor);

		sensor[_private]        =
		expand_sensor[_private] =
		shrink_sensor[_private] = {
			sensor        : sensor,
			expand_sensor : expand_sensor,
			shrink_sensor : shrink_sensor,
			last_width    : element.offsetWidth,
			last_height   : element.offsetHeight,
			callbacks     : [callback],
			dirty         : false
		};

		expand_sensor.scrollLeft =
		expand_sensor.scrollTop  =
		shrink_sensor.scrollLeft =
		shrink_sensor.scrollTop  = massive;

		expand_sensor.onscroll =
		shrink_sensor.onscroll = scrollHandler;
	}

	/**
	 * Removes a resize callback from an element
	 * If no callback is defined, all callbacks are removed
	 * @param {HTMLElement} element
	 * @param {Function}    callback
	 */
	function removeResizeListener(element, callback) {
		var listener = getListener(element);

		if(!listener) {
			return;
		}

		// If a specific callback was passed in, remove it
		if(callback) {
			var callbacks = listener.callbacks;

			for(var i = 0; i < callbacks.length; ++i) {
				if(callbacks[i] === callback) {
					callbacks.splice(i, 1);
					--i;
				}
			}

			// If there are still callbacks, we're done
			if(callbacks.length) {
				return;
			}
		}

		// If we've made it this far, remove the entire listener
		element.removeChild(listener.sensor);
	}

	/**
	 * Scroll event handler
	 * @param {Event} e
	 */
	function scrollHandler(e) {
		if(!e) {
			e = window.event;
		}

		var target = e.target || e.srcElement;

		if(!target) {
			return;
		}

		var listener = target[_private];

		if(listener.dirty) {
			return;
		}

		listener.dirty = true;
		dirty.push(listener);

		// Queue up a frame to check dirty listeners
		if(!dirty_frame) {
			dirty_frame = requestAnimationFrame(checkDirtyListeners);
		}
	};

	/**
	 * Checks all possibly resized listeners for changes in dimensions
	 */
	function checkDirtyListeners() {
		for(var i = 0; i < dirty.length; ++i) {
			var listener = dirty[i];
			var element  = listener.sensor.parentNode;

			listener.dirty = false;

			listener.expand_sensor.scrollLeft =
			listener.expand_sensor.scrollTop  =
			listener.shrink_sensor.scrollLeft =
			listener.shrink_sensor.scrollTop  = massive;

			if(!element) {
				continue;
			}

			var width    = element.offsetWidth;
			var height   = element.offsetHeight;

			if(listener.last_width === width && listener.last_height === height) {
				continue;
			}

			var data = {
				width       : width,
				height      : height,
				last_width  : listener.last_width,
				last_height : listener.last_height
			};

			listener.last_width  = width;
			listener.last_height = height;

			for(var j = 0; j < listener.callbacks.length; ++j) {
				listener.callbacks[j].call(listener.sensor.parentNode, data);
			}
		}

		dirty.length = 0;
		dirty_frame  = null;
	}

	/**
	 * Gets the listener object for a given element
	 * @param  {HTMLElement} element The element to get the listener for
	 * @return {Object|null}         The listener or null if one was not found
	 */
	function getListener(element) {
		if(element[_private]) {
			return element[_private];
		}

		for(var i = 0; i < element.childNodes.length; ++i) {
			var child = element.childNodes[i];

			if(child[_private]) {
				return child[_private];
			}
		}

		return null;
	}

	/**
	 * Wraps a value in an array if it isn't one
	 * @param  {*} value The value to wrap
	 * @return {*}       The wrapped value
	 */
	function wrapInArray(value) {
		if(!value || typeof value !== 'object' || typeof value.length === 'undefined') {
			return [value];
		}

		return value;
	}
}(this));

}).apply(eon.resize);


/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @param  {Function} callback     [description]
 * @return {[type]}            [description]
 */
eon.addResizeListener = function (element, key, fn) {

  if ('ResizeObserver' in window) {

    element.__resizeObservers = element.__resizeObservers || {};

    // If there is already a resizeObserver with that key, 
    // we disconnect/delete it, and create a new one with the provided callback
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

    // Creates the resizeObserver for the element with the provided callback
    element.__resizeObservers[key] = new ResizeObserver(fn);
    element.__resizeObservers[key].observe(element);

  } else {

    eon.onReady(function () {

      element.__resizeListeners = element.__resizeListeners || {};

      // If there is already a resizeListener with that key, 
      // we remove it, and create a new one with the provided callback
      if (element.__resizeListeners[key]) {
        eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
      }

      // Creates the resizeObserver for the element with the provided callback
      element.__resizeListeners[key] = fn;
      eon.resize.ResizeListener.add(element, element.__resizeListeners[key]);

    });

  }

};

/**
 *
 * @param  {[type]} element [description]
 * @param  {[type]} key      [description]
 * @return {[type]}            [description]
 */
eon.removeResizeListener = function (element, key) {

  if ('ResizeObserver' in window) {

    // Checks if the key already exists and disconnects/deletes it
    if (element.__resizeObservers[key]) {
      element.__resizeObservers[key].disconnect();
      delete element.__resizeObservers[key];
    }

  } else {

    // Checks if there is a resizeListener with that key and removes it
    if (element.__resizeListeners[key]) {
      eon.resize.ResizeListener.remove(element, element.__resizeListeners[key]);
    }

  }

};

eon.util = eon.util || {};
/**
 * Set first string character to upper case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToUpperCase = function (str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
/**
 * Set first string character to lower case
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.firstToLowerCase = function (str) {
  var first = str.substring(0, 1);
  var low = str.substring(0, 1).toLowerCase();
  return low + str.substring(1, str.length);
};
/**
 * Replaces the camel cases for hyphens
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.camelToHyphenCase = function (str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};
/**
 * Replaces the hyphens cases for camels
 * @param  {[type]} str [description]
 * @return {[type]}     [description]
 */
eon.util.hyphenToCamelCase = function (str) {
  return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
};
/**
 * Parse query params to object
 * @param  {[type]} url [description]
 * @return {[type]}     [description]
 */
eon.util.queryToObject = function (url) {
  var obj = {};
  // Get query params substring from url
  var paramsStr = url.split("?")[1];
  if (paramsStr) {
    paramsStr = paramsStr.split("#")[0];
    // Store each params into an array
    var paramsArray = paramsStr.split("&");
    for (var i = 0; i < paramsArray.length; i++) {
      var paramStr = paramsArray[i];
      // Store query param as an object property
      obj[paramStr.split("=")[0]] = paramStr.split("=")[1];
    }
  }
  return obj;
};
/**
 * Parse params object to query string
 * @param  {[type]} obj [description]
 * @return {[type]}      [description]
 */
eon.util.objectToQuery = function (obj) {
  var queryStr = "";
  var keyIndex = 0;
  for (var key in obj) {
    // Check first parameter added
    if (keyIndex > 0) {
      // Build string with query parameters separator
      queryStr += "&" + key + "=" + obj[key];
    } else {
      // Build string without query parameters separator
      queryStr += key + "=" + obj[key];
    }
    keyIndex++;
  }
  return queryStr;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.replaceParam = function (url, paramsObj) {
  // Convert url params into a manipulable object
  var queryObj = this.queryToObject(url);
  // Replace or add query param
  for (var key in paramsObj) {
    queryObj[key] = paramsObj[key];
  }
  // Return url with its parameters updated
  var newUrl = url.split("?")
    ? url.split("?")[0] + "?" + this.objectToQuery(queryObj)
    : url + "?" + this.objectToQuery(queryObj);
  return newUrl;
};
/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowser = function () {
  var browserName;
  // Internet Explorer 6-11
  if (document.documentMode) {
    browserName = "IE";
  }
  // Edge 20+
  if (!document.documentMode && window.StyleMedia) {
    browserName = "Edge";
  }
  // Chrome 1+
  if (window.chrome && window.chrome.webstore) {
    browserName = "Chrome";
  }
  // Firefox 1.0+
  if (typeof InstallTrigger !== "undefined") {
    browserName = "Firefox";
  }
  // Safari
  if (!window.chrome && navigator.userAgent.indexOf("Safari") > -1) {
    browserName = "Safari";
  }
  // TODO - ** Test in Opera**
  if (
    (window.opr && opr.addons) ||
    window.opera ||
    navigator.userAgent.indexOf(" OPR/") >= 0
  ) {
    browserName = "Opera";
  }
  return browserName;
};

/**
 * Replace or add params to specified url
 * @param  {[type]} url [description]
 * @param  {[type]} paramsObj [description]
 * @return {[type]}      [description]
 */
eon.util.getBrowserScrollBarWidth = function () {

  if (!eon.__browserScrollBarWidth) {

    var outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

    document.body.appendChild(outer);

    var widthNoScroll = outer.getBoundingClientRect().width;
    // force scrollbars
    outer.style.overflow = "scroll";

    // add innerdiv
    var inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);

    var widthWithScroll = inner.getBoundingClientRect().width;

    // remove divs
    outer.parentNode.removeChild(outer);

    // Creates a listener for the window resize to handle the zoom in/out of the browser that may affect the scroll bar width
    if (!eon.__browserScrollBarWidthListener) {
      window.addEventListener("resize", function () {
        delete eon.__browserScrollBarWidth;
      });
    }

    eon.__browserScrollBarWidth = widthNoScroll - widthWithScroll;
    eon.__browserScrollBarWidthListener = true;

  }

  return eon.__browserScrollBarWidth;

};

eon.util.isTrue = function (a) {
  return a == true || a == "true";
};

eon.util.isTouchScreen = function () {
  return "ontouchstart" in window;
};

eon.ajax = function (url, options, cb) {
  options = options || {};
  options.method = options.method ? options.method.toUpperCase() : "GET";
  options.querySeparator = options.querySeparator || "?";
  options.paramSeparator = options.paramSeparator || "&";
  options.payload = options.payload || null;
  options.async = options.async || null;
  options.user = options.user || null;
  options.password = options.password || null;

  var xhr = options.xhr || new XMLHttpRequest();
  xhr.onreadystatechange = function () {
    if (this.readyState == 4) {
      var success = this.status >= 200 && this.status < 300;
      cb(success, {
        url: url,
        method: options.method,
        xhr: this,
        status: this.status,
        response: this.response,
        responseText: this.responseText
      });
    }
  };

  if (options.params) {
    var paramsKeys = Object.keys(options.params);
    if (paramsKeys.length > 0) {
      url += options.querySeparator + paramsKeys[0] + "=" + options.params[paramsKeys[0]];
      for (var i = 1; i < paramsKeys.length; i++) {
        url += options.paramSeparator + paramsKeys[i] + "=" + options.params[paramsKeys[i]];
      }
    }
  }

  if (options.async || options.user || options.password) {
    xhr.open(options.method, url, options.async, options.user, options.password);
  } else {
    xhr.open(options.method, url);
  }

  if (options.contentType) {
    xhr.setRequestHeader("Content-Type", options.contentType);
  }

  if (options.headers) {
    for (var header in options.headers) {
      xhr.setRequestHeader(header, options.headers[header]);
    }
  }
  xhr.send(options.payload);
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.arrayToMap = function (array) {
  var map = new Map();

  for (var i = 0; i < array.length; i++) {
    map.set(i.toString(), array[i]);
  }

  return map;
};

/**
 * 
 * @param  {[type]}  [description]
 */
eon.util.objectToMap = function (object) {
  var map = new Map();

  for(var key in object){
    map.set(key, object[key]);
  }

  return map;
};
/**
 * Get Map Js Object representation
 * @param  {[type]}  [description]
 */
eon.util.mapToObject = function (map) {
  var obj = Object.create(null);
  map.forEach(function (value, key, mapObj) {
    mapObj[key] = value;
});
  return obj;
};

/**
 * :::::::::::::::::::::
 * Progressive Web App
 * :::::::::::::::::::::
 * 
 * > Home screen access - manifest.json
 * > Offline mode - service-worker.js
 * 
 * *** SERVICE WORKERS *** 
 * . Service Worker is an experimental technology. New browsers versions are supporting it
 * by default but its functionality is not guaranteed for now.
 *  
 * . An HTTPS implementation is needed to work with service workers.
 * Localhost is considered a secure origin by browsers as well
 * 
 * ***************************
 * 
 */

eon.cache = eon.cache || {};

eon.cache.config = eon.cache.config || {};

 // Check if eon has any cache strategy
 if ('serviceWorker' in navigator && Object.keys(eon.cache.config).length) {
  // Check service worker existence
  (function (proxied) {
    ServiceWorkerContainer.prototype.register = function () {

      this._registered = true;

      return proxied.apply(this, arguments);
    };
  })(ServiceWorkerContainer.prototype.register);

  eon.onReady(function () {
    // Check service worker existence
    if(!navigator.serviceWorker._registered) {

      // Register eon service worker
      navigator.serviceWorker
        .register(eon.basePath + '/modules/cache-sw.js')
        .then(function () {
          console.log('[ServiceWorker] Registered');
      });

    }
  });
}

eon.cache.open = function (cb) {

  eon.cache.config.name = eon.cache.config.name || "eon-cache";

  // Check browser cache storage existence
  if ('caches' in window) {

    // Create cache
    caches.open(eon.cache.config.name).then(function (cache) {
      // Cache config
      cb(null, cache);
    });

  }
}

eon.cache.add = function (request, options, cb) {
  var config = eon.cache.config;

  // Conditions
  var excluded = config.exclude && (options && config.exclude.indexOf(options.name) > -1);
  var requestAll = config.requests && config.requests.indexOf("*") > -1;
  var included = requestAll || !options || (options && config.requests && config.requests.indexOf(options.name) > -1);

  // Check cache config
  if (!excluded && included) {
    // Check eon-cache reference existence
    if (!eon.cache.ref) {
      eon.cache.open(function (error, cache) {
        eon.cache.ref = eon.cache.ref || cache;
        // Check if the file has been cached already
        cache.match(request).then(function (cached) {
          if(!cached) {
            cache.add(request).then(function () {    
              if (cb) { cb(null, request) }
            });
          }
        });
      });
    }
  }
}

eon.history = eon.history || {};

eon.history.location = {};

eon.history.location.origin = window.location.origin;
eon.history.location.href = window.location.href;
eon.history.location.state = window.location.hash || window.location.pathname.split("/")[1];
eon.history.location.params = eon.util.queryToObject(window.location.href);
eon.history.current = window.location.pathname.substring(1);
eon.history.states = {};
eon.history.cancelNavigation = false;

eon.history.push = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.pushState(obj, url, title);
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};
eon.history.replace = function (obj, url, title) {
  if (!eon.history.cancelNavigation) {
    history.replaceState(obj, url, title);
    delete eon.history.states[eon.history.current];
    eon.history.getURLInformation();
    eon.history.states[eon.history.current] = url;
  }
};

// Create on URL hash changed callback
eon.createCallback("onHashChanged", eon.history);

// Wrap window on pop state event
window.onpopstate = function () {
  eon.history.getURLInformation();
  eon.triggerCallback("onHashChanged", eon.history, eon.history, [eon.history]);
};

/*
  @function getURLInformation
  @description Save window location object information
*/
eon.history.getURLInformation = function () {
  eon.history.location.origin = window.location.origin;
  eon.history.location.state = window.location.history || window.location.pathname.substring(1);
  eon.history.location.params = eon.util.queryToObject(window.location.href);
  eon.history.current = window.location.hash ? window.location.pathname.substring(1) + window.location.hash
    : window.location.pathname.substring(1);
};

eon.store = function () {
  var el = this;
  /* Resources representation */
  this.data = {};

  // Create useful callbacks
  createCallbacks();

  // Import Memory Adapter
  importAdapter();
  
  /* 
      ##########
      Private Functions
      ##########
  */
  /*
      @function _createCallbacks
      @description 
  */
  function createCallbacks() {
    eon.createCallback("onLoaded", el, "ready");
    eon.createCallback("onDataChanged", el);
  }
  /*
      ** TO BE REMOVED
      @function importAdapter
      @description 
  */
  function importAdapter() {
    // Clone adapter functions
    cloneFunctions(new eon.data.MemoryAdapter());
    // Store data access
    createDataDescriptor();
    // Trigger user callback once VPA has been loaded
    eon.triggerCallback("onLoaded", el, el, [el]);

  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function cloneFunctions(adapter) {
    // Clone adapter data object
    Object.assign(el, adapter);
    // Get BaseAdapter prototype functions
    Object.assign(el, adapter.constructor.prototype);
  };
  /*
      @function (private) _cloneFunctions
      @description 
  */
  function createDataDescriptor() {
    // Define property descriptor with custom get and set
    Object.defineProperty(
      el,
      "data",
      {
        get: function () {
          return el._memory.data;
        },
        set: function (value) {
          // Update property value
          el._memory.data = value;
          // Fire data changed event
          eon.triggerCallback("onDataChanged", el, el, [el.data]);
        }
      }
    );
  }
}


eon.endpoint = function (type, url) {
  var el = this;
  /* Endpoint standard type */
  this.type = type;
  /* Resources root url */
  this.composedURL = "";
  /* Resources url */
  this.url = url;
  /* GraphQL Web Sockets based use only */
  this.socket = type == "graphSockets" && !this.socket ? new WebSocket(this.url) : this.socket;

  /* 
      ##########
      Functions
      ##########
  */

  // -- REST API --

  /*
    @function get
    @description Read data resource // Read all data resources
  */
  this.get = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    // Set up request
    var options = {
      method: "GET"
    };
    // Send request
    eon.ajax(el.composedUrl, options, cb);
  } : "";
  /*
    @function put
    @description Overwrite data resource // create if not exists
  */
  this.put = type == "rest" ? function (id, data, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "PUT",
        payload: data
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";
  /*
    @function post
    @description Create data resource
  */
  this.post = type == "rest" ? function (data, cb) {
    // Check resource id and set url
    if (data) {
      // Set up request
      var options = {
        method: "POST",
        payload: data
      };
      // Send request
      eon.ajax(el.url, options, cb);
    } else {
      console.error('No resource data found');
    }
  } : "";
  /*
    @function delete
    @description Delete data resource
  */
  this.delete = type == "rest" ? function (id, cb) {
    // Check resource id and set url
    el.composedUrl = el.url;
    el.composedUrl += id ? "/" + id : "";
    if (id) {
      // Set up request
      var options = {
        method: "DELETE"
      };
      // Send request
      eon.ajax(el.composedUrl, options, cb);
    } else {
      console.error('No resource id found');
    }
  } : "";

  // -- GraphQL --

  /*
    @function send
    @description Query data source
  */
  this.send = type == "graphHTTP" ? function (queryString, cb) {
    el.query(queryString, cb);
  } : "";
  /*
    @function query
    @description Query data source
  */
  this.query = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPQuery(queryString, cb);
  } : "";
  /*
    @function mutation
    @description Update data source
   */
  this.mutation = type == "graphHTTP" ? function (queryString, cb) {
    graphHTTPMutation(queryString, cb);
  } : "";
  /*
    @function subscribe
    @description Subscribe
   */
  this.subscribe = type == "graphSockets" ? function (queryString, cb) {
    // Check graphQL protocol based on
    graphSocketsSubscription(queryString, cb);
  } : "";

  /* 
      #################
      Private Functions
      #################
  */

  // -- GraphQL HTTP API --

  // Query call HTTP based
  function graphHTTPQuery(queryString, cb) {
  
    // Validate query string 
    if (queryString) {
      // Set up request
      var options = {
        method: "GET",
        contentType: "application/json",
        payload: "query:" +  queryString
      };
      console.log('options', options.payload);
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }
  // Mutation call HTTP based
  function graphHTTPMutation(queryString, cb) {
    // Validate mutation string 
    if (queryString) {
      // Set up request
      var options = {
        method: "POST",
        payload: "mutation:" + queryString
      };
      // Send request
      eon.ajax(el.url, options, cb);
    }
  }

  // -- GraphQL Web Sockets API --

  // Query call Web sockets based
  function graphSocketsSubscription(queryString, cb) {
    // Server response listener
    el.socket.onmessage = function (event) {
      // TODO Handle response messages
      cb(true, event);
    };
    el.socket.send("subscription:" + queryString);
  }
}

eon.data = eon.data || {};

eon.data.MemoryAdapter = function () {
  // eon.vpa.declareAdapter("MemoryAdapter", function (config) {
  var memory = {}; // Memory itself
  memory.data = new Map(); // Where data will be stored
  var counter = 0;

  // @function create (private) [Create a new entry to the memory object with given data] @param query
  function create(query) {
    return new Promise(function (resolve, reject) {
      if (query.data) {
        var id;
        if (query.data.id) {
          id = query.data.id;
        }
        else {
          // ** Check if some data has already been inserted
          counter = memory.data.size ? memory.data.size + 1 : 0;
          id = counter;
          query.data.id = "" + id;
          counter++;
        }
        var validated = validate(query);
        if (validated) {
          memory.data.set(id, validated);
          resolve(validated);
        }
        else {
          reject(new Error("Validation error"));
        }
      }
      else {
        reject(new Error("Data not found"));
      }
    });
  }
  // @function read (private) [Read from memory or list if no id given] @param query
  function read(query) {
    return new Promise(function (resolve, reject) {
      // Check id value
      if (query.id) {
        if (memory.data.get(query.id)) {
          console.log('memory.data.get(query.id)', memory.data.get(query.id));
          resolve(memory.data.get(query.id));
        } else {
          reject(new Error("Not found"));
        }
      } else {
        var keys;
        var result = new Map();
        // Sort data before get range
        if (query.sortField) {
          var asc = 1;
          if (query.sortRule && ~["descending", "desc"].indexOf(query.sortRule)) {
            asc = -1;
          }
          keys = sortArray(memory.data, query.sortField, asc);
        }
        // Check ranges
        var start = query.limitStart || 0;
        var end = (query.limitAmount + query.limitStart) || memory.data.size;
        end = end > memory.data.size ? memory.data.size : end;

        if (!keys) {
          keys = [];
          // Store map keys
          memory.data.forEach(function (value, key, map) {
            keys.push(key);
          });
        }
        // Build sorted map
        for (var i = start; i < end; i++) {
          // Check keys sorted 
          if (query.sortField) {
            result.set(keys[i].key, memory.data.get(keys[i].key));
          } else {
            result.set(keys[i], memory.data.get(keys[i]));
          }
        }
        resolve(result);
      }
    });
  }
  // @function update (private) [Update an existing entry from memory] @param query
  function update(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        if (query.data) {
          // Check update target
          if (memory.data.get(query.id)) {
            // Merge current and new data
            query.data = deepMerge(memory.data.get(query.id), query.data);
            var validated = validate(query);
            if (validated) {
              // Set new validated data entry
              memory.data.set(query.id, validated);
              resolve(validated);
            }
            else {
              reject(new Error("Validation error"));
            }
          }
          else {
            reject(new Error("Id doesn't exist"));
          }
        }
        else {
          reject(new Error("Data not found"));
        }
      }
      else {
        reject(new Error("Id not found"));
      }
    });
  }
  // @function delete (private) [Delete from memory] @param query
  function remove(query) {
    return new Promise(function (resolve, reject) {
      // Check null values
      if (query.id) {
        // Check remove target
        if (memory.data.get(query.id)) {
          var result = memory.data.get(query.id);
          memory.data.delete(query.id);
          resolve(result);
        }
        else {
          reject("Id not found");
        }
      }
      else {
        // Remove all entries
        var result = memory;
        // Safe clear object and its copy baseAdapter._memory
        memory.data.forEach(function (value, key, map) {
          memory.data.delete(key);
        });
        resolve(result);
      }
    });
  }
  // @function sortArray (private) [Sort an array of objects] @param array @param key @param asc (number) [1 if ascendant, -1 if descendant]
  function sortArray(data, field, asc) {
    // ** IMPROVE
    var array = [];
    // Store map keys
    data.forEach(function (value, key, map) {
      array.push({
        key: key,
        field: data.get(key)[field]
      });
    });
    // Check ascending value
    asc = asc || 1;
    // Sort comparing function
    function compare(a, b) {
      if (a.field < b.field) {
        return -1 * asc;
      }
      else if (a.field > b.field) {
        return 1 * asc;
      }
      else {
        return 0;
      }
    }
    // Sort map keys
    array.sort(compare);
    return array;
  }
  // @function validate(private) [Not implemented yet] @param query
  function validate(query) {
    if (query.validate) {
      // Do something
    }
    return query.data;
  }
  // @function deepMerge (private) [Merge two objects] @param args
  var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var merged = {};
    var merge = function (obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          if (obj[prop] && typeof obj[prop] == 'object') {
            merged[prop] = deepMerge(merged[prop], obj[prop]);
          }
          else {
            merged[prop] = obj[prop];
          }
        }
      }
    };
    for (var i = 0; i < arguments.length; i++) {
      var obj = arguments[i];
      merge(obj);
    }
    return merged;
  };
  var queryHandler = function (adapterData) {
    var baseQuery = eon.vpa.createBaseQuery(adapterData);
    baseQuery.result = function (cb) {
      var query = baseQuery.query;
      var result;
      var error;
      switch (query.action) {
        case "create":
          create(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "read":
          read(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "update":
          update(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
        case "delete":
          remove(query).then(function (data) {
            result = data;
            cb(error, result);
          }).catch(function (er) {
            error = er;
            cb(error, result);
          });
          break;
      }
    };
    return baseQuery;
  };
  var baseAdapter = eon.vpa.createBaseAdapter(queryHandler);
  baseAdapter._memory = memory;
  return baseAdapter;
}



eon.validator = eon.validator || {};
eon.validator.schemas = eon.validator.schemas = {};
eon.validator.defaultErrorMessage = "Does not meet the requirements.";

eon.validator.addSchema = function (id, schema) {
    if (schema) {
        // Saves the schema with the given id
        eon.validator.schemas[id] = schema;
    }
}

eon.validator.containsSchema = function (id) {
    // Returns whether there is already a schema id or not
    return eon.validator.schemas[id] ? true : false;
}

eon.validator.validate = function (data, schema) {

    // If the parameter is a string then we assume its the id of the schema, else we take for granted its a schema object
    schema = schema.constructor === String ? eon.validator.schemas[schema] : schema;

    if (data && schema) {

        var errorObj = {};

        // Loops all the properties for the given schema and for each property validates the field type, if it does not meet
        // the schema requirements the errorObj gets filled with the proper information
        eon.validator.loopProperties(schema, function (property) {

            eon.validator.validateRequiredField(property, schema, data, errorObj);
            eon.validator.validateStringField(property, schema, data, errorObj);
            eon.validator.validateDateField(property, schema, data, errorObj);
            eon.validator.validateNumericField(property, schema, data, errorObj);
            eon.validator.validateArrayField(property, schema, data, errorObj);
            eon.validator.validateObjectField(property, schema, data, errorObj);

        });

        // If there are errors collected then returns the errorObj, else just returns undefined
        return Object.keys(errorObj).length > 0 ? errorObj : undefined;

    }

    return undefined;

}

eon.validator.loopProperties = function (schema, callback) {

    // We take the schema properties
    var properties = schema.properties;
    var fields = Object.keys(properties);

    // And loop through them
    for (var i = 0; i < fields.length; i++) {

        // Call the callback passing the field
        callback(fields[i]);

    }

}

eon.validator.validateRequiredField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];
    var isRequired = (schema.required && schema.required.indexOf(property) > -1) || eon.util.isTrue(propertySchema.required);

    var isInvalid = ((!data[property] || data[property] == "") && isRequired);

    // If if does not meet any of the requirements then it fills the error object with the proper information
    if (isInvalid) {
        eon.validator.fillErrorObj(property, "Required", errorObj);
    }

}

eon.validator.validateStringField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "string" && data.hasOwnProperty(property)) {

        // MaxLength
        var hasMaxLength = propertySchema.hasOwnProperty("maxLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMaxLength = data[property].length > parseInt(propertySchema.maxLength);

        // MinLength
        var hasMinLength = propertySchema.hasOwnProperty("minLength") && (parseInt(propertySchema.maxLength) > 0);
        var exceedsMinLength = data[property].length < parseInt(propertySchema.minLength);

        // Pattern
        var hasPattern = propertySchema.hasOwnProperty("pattern");
        var matchesPattern = new RegExp(propertySchema.pattern).test(data[property]);

        var isInvalid = (hasPattern && !matchesPattern) || (hasMaxLength && exceedsMaxLength) || (hasMinLength && exceedsMinLength);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateDateField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "date" && data.hasOwnProperty(property)) {

        // Takes the format of the schema, if there is no format in the schema it takes a default format work with
        var format = propertySchema.format ? propertySchema.format : "YYYY-MM-DD";

        // Takes the data value
        var value = data[property];
        // Turns that value into an object with day,month and year properties
        var valueObj = eon.time.getDateObjectFromString(value, format);
        // Takes the object and applies the schema format to see if both values (the value and the schema value) are the same,
        // that would mean if follows the same format
        var schemaValue = eon.time.generateOutput(valueObj, format);

        var isInvalid;

        // If it does not follow the same format then it is no valid
        if (value != schemaValue) {

            isInvalid = true;

        } else {

            var year = valueObj.year != undefined ? valueObj.year : 0;
            var month = valueObj.month != undefined ? (valueObj.month - 1) : 0;
            var day = valueObj.day != undefined ? valueObj.day : 1;

            // Turns the date into epoch so that we are able to compare dates
            var epochDate = new Date(year, month, day).getTime();
            var minEpochDate, maxEpochDate;

            // Checks if there is a minimum specified in the schema
            if (propertySchema.hasOwnProperty("minimum")) {

                var minDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var minYear = minDateObj.year != undefined ? minDateObj.year : 0;
                var minMonth = minDateObj.month != undefined ? (minDateObj.month - 1) : 0;
                var minDay = minDateObj.day != undefined ? minDateObj.day : 1;

                minEpochDate = new Date(minYear, minMonth, minDay).getTime();
                
                isInvalid = epochDate < minEpochDate ? true : isInvalid;

            }

            // Checks if there is a maximum specified in the schema
            if (propertySchema.hasOwnProperty("maximum")) {

                var maxDateObj = eon.time.getDateObjectFromString(propertySchema.minimum, format);

                var maxYear = maxDateObj.year != undefined ? maxDateObj.year : 0;
                var maxMonth = maxDateObj.month != undefined ? (maxDateObj.month - 1) : 0;
                var maxDay = maxDateObj.day != undefined ? maxDateObj.day : 1;

                maxEpochDate = new Date(maxYear, maxMonth, maxDay).getTime();
                isInvalid = epochDate > maxEpochDate ? true : isInvalid;

            }

        }

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateNumericField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if ((propertySchema.type == "integer" || propertySchema.type == "number") && data.hasOwnProperty(property)) {

        var value = parseFloat(data[property]);

        // MultipleOf
        var hasMultipleOf = propertySchema.hasOwnProperty("multipleOf");
        var isMultipleOf = value % propertySchema.multipleOf === 0;

        // Maximum
        var hasMaximum = propertySchema.hasOwnProperty("maximum");
        var exceedsMaximum = propertySchema.exclusiveMaximum ? (value >= propertySchema.maximum) : (value > propertySchema.maximum);
        
        // Minimum
        var hasMinimum = propertySchema.hasOwnProperty("minimum");
        var exceedsMinimum = propertySchema.exclusiveMinimum ? (value <= propertySchema.minimum) : (value < propertySchema.minimum);

        var isInvalid = (hasMultipleOf && !isMultipleOf) || (hasMaximum && exceedsMaximum) || (hasMinimum && exceedsMinimum);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateArrayField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "array" && data.hasOwnProperty(property)) {

        var valuesArray = data[property].filter(function (value) {
            return value != false;
        });

        var hasMinItems = propertySchema.hasOwnProperty("minItems");
        var exceedsMinItems = valuesArray.length < parseInt(propertySchema.minItems);

        var hasMaxItems = propertySchema.hasOwnProperty("maxItems");
        var exceedsMaxItems = valuesArray.length > parseInt(propertySchema.maxItems);

        var isInvalid = (hasMinItems && exceedsMinItems) || (hasMaxItems && exceedsMaxItems);

        // If if does not meet any of the requirements then it fills the error object with the proper information
        if (isInvalid) {
            var errorMessage = propertySchema.errorMessage ? propertySchema.errorMessage : eon.validator.defaultErrorMessage;
            eon.validator.fillErrorObj(property, errorMessage, errorObj);
        }

    }

}

eon.validator.validateObjectField = function (property, schema, data, errorObj) {

    var propertySchema = schema.properties[property];

    if (propertySchema.type == "object" && data.hasOwnProperty(property)) {

        var propertyData = data[property];
        var nestedErrorObj = {};

        errorObj[property] = nestedErrorObj;

        // Loops through the new schema and validates against the property data
        eon.validator.loopProperties(propertySchema, function (property) {

            eon.validator.validateRequiredField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateStringField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateNumericField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateArrayField(property, propertySchema, propertyData, nestedErrorObj);
            eon.validator.validateObjectField(property, propertySchema, propertyData, nestedErrorObj);

        });

        if (Object.keys(errorObj[property]) == 0) {
            delete errorObj[property];
        }

    }

}

eon.validator.fillErrorObj = function (property, errorMessage, errorObj) {
    !errorObj[property] ? errorObj[property] = [errorMessage] : errorObj[property].push(errorMessage);
}


  
    // ############################################################################################
// VPA JS
// ############################################################################################

// Creates a namespace for vpa.js
eon.vpa = eon.vpa || {};

(function () {
  
  var define = eon.amd.define;
  var require = eon.amd.require;

  var vpa = {};
  vpa.useAmd = true;
  vpa.declareLocal = true;

  // Import vpa.js file
  // ------------------------------------------------------------------------------------
    // USE ONLY WITH SCRIPT SRC!

// Support module in any environment
var scope = typeof global != "undefined" ? global : window;
scope["module"] = scope["module"] || undefined;

// Global vpa declaration
scope.vpa = scope.vpa || {};

vpa.declareLocal = vpa.hasOwnProperty("declareLocal") ? vpa.declareLocal : true;
vpa.declareGlobal = vpa.hasOwnProperty("declareGlobal") ? vpa.declareGlobal : true;

vpa.useAmd = vpa.hasOwnProperty("useAmd") ? vpa.useAmd : false;
vpa.allowAmdRequire = vpa.hasOwnProperty("allowAmdRequire") ? vpa.allowAmdRequire : false;

if (vpa.useAmd || vpa.allowAmdRequire) {
  vpa.define = vpa.define || define;
  vpa.require = vpa.require || require;
  vpa.useAmd = true; // Force AMD when any related option is used
}

vpa.declareAdapter = function (name, adapter, ext_module) {
  (function () {
    if (vpa.declareLocal && vpa.useAmd) {
        vpa.define(function () {
          return adapter;
        });      
    }
    if (vpa.declareGlobal) {
      vpa[name] = adapter;
    }
  })();
};

// Base implementation
(function () {
    var self = this;
    // Base Query and Adapter Objects
    self.createBaseQuery = function (adapterData) {
        var BaseQuery = /** @class */ (function () {
            function BaseQuery() {
                this.query = adapterData || {};
            }
            BaseQuery.prototype.options = function (o) {
                this.query.options = o;
                return this;
            };
            BaseQuery.prototype.limit = function (start, amount) {
                this.query.limitStart = start;
                this.query.limitAmount = amount;
                return this;
            };
            BaseQuery.prototype.validate = function (schema) {
                this.query.validate = schema;
                return this;
            };
            BaseQuery.prototype.sort = function (field, rule) {
                this.query.sortField = field;
                this.query.sortRule = rule;
                return this;
            };
            BaseQuery.prototype.view = function (v) {
                this.query.view = v;
                return this;
            };
            BaseQuery.prototype.result = function (cb) {
                throw "Not implemented, please override result function";
            };
            return BaseQuery;
        }());
        return new BaseQuery();
    };
    self.createBaseAdapter = function (queryHandler) {
        var BaseAdapter = /** @class */ (function () {
            function BaseAdapter() {
            }
            BaseAdapter.prototype.create = function (data) {
                return queryHandler({
                    action: "create",
                    data: data
                });
            };
            BaseAdapter.prototype.read = function (id) {
                return queryHandler({
                    action: "read",
                    id: id
                });
            };
            BaseAdapter.prototype.update = function (id, data) {
                return queryHandler({
                    action: "update",
                    id: id,
                    data: data
                });
            };
            BaseAdapter.prototype.delete = function (id) {
                return queryHandler({
                    action: "delete",
                    id: id
                });
            };
            return BaseAdapter;
        }());
        return new BaseAdapter();
    };
}).apply(vpa);


// Allow vpa require
if (vpa.allowAmdRequire) {
  vpa.define(function () {
    return vpa;
  });
}  // ------------------------------------------------------------------------------------

  eon.vpa = vpa;

}).apply({});


}.apply(eon));
  



        eon.theme = "claro";
        // UI components
        eon.import([
          "eon/ui/eon-button",
          "eon/ui/eon-date",
          "eon/ui/eon-text",
          "eon/ui/eon-radio",
          "eon/ui/eon-group",
          "eon/ui/eon-checkbox",
          "eon/ui/eon-combobox",
          "eon/ui/eon-slider",
          "eon/ui/eon-spinner",
          "eon/ui/eon-toggle",
          "eon/ui/eon-form",
          "eon/custom/eon-showcase-item"
        ]);
      </script>
    </div>
    <!-- EXAMPLES BODY -->
    <div class="template-body">
      <eon-showcase-item title="Demo form">
        <eon-form action="#" method="get">

          <eon-text class="d-marginTop" inline="false" name="text" type="text" placeholder="Name and ast name" label="Client name"
            max-length="18"></eon-text>

          <eon-group name="sex" class="d-marginTop" label="Themes">
            <eon-radio class="radioSpacing" label="Material" value="material"></eon-radio>
            <eon-radio class="radioSpacing" label="Noire" value="noire"></eon-radio>
          </eon-group>

          <eon-checkbox class="d-marginTop" label="Global" name="global" value="global" checked="true"></eon-checkbox>

          <eon-combobox class="d-marginTop" label="Base color" name="selectorTest2" trigger="focus" placeholder="Placeholder"
            filter="false">
            <eon-item value="blue" displayValue="Blue"></eon-item>
            <eon-item value="red" displayValue="Red"></eon-item>
            <eon-item value="orange" displayValue="Orange"></eon-item>
          </eon-combobox>

          <eon-date label="Expiration" class="d-marginTop"> </eon-date>

          <span class="d-marginTop">Color-scheme</span>
          <eon-slider></eon-slider>

          <eon-spinner class="d-marginTop" label="Border" value="15" min="9" max="111"></eon-spinner>

          <eon-toggle class="d-marginTop" label="Accept policy" checked="true" value="toggle1" name="toggleOptions" id="option1">
          </eon-toggle>

          <eon-button inline="true" class="d-marginTop" type="submit" value="Submit">
          </eon-button>

        </eon-form>
      </eon-showcase-item>
    </div>

    <!-- END EXAMPLES BODY -->
    <script class="template-js">
      //** Showcase resize fix
      eon.onReady(function () {
        // Iframe content loaded monitoring
        eon.triggerCallback("onLoaded", window.frameElement);
      });
      //**
    </script>
    <style class="template-style">
      html,
      body {
        height: auto;
        width: 100%;
        padding: 0;
        margin: 0;
        background-color: transparent;
        color: #888888;
        overflow: hidden;
      }
    </style>
  </template>
  <!-- END SHOWCASE -->
</div>
</template>