<template>

  <div class="vc-grid-header">
    <div class="vc-grid-wrapper vc-sect1"></div>
  </div>

  <div class="vc-grid-rows">
    <vc-scroll prevent-render="false" arrowScrolls="false" type="auto" scrollsLength="auto" thickness="10" observers="true" rail-scrolls="false">
      <div class="vc-grid-wrapper">
      </div>
    </vc-scroll>
  </div>

  <div class="vc-grid-footer vc-fg1 vc-sect1 vc-unselectable">
    <div class="vc-grid-pagControls vc-fg5">
      <i class="vicon vicon-arrow-back vc-grid-pagIcon vc-fg1-hoverable" data-navigation="first"></i>
      <i class="vicon vicon-chevron-left vc-grid-pagIcon vc-fg1-hoverable" data-navigation="previous"></i>
      <div class="pageSelector"></div>
      <i class="vicon vicon-chevron-right vc-grid-pagIcon vc-fg1-hoverable" data-navigation="next"></i>
      <i class="vicon vicon-arrow-forward vc-grid-pagIcon vc-fg1-hoverable" data-navigation="last"></i>
    </div>
    <span class="vc-grid-entriesCount vc-fg5"></span>
  </div>

</template>

<script type="text/javascript">
  vcomet.element("vc-grid", "vc-grid.css", {
    themed: true,
    dependencies: [
      "../vc-row",
      "../vc-cell",
      "../vc-scroll"
    ],
    privateProperties: {
      /*
      @property (private) {Object} _misc
      @description Object with miscellaneous data
      */
      misc: {
        value: {},
        reflect: false
      },
      /*
      @property (private) {Object} _refs
      @description Object with references
      */
      refs: {
        value: {},
        reflect: false
      },
    },

    properties: {
      /*
      @property {Boolean} footer
      @description Whether the footer will be displayed or not
      */
      footer: {
        value: true,
        reflect: true
      },
      /*
      @property {String} pagination
      @description Defines the type of the page pagination
      */
      pagination: {
        value: "",
        reflect: true
      },
      /*
      @property {Boolean} entriesCount
      @description Whether the footer will display the page entries or not
      */
      entriesCount: {
        value: false,
        reflect: true
      },
      /*
      @property {String} columns
      @description Defines the columns that will be shown in the grid
      */
      columns: {
        value: "",
        reflect: true
      },
      /*
      @property {String} headers
      @description Defines the headers of the given columns
      */
      headers: {
        value: "",
        reflect: true
      },
      /*
      @property {String} String
      @description It can be a number of max rows of the page, or automatic
      */
      pageSize: {
        value: "auto",
        reflect: true
      },
      /*
      @property {Boolean} autofit
      @description Whether the grid will manage the rows amount depending on the available space
      */
      autofit: {
        value: "true",
        reflect: true
      },
      /*
      @property {Boolean} resizable
      @description Whether the user can resize the columns or not
      */
      resizable: {
        value: true,
        reflect: true
      },
      /*
      @property {Number} columnMinWidth
      @description Pixels that will be set as the minimum width of each column
      */
      columnMinWidth: {
        value: 150,
        reflect: true
      },
      /*
      @property {Number} rowMinHeight
      @description Pixels that will be set as the minimum height of each row
      */
      rowMinHeight: {
        value: 52,
        reflect: true
      },
      /*
      @property {Boolean} editable
      @description Whether the user will be able to edit entry cells or not
      */
      editable: {
        value: "false",
        reflect: true
      },
      /*
      @property {String} idProperty
      @description This property will be transfered to the store
      */
      idProperty: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} fill 
        @description 
        Values: true, false
        Default: true
      */
      fill: {
        value: true,
        reflect: true
      }
    },
    privateFunctions: {
      /*
      @function (private) _setupRefs
      @description Creates some fast access elements so that theres no need for calling the QuerySelector all the time.
      */
      setupRefs: function () {

        var el = this;

        el._refs.header = el.querySelector(".vc-grid-header");
        el._refs.headersWrapper = el.querySelector(".vc-grid-header .vc-grid-wrapper");
        el._refs.rowsWrapper = el.querySelector(".vc-grid-rows .vc-grid-wrapper");
        el._refs.footer = el.querySelector(".vc-grid-footer");

        el.vcometScroll = el.querySelector("vc-scroll");

        el._refs.pageSelector = el.querySelector(".pageSelector");
        el._refs.entriesCount = el.querySelector(".vc-grid-entriesCount");
        el.store = el.querySelector("vc-store");
      },
      /*
        @function (private) _setDefaultStyle
        @description Check if the default element style should be applied
      */
      setDefaultStyle: function () {
        var el = this;
        // Check fill behavior
        if (vcomet.util.isTrue(el.fill)) {
          // Content style
          el.classList.add("vc-fill");
        }
      },
      /*
      @function (private) _setupMisc
      @description Sets up basic properties for the misc object
      */
      setupMisc: function () {

        var el = this;

        el._misc.columns = {};
        el._misc.range = {};
        el._misc.entriesCount = 0;
        
        el._misc.resize = {};
        el._misc.resize.active = false;
        el._misc.resize.firstTime = true;

        el._misc.sourceFragment = document.createDocumentFragment();
        el._misc.sourceType = "";

        el._misc.currentPage = 1;
        el._misc.hasPagination = true;
        el._misc.isEditing = false;

      },
      /*
      @function (private) _setupColumns
      @description Sets up the columns and its css rule
      */
      setupColumns: function () {

        var el = this;

        var layoutWidth = 0;
        var columns = el.columns.replace(/\s/g, '').split(',');
        var headers = el.headers.length > 0 ? el.headers.replace(/\s/g, '').split(',') : [];
        var newStyle = document.createElement("style");
        var sheet, rulePosition, columnRule;

        //If there are no headers specified or the amount of headers is not the same as columns,
        //then we equal the headers to the columns
        headers = (headers.length == 0 || (headers.length < 0 && columns.length != headers.length)) ? columns : headers;

        el._refs.header.insertBefore(newStyle, el._refs.header.childNodes[0]);
        sheet = newStyle.sheet;

        for (var i = 0; i < columns.length; i++) {

          rulePosition = sheet.cssRules.length;
          sheet.insertRule("vc-grid[uid='" + el.uid + "'] vc-cell:nth-child(" + (i + 1) + ") {}", rulePosition);
          columnRule = sheet.cssRules[rulePosition];
          columnRule.style.minWidth = el.columnMinWidth + "px";
          layoutWidth = layoutWidth + parseInt(el.columnMinWidth);

          el._misc.columns[columns[i]] = {}
          el._misc.columns[columns[i]]["value"] = columns[i];
          el._misc.columns[columns[i]]["header"] = headers[i];
          el._misc.columns[columns[i]]["order"] = i;
          el._misc.columns[columns[i]]["rule"] = columnRule;
        }

        el._refs.headersWrapper.style.minWidth = layoutWidth + "px";
        el._refs.headersWrapper.style.width = "auto";

        el._refs.rowsWrapper.style.minWidth = layoutWidth + "px";
        el._refs.rowsWrapper.style.width = "auto";

      },
      /*
      @function (private) _setupHeaders
      @description Creation of the headers and its attributes
      */
      setupHeaders: function () {

        var el = this;

        var header = el.querySelector(".vc-grid-header .vc-grid-wrapper");
        var columnsKeys = Object.keys(el._misc.columns);
        var docFragment = document.createDocumentFragment();
        var headerCell;
        var headerResize;

        header.classList.add("headers");
        //Create header for each column
        for (var i = 0; i < columnsKeys.length; i++) {
          headerCell = document.createElement("vc-cell");

          //Adding Attributes to the header
          headerCell.setAttribute("type", "header");
          headerCell.setAttribute("sort", "none");
          headerCell.setAttribute("fixed", "false")
          headerCell.setAttribute("column", el._misc.columns[columnsKeys[i]].value);
          headerCell.setAttribute("order", el._misc.columns[columnsKeys[i]].order);
          headerCell.setAttribute("value", el._misc.columns[columnsKeys[i]].header);
          headerCell.onclick = function (e) {
            el._sortEntries(e, this)
          };

          docFragment.appendChild(headerCell);

          //If he grid columns are resizable then we will create a resize Indicator for every columns
          //except for the last one
          if ((el.resizable == "true" || el.resizable == true)) {

            headerResize = document.createElement("div");

            headerResize.classList.add("vc-grid-resizeIndicator");
            headerResize.dataset.columnTarget = i;

            headerResize.onmousedown = function (e) {

              if (e.button == 0) {

                el._misc.resize.initialPosition = el._misc.resize.initialPosition || {};
                el._misc.resize.initialPosition.x = e.clientX;
                el._misc.resize.initialPosition.y = e.clientY;

                el._resizeColumn(this);

              }
            };

            headerCell.appendChild(headerResize);
          }
        }

        header.appendChild(docFragment);
      },
      /*
      @function (private) _setupPageSize
      @description Setting up the rows size type depending on the user input
      */
      setupPageSize: function () {

        var el = this;

        if (!el.pageSize || el.pageSize == "auto") {

          el._misc.pageSizeType = "auto";
          el.pageSize = el._getRowsCapacity();

        } else if (el.pageSize == "all") {

          el.pageSize = 0;
          el._misc.pageSizeType = "all";


        } else {

          el._misc.pageSizeType = "fixed";
        }

      },
      /*
      @function (private) _setupAutofit
      @description Sets up the autofit boolean depending on the situation
      */
      setupAutofit: function () {

        var el = this;

        if (el.autofit == "false" || el.autofit == false) {

          el.autofit = false;

        } else if ((el.autofit == "true" || el.autofit == true)) {

          el.autofit = true;
          el.vcometScroll.onRender(function () {
            el.vcometScroll.content.style.display = "flex";
          });
        }

        if (el._misc.pageSizeType == "auto") {
          el._refs.rowsWrapper.classList.add("vc-grid-autofitRows");
        }

      },
      /*
      @function (private) _setupContent
      @description Depending on what the user provided with the grid we will set up our store with the data we have
      */
      setupContent: function () {

        var el = this;

        // If the sourceType is of type "remote" it means the user provided a store with an url
        if (el._misc.sourceType == "remote") {

          el._setupStore();

          // Else if the user has not provided a store we create one and check if it has atleast provided vc-rows and vc-cells from which
          // we will elaborate our data object
        } else {

          var data = el._generateDataFromDeclarativeRows();

          el.store = document.createElement("vc-store");
          el.store.setAttribute("type", "memory");
          el.idProperty = el.idProperty != "" ? el.idProperty : "entryid";

          el.store.idProperty = el.idProperty;

          el.appendChild(el.store);

          el._setupStore();

          if (data && Object.keys(data).length > 0) {
            el.setData(data);
          }

        }

      },
      /*
      @function (private) _setupStore
      @description Sets up callbacks to be called when this data is loaded and updated
      */
      setupStore: function () {

        var el = this;

        var start = 1;
        var limit = parseInt(el.pageSize);

        var myCallback = function () {
          if (el._misc.pageSizeType == "all") {
            el.pageSize = el.store.size;
          }

          el._handleStoreEntries("object", true, start, limit);
          el._updatePages(1);

        };

        //Store calls
        el.store.onCreated(function () {

          el.store.onLoaded(function () {

            if (el._misc.pageSizeType == "fixed" || el._misc.pageSizeType == "auto") {

              el.store.getRangeRemote(start, limit, myCallback);

            } else {

              // This is set to save the start/limit range, this will be of use when sorting the entries
              el._misc.range.start = start;
              el._misc.range.limit = limit;

              el.store.listRemote(myCallback);
            }

          });

          el.store.onSourceChanged(myCallback);

        });

      },
      /*
      @function (private) _setupNavigationButtons
      @description Sets up the events to navigate through the buttons
      */
      setupNavigationButtons: function () {

        var el = this;

        var first = el.querySelector('i[data-navigation="first"]');
        var previous = el.querySelector('i[data-navigation="previous"]');
        var next = el.querySelector('i[data-navigation="next"]');
        var last = el.querySelector('i[data-navigation="last"]');

        first.onclick = function () {
          el._navigate(first)
        };
        previous.onclick = function () {
          el._navigate(previous)
        };
        next.onclick = function () {
          el._navigate(next)
        };
        last.onclick = function () {
          el._navigate(last)
        };

      },
      /*
      @function (private) _setupFooter
      @description Sets up the grid footer
      */
      setupFooter: function () {

        var el = this;

        if (!vcomet.util.isTrue(el.footer)) {

          el._misc.hasEntriesCount = false;
          el._misc.hasPagination = false;
          
          el._refs.footer.style.display = "none";
          el._refs.entriesCount.style.display = "none";

        } else {

          el._misc.hasPagination = el.pagination == "none" ? false : true;
          el._misc.hasEntriesCount = vcomet.util.isTrue(el.entriesCount) ? true : false;

          if (!el._misc.hasEntriesCount) {
            el._refs.entriesCount.style.display = "none";
          }

        }

        el._setupPagination();

      },
      /*
      @function (private) _setupPagination
      @description Sets up the page selector to navigate through the pages
      */
      setupPagination: function () {

        var el = this;

        // If it has pagination then it sets it up depending on the type specified by the user
        if (el._misc.hasPagination) {

          if (el.pagination == "input") {
            el._setupInputPageSelector();
          } else {
            el._setupStripPageSelector();
          }

          el._setupNavigationButtons();

          // Else just removes it from the element
        } else {

          var pageControls = el.querySelector(".vc-grid-pagControls");
          pageControls.parentNode.removeChild(pageControls);

        }

      },
      /*
      @function (private) _setupStripPageSelector
      @description Sets up the page selector as a strip of page buttons
      */
      setupStripPageSelector: function () {

        var el = this;

        var stripPageSelector = document.createElement("div");
        var currentStripPage = document.createElement("div");

        stripPageSelector.classList.add("vc-grid-stripPageSelector");

        currentStripPage.id = "currentPage";
        currentStripPage.dataset.page = el._misc.currentPage;
        currentStripPage.innerHTML = el._misc.currentPage;
        currentStripPage.classList.add("vc-grid-currentPage", "vc-bg8", "vc-fg2", "vc-grid-stripPage", "vc-sect2-border-hoverable");

        stripPageSelector.appendChild(currentStripPage);

        el._refs.pageSelector.appendChild(stripPageSelector);
      },
      /*
      @function (private) _setupInputPageSelector
      @description Sets up the page selector as an input
      */
      setupInputPageSelector: function () {

        var el = this;

        var inputPageSelector = document.createElement("div");
        var pageInput = document.createElement("div");
        var separator = document.createElement("div");
        var totalPages = document.createElement("div");

        inputPageSelector.classList.add("vc-grid-inputPageSelector");

        pageInput.classList.add("pageInput");
        pageInput.setAttribute("contenteditable", "true");
        pageInput.innerHTML = 1;
        pageInput.onkeydown = function (e) {
          if (e.keyCode == 13) {
            e.stopPropagation();
            e.preventDefault();

            var page = parseInt(this.textContent);

            if (!isNaN(page)) {
              if (page > 0 && page <= el._getStoreDataLastPage()) {
                el._selectPage(page);
              }
            }
            this.blur();
          }
        };

        separator.classList.add("separator", "vc-unselectable");
        separator.innerHTML = "/";

        totalPages.classList.add("totalPages", "vc-unselectable");
        totalPages.innerHTML = el._misc.currentPage;

        inputPageSelector.appendChild(pageInput);
        inputPageSelector.appendChild(separator);
        inputPageSelector.appendChild(totalPages);

        el._refs.pageSelector.appendChild(inputPageSelector);
      },
      /*
      @function (private) _setupGridResizeHandler
      @description Called when the window is resized and will handle the according resizing functions
      */
      setupGridResizeHandler: function () {

        var el = this;

        vcomet.addResizeListener(el, el.nodeName.toLowerCase(), function () {

          if (!el._misc.isEditing) {

            if (el._misc.resizeTimeout != null) {
              clearTimeout(el._misc.resizeTimeout);
            }

            el._misc.resizeTimeout = setTimeout(function () {
              el._handleGridResize();
            }, 200);

          }

        });

      },
      /*
      @function (private) _setupHeaderHorizontalScroll
      @description Synchronizes the rows scroll with the headers to feel like its the same scroll
      */
      setupHeaderHorizontalScroll: function () {

        var el = this;

        el.vcometScroll.onScrolled(function (e) {
          el._refs.header.style.transform = "translate3d(" + -e.scrollLeft + "px, 0, 0)";
        });

      },
      /*
      @function (private) {Object} _generateDataFromDeclarativeRows
      @description Searches for rows declared by the user to elaborate our data object and returns it
      */
      generateDataFromDeclarativeRows: function () {

        var el = this;

        var storeData = {};
        var rows = el._misc.sourceFragment.querySelectorAll("vc-row");

        if (rows.length > 0) {

          var columns = el.columns.replace(/\s/g, '').split(',');
          var dataModel = {};
          var cells;

          // We create a data model based on the columns specified in the grid, this is done so that in case there is an entry missing one of the column values
          // we will be able to fill it with an empty one
          for (var i = 0; i < columns.length; i++) {
            dataModel[columns[i]] = "";
          }

          // For each row we loop through its cells and fill its data object
          for (var j = 0; j < rows.length; j++) {

            data = Object.assign({}, dataModel);
            data.entryid = j;

            cells = rows[j].querySelectorAll("vc-cell");

            for (var k = 0; k < cells.length; k++) {
              data[cells[k].getAttribute("column")] = cells[k].getAttribute("value");
            }

            storeData[j] = data;

          }

        }

        return storeData;

      },
      /*
      @function (private) _generateSourceFragment
      @description Takes all the source declared by the user and creates its own fragment to save it
      */
      generateSourceFragment: function () {
        this._misc.sourceFragment.appendChild(this.source);
      },
      /*
      @function (private) _defineDataSourceType
      @description Depending on what the user provided with the grid we will define the type of source we will use to fill our grid
      */
      defineDataSourceType: function () {

        var el = this;

        var store = this._misc.sourceFragment.querySelector("vc-store");
        var rows = this._misc.sourceFragment.querySelectorAll("vc-row");

        if (store) {

          el._misc.sourceType = "remote";
          el.appendChild(store);

        } else if (rows) {

          el._misc.sourceType = "inward";

        }

      },

      //HANDLE FUNCTIONS
      /*
      @function (private) _handleStoreEntries
      @description Manages the redirection to another function depending on the situation
      @param {String} responseType
      @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
      @param {Number} start
      @param {Number} limit
      */
      handleStoreEntries: function (responseType, cleanCurrentRange, start, limit) {

        var el = this;
        var handleFunction, dataSource, source;

        dataSource = (el.store.type == "memory" && el._misc.pageSizeType != "all") ? el.store.rangeData : el.store.data;
        source = (responseType == "object") ? dataSource.asObject() : dataSource.asArray();

        el._misc.range.start = start ? start : el._misc.range.start;
        el._misc.range.limit = limit ? limit : el._misc.range.limit;

        el._misc.range.limit = (el._misc.pageSizeType == "all") ? el.store.size : el._misc.range.limit;

        handleFunction = (responseType == "object") ? el._handleStoreEntriesAsObject : el._handleStoreEntriesAsArray;
        handleFunction.apply(el, [source, cleanCurrentRange]);

      },
      /*
      @function (private) _handleStoreSort
      @description Manages the redirection to another function depending on the situation
      @param {String} columnKey
      @param {Boolean} isDescending
      */
      handleStoreSort: function (columnKey, sortType) {

        var el = this;

        var cleanCurrentRange = true;
        var isDescending = sortType == "descending" ? true : false;
        var dataType = sortType != "none" ? "array" : "object";

        var sortCallback = function () {
          el._handleStoreEntries("array", cleanCurrentRange);
        };

        if (el.store.type == "rest") {

          el.store.sortRemote(columnKey, isDescending, sortCallback);

        } else {

          el.store.sortList(columnKey, isDescending);

          if (el._misc.pageSizeType !== "all") {
            // If we want the data raw, we send true as the third parameter
            el.store.getRange(el._misc.range.start, el._misc.range.limit, sortType == "none" ? true : false);

          }

          // Here we call the handleStoreEntries function, after requesting sort and range
          el._handleStoreEntries(dataType, cleanCurrentRange);

        }
      },
      /*
      @function (private) _handleStoreRange
      @description Manages the redirection to another function depending on the situation
      @param {Number} start
      @param {Number} limit
      @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
      */
      handleStoreRange: function (start, limit, cleanCurrentRange) {

        var el = this;

        el._misc.range.start = start;
        el._misc.range.limit = limit;

        if (el.store.type == "memory") {

          el.store.getRange(start, limit);
          el._handleStoreEntries(el.store.data.__sorted ? "array" : "object", cleanCurrentRange, start, limit);

        } else {

          el.store.getRangeRemote(start, limit, function () {
            el._handleStoreEntries("object", cleanCurrentRange, start, limit);
          });
        }
      },
      /*
      @function (private) _handleStoreEntriesAsObject
      @description Handles the store data that is returned as an object
      @param {Object} storeData
      @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
      */
      handleStoreEntriesAsObject: function (storeData, cleanCurrentRange) {

        var el = this;

        var columnsKeys = Object.keys(el._misc.columns);
        var rowsDocFragment = document.createDocumentFragment();
        var entriesCount = Object.keys(storeData).length;
        var dataObject;
        var row;
        var cell;
        var eventObject;

        if (cleanCurrentRange) {
          el._refs.rowsWrapper.innerHTML = "";
          el._resetEntriesCount();
        }

        //for each dataObject in the storeData we create a Row
        for (var key in storeData) {
          dataObject = storeData[key];

          row = document.createElement("vc-row");
          row.classList.add("vc-grid-entryRow", "vc-bg1-hoverable3", "vc-bg1-border2");
          row.dataset.entryId = dataObject[el.store.idProperty];

          //For each column we have in the grid we will look for its value on the dataObject
          // and create a cell, this way if a dataObject doesnt have a columnKey it will still have the cell but it will be an empty one
          for (var i = 0; i < columnsKeys.length; i++) {

            cell = el._createCell(columnsKeys[i], dataObject, storeData);
            row.appendChild(cell);

          }

          if (el.autofit == "true" || el.autofit == true) {

            row.classList.add("vc-grid-autofit");

          } else {

            row.style.minHeight = el.rowMinHeight + "px";
          }

          el._increaseEntriesCount();

          rowsDocFragment.appendChild(row);

          // Creates the callback event object for the user
          eventObject = {

            data: dataObject,
            row: row

          };

          vcomet.triggerCallback("onRowCreated", el, el, [eventObject]);

        };

        el._refs.rowsWrapper.appendChild(rowsDocFragment);
        
        if (el._misc.pageSizeType == "auto") {
          el._handleRowsLayout(entriesCount)
        };
      },
      /*
      @function (private) _handleStoreEntriesAsObject
      @description Handles the store data that is returned as an array
      @param {Array} storeData
      @param {Boolean} cleanCurrentRange [Whether it has to clean the current page or not]
      */
      handleStoreEntriesAsArray: function (storeData, cleanCurrentRange) {

        var el = this;

        var columnsKeys = Object.keys(el._misc.columns);
        var rowsDocFragment = document.createDocumentFragment();
        var entriesCount = storeData.length;
        var dataObject;
        var row;
        var cell;

        if (cleanCurrentRange) {
          el._refs.rowsWrapper.innerHTML = "";
        }

        el._resetEntriesCount();

        //for each dataObject in the storeData we create a Row
        for (var i = 0; i < entriesCount; i++) {
          dataObject = storeData[i];

          row = document.createElement("vc-row");
          row.classList.add("vc-grid-entryRow", "vc-bg1-hoverable3", "vc-bg1-border2");
          row.dataset.entryId = dataObject[el.store.idProperty];

          //For each column we have in the grid we will look for its value on the dataObject
          // and create a cell, this way if a dataObject doesn't have a columnKey it will still have the cell but it will be an empty one
          for (var j = 0; j < columnsKeys.length; j++) {

            cell = el._createCell(columnsKeys[j], dataObject, storeData);
            row.appendChild(cell);

          }

          if (el.autofit == "true" || el.autofit == true) {

            row.classList.add("vc-grid-autofit");

          } else {

            row.style.minHeight = el.rowMinHeight + "px";
          }

          el._increaseEntriesCount();

          rowsDocFragment.appendChild(row);
        }
        el._refs.rowsWrapper.appendChild(rowsDocFragment);
        
        if (el._misc.pageSizeType == "auto") {
          el._handleRowsLayout(entriesCount)
        };
      },
      /*
      @function (private) _createCell
      @description Handles the cell creation and if the user has specified the grid as editable it will add its corresponding events
      @param {String} columnKey
      @param {Object} dataObject
      @param {Object} storeData
      */
      createCell: function (columnKey, dataObject, storeData) {

        var el = this;
        var cell = document.createElement("vc-cell");
        var editableColumns, eventObject;

        if (dataObject[columnKey]) {
          cell.setAttribute("value", dataObject[columnKey]);
        }

        cell.setAttribute("column", columnKey);
        cell.dataset.entryId = dataObject[el.store.idProperty];

        if (vcomet.util.isTrue(el.editable)) {

          editableColumns = el.columns.replace(/\s/g, '').split(',');

        } else {

          if (el.editable != "false" && el.editable != false) {
            editableColumns = el.editable.replace(/\s/g, '').split(',');
          }

        }

        if (editableColumns && editableColumns.indexOf(columnKey) > -1) {

          cell.onReady(function () {

            var cellContent = this.querySelector(".vc-grid-cellContent");

            cellContent.setAttribute("contenteditable", "true");
            cellContent.spellcheck = false;

            // This is ment for mobile devices: When entering edit mode the keyboard will trigger grid resize, 
            // setting this property to true will prevent resize from triggering in those situation
            cellContent.addEventListener("focus", function (e) {
              el._misc.isEditing = true;
            });

            // Keydown event that will be aware for the enter key, to blur the cell
            cellContent.addEventListener("keydown", function (e) {

              if (e.key.toLowerCase() == "enter") {
                cellContent.blur();
              }

            });

            // Blur event that will trigger the entry update
            cellContent.addEventListener("blur", function (e) {

              var cell = this.parentNode;
              var entryId = cell.dataset.entryId;
              var column = cell.getAttribute("column");

              // We only want to update if the value has changed
              if (cell.value != cellContent.textContent) {

                cell.value = cellContent.textContent;
                el._updateEntry(entryId, column, cellContent.textContent);

              }

              el._misc.isEditing = false;

            });

          });

        }

        // Creates the callback event object for the user
        eventObject = {

          data: dataObject,
          column: columnKey,
          cell: cell

        };

        vcomet.triggerCallback("onCellCreated", el, el, [eventObject]);

        return cell;

      },
      /*
      @function (private) _updateEntry
      @description Updates the requested entry for the calumn change
      @param {Object} data
      @param {String} entryId
      @param {String} column
      @param {String} value
      */
      updateEntry: function (entryId, column, value) {
        var el = this;
        var dataSource, source;

        // TODO: Handle update entry on "Rest" store type
        dataSource = (el.store.type == "memory" && el._misc.pageSizeType != "all") ? el.store.rangeData : el.store.data;
        data = dataSource.asObject();

        data[entryId][column] = value;

        vcomet.triggerCallback("onEdit", el, el, [entryId, column, value]);

      },
      /*
      @function (private) _handleRowsLayout
      @description Handles everything autofit rows related, the paginations, its sizes...
      @param {Number} entriesCount
      */
      handleRowsLayout: function (entriesCount) {

        var el = this;
        var rowsCapacity = el._getRowsCapacity();
        
        //We will only do stuff when the rowsCapacity is bigger than one.
        //One row will be the smallest number of rows possible, we will not allow pages with no rows
        if (rowsCapacity >= 1) {

          var existingDummiesCount = el.querySelectorAll(".vc-grid-dummyRow").length;
          var totalPageRows = existingDummiesCount + entriesCount;
          var dummyRowsAmount = rowsCapacity - entriesCount;

          //If there are more rows than the capacity that we have we will remove an amount of rows
          //until we match our capacity, the removal starts from the last one
          if (rowsCapacity < totalPageRows) {

            var rowsAmountDifference = totalPageRows - rowsCapacity;
            var rows = el._refs.rowsWrapper.querySelectorAll(".vc-grid-entryRow, .vc-grid-dummyRow");
            var rowsLength = rows.length;
            var lastRowIndex;

            for (var i = rowsAmountDifference; i > 0; i--) {
              lastRowIndex = rowsLength - 1;

              if (rows[lastRowIndex].classList.contains("vc-grid-entryRow")) {
                el._decreaseEntriesCount();
              }

              el._refs.rowsWrapper.removeChild(el._refs.rowsWrapper.querySelectorAll(".vc-grid-entryRow, .vc-grid-dummyRow")[lastRowIndex]);
              rowsLength--;
            }

            //If we have more capacity than actual rows displayed then we will fill the page with dummies
          } else if (rowsCapacity > totalPageRows) {
            
            var dummyDocFragment = document.createDocumentFragment();
            var newDummiesCount = dummyRowsAmount - existingDummiesCount;
            var dummyRow;

            for (var i = 0; i < newDummiesCount; i++) {
              dummyRow = document.createElement("div");
              dummyRow.classList.add("vc-grid-autofit", "vc-grid-dummyRow");
              dummyDocFragment.appendChild(dummyRow);
            }

            el._refs.rowsWrapper.appendChild(dummyDocFragment);
          }

          //If ourpageSize is different from the actual amount of rows we can have, we will handle
          //different calls to reload the page with the data corresponding to the page
          if (el.pageSize != rowsCapacity) {
            var currentPage = parseInt(el._misc.currentPage);
            var newPage;

            el.pageSize = rowsCapacity;

            newPage = currentPage > el._getStoreDataLastPage() ? el._getStoreDataLastPage() : currentPage;

            el._selectPage(newPage);

          }
        }
      },
      /*
      @function (private) _handleNavigability
      @description Handles the navigability buttons to be enabled/disabled depending on the situation
      */
      handleNavigability: function () {

        var el = this;

        var currentPage = parseInt(el._misc.currentPage);
        var pageSize = parseInt(el.pageSize);
        var lastPage = el._getStoreDataLastPage();

        var firstPageButton = el.querySelector('[data-navigation = "first"]');
        var previousPageButton = el.querySelector('[data-navigation = "previous"]');
        var nextPageButton = el.querySelector('[data-navigation = "next"]');
        var lastPageButton = el.querySelector('[data-navigation = "last"]');

        if (currentPage == 1) {

          el._disableNavigationbutton(firstPageButton);
          el._disableNavigationbutton(previousPageButton);

          if (lastPage == 1) {

            el._disableNavigationbutton(nextPageButton);
            el._disableNavigationbutton(lastPageButton);

          } else {

            el._enableNavigationButton(nextPageButton);
            el._enableNavigationButton(lastPageButton);
          }

        } else {

          el._enableNavigationButton(firstPageButton);
          el._enableNavigationButton(previousPageButton);

          if (currentPage == lastPage) {

            el._disableNavigationbutton(nextPageButton);
            el._disableNavigationbutton(lastPageButton);

          } else {
            el._enableNavigationButton(nextPageButton);
            el._enableNavigationButton(lastPageButton);
          }
        }
      },
      /*
      @function (private) _handleColumnsResize
      @description Handles the resize of the columns
      @param {Object} e [event]
      */
      handleColumnResize: function (e) {

        var el = this;

        var headerOrder = parseInt(el._misc.columns[el._misc.resize.header.column].order);
        var columnRule = el._misc.columns[el._misc.resize.header.column].rule;

        var resizeIndicatorLeftPosition = el._misc.resize.indicator.getBoundingClientRect().left;
        var resizeIndicatorRightPosition = el._misc.resize.indicator.offsetWidth + resizeIndicatorLeftPosition;

        var nextSiblingOrder = headerOrder + 1;
        var previousSiblingOrder = headerOrder - 1;

        var contentWidth = el._refs.header.offsetWidth;
        var remainingSpace = el._refs.header.offsetWidth;

        var newHeaderMinWidth = 0;
        var columnWidth;

        //For each header/column we have we loop to set its css properties in case its the first time we resize,
        //also we will be calculating the remainingSpace
        for (var i = 0; i < el._misc.resize.headers.length; i++) {

          if (el._misc.resize.headers[i].column != el._misc.resize.header.column) {

            columnWidth = Math.ceil(parseInt(el._misc.columns[el._misc.resize.headers[i].column].rule.style.minWidth.split("px")[0]));
            remainingSpace = remainingSpace - columnWidth;
            newHeaderMinWidth = newHeaderMinWidth + columnWidth;
          }
        }

        var difference;
        var finalWidth;

        //Here we will see if the mouse is on the left or right and calculate the difference
        if (e.clientX < resizeIndicatorRightPosition) {
          difference = resizeIndicatorRightPosition - e.clientX;
          finalWidth = el._misc.resize.header.offsetWidth - difference;
        } else if (e.clientX > resizeIndicatorRightPosition) {
          difference = e.clientX - resizeIndicatorRightPosition;
          finalWidth = el._misc.resize.header.offsetWidth + difference;
        }

        finalWidth = (finalWidth < el.columnMinWidth) ? el.columnMinWidth : finalWidth;
        remainingSpace = remainingSpace - finalWidth;

        columnRule.style.flexBasis = 0;
        columnRule.style.flexGrow = 0;
        columnRule.style.minWidth = finalWidth + "px";

        newHeaderMinWidth = parseInt(newHeaderMinWidth) + parseInt(finalWidth);

        if (newHeaderMinWidth > contentWidth) {
          el._refs.headersWrapper.style.minWidth = newHeaderMinWidth + "px";
          el._refs.rowsWrapper.style.minWidth = newHeaderMinWidth + "px";
        } else {
          el._refs.headersWrapper.style.minWidth = contentWidth + "px";
          el._refs.rowsWrapper.style.minWidth = newHeaderMinWidth + "px";
        }

        var headersWrapperWidth = el._refs.headersWrapper.offsetWidth;

        //If the headersWrapper is smaller than the contentWidth we equal the headersContaienr width and
        //add the remainingSpace to the last column
        if (headersWrapperWidth <= contentWidth) {

          var sibling = el._refs.headersWrapper.querySelector('vc-cell[order="' + nextSiblingOrder + '"]');

          if (!sibling) {
            sibling = el._refs.headersWrapper.querySelector('vc-cell[order="' + previousSiblingOrder + '"]');
          }

          el._misc.columns[sibling.column].rule.style.minWidth = parseInt(sibling.offsetWidth) + parseInt(remainingSpace) + "px";
        }

        // While we are resizing we want the scrolls to resize aswell
        el.vcometScroll.update();

      },
      /*
      @function (private) _handleColumnResizeStop
      @description Handles the end of the column resize
      @param {Object} e [event]
      */
      handleColumnResizeStop: function (e) {

        var el = this;

        var columnRule = el._misc.columns[el._misc.resize.header.column].rule;

        //At the end of the resizing event we remove the header resizing indicator
        var headersWithResizingClass = el._refs.headersWrapper.querySelectorAll(".vc-grid-resizingHeader");
        for (var i = 0; i < headersWithResizingClass.length; i++) {
          headersWithResizingClass[i].classList.remove("vc-grid-resizingHeader", "vc-bg1-hoverable3");
        }

        columnRule.style.minWidth = el._misc.resize.header.offsetWidth + "px";
        el._removeResizeOverlay();
        el._misc.resize.active = false;

      },
      /*
      @function (private) _handleGridResize
      @description Handles the grid inner sizes when resizing the window
      */
      handleGridResize: function () {

        var el = this;

        var contentWidth = el._refs.header.offsetWidth;
        var headersWrapperWidth = el._refs.headersWrapper.offsetWidth;

        if (headersWrapperWidth < contentWidth) {

          var remainingSpace = contentWidth - headersWrapperWidth;
          var headers = el._refs.headersWrapper.querySelectorAll("vc-cell");
          var lastHeader = headers[(headers.length - 1)];

          var lastHeaderActualWidth = parseInt(el._misc.columns[lastHeader.column].rule.style.minWidth.split("px")[0]);
          el._misc.columns[lastHeader.column].rule.style.minWidth = lastHeaderActualWidth + remainingSpace + "px";
        }
        
        if (el._misc.pageSizeType == "auto") {
          el._handleRowsLayout(el._misc.entriesCount);
        }

      },
      /*
      @function (private) _createResizeOverlay
      @description Creates an overlay when resizing the columns
      */
      createResizeOverlay: function () {

        var el = this;
        var existingOverlay = document.querySelector("#resizeOverlay");

        if (!existingOverlay) {
          var overlay = document.createElement("div");

          overlay.id = "resizeOverlay";
          overlay.style.position = "absolute";
          overlay.style.top = 0;
          overlay.style.bottom = 0;
          overlay.style.right = 0;
          overlay.style.left = 0;
          overlay.style.backgroundColor = "transparent";
          overlay.style.cursor = "col-resize";
          overlay.classList.add("vc-unselectable");

          document.body.appendChild(overlay);

          el._refs.headersWrapper.classList.add("vc-unselectable");
          el._refs.rowsWrapper.classList.add("vc-unselectable");
          el._refs.footer.classList.add("vc-unselectable");
        }
      },
      /*
      @function (private) _removeResizeOverlay
      @description Removes the overlay after the column resize is over
      */
      removeResizeOverlay: function () {

        var el = this;
        var overlay = document.body.querySelector("#resizeOverlay");

        if (overlay) {
          overlay.parentNode.removeChild(overlay);
        }

        el._refs.headersWrapper.classList.remove("vc-unselectable");
        el._refs.rowsWrapper.classList.remove("vc-unselectable");
        el._refs.footer.classList.remove("vc-unselectable");
      },
      /*
      @function (private) _resizeColumn
      @description First action when clicking to resize, sets up some information and actions before the actual resize function is called when moving the mouse
      @param {Object} resizeIndicator
      */
      resizeColumn: function (resizeIndicator) {

        var el = this;

        el._misc.resize.header = resizeIndicator.parentNode;
        el._misc.resize.indicator = resizeIndicator;
        el._misc.resize.active = true;

        if (el._misc.resize.firstTime == true) {

          el._misc.resize.headers = el._refs.headersWrapper.querySelectorAll("vc-cell");
          el._misc.resize.firstTime = false;

          var headerWidth;

          for (var i = 0; i < el._misc.resize.headers.length; i++) {

            if (el._misc.resize.headers[i].column != el._misc.resize.header.column) {

              headerWidth = window.getComputedStyle(el._misc.resize.headers[i]).width.split("px")[0];

              el._misc.columns[el._misc.resize.headers[i].column].rule.style.minWidth = headerWidth + "px";
              el._misc.columns[el._misc.resize.headers[i].column].rule.style.flexGrow = 0;
              el._misc.columns[el._misc.resize.headers[i].column].rule.style.flexBasis = headerWidth + "px";
            }
          }

          window.addEventListener("mousemove", function (e) {

            if (el._misc.resize.active == true && e.clientX != el._misc.resize.initialPosition.x) {

              e.stopPropagation();
              e.preventDefault();

              el._handleColumnResize(e);

            }

          });

          window.addEventListener("mouseup", function (e) {

            e.stopPropagation();
            e.preventDefault();

            if (el._misc.resize.active == true) {
              el._handleColumnResizeStop(e);
            }

          });

        }

        //We create an overlay so that while resizing we dont select text and hover over other elements,
        //this overlay will be removed on resizeStop
        el._createResizeOverlay();

        //We add a class to the header of the columns we are resizing as an indicator
        el._misc.resize.header.classList.add("vc-grid-resizingHeader", "vc-bg1-hoverable3");
      },
      /*
      @function (private) _sortEntries
      @description Redirects the sort call depending on the situation, it also toggles the icon
      @param {Object} e [event]
      @param {Object} header
      */
      sortEntries: function (e, header) {

        if (e.target != header.querySelector(".vc-grid-resizeIndicator")) {

          var el = this;

          var sortType = el._getSortTypeForHeader(header);

          el._handleHeadersChange(header, sortType);
          el._handleSort(header.column, sortType);

        }
      },
      handleSort: function (column, sortType) {

        var el = this;

        el._handleStoreSort(column, sortType);

      },
      /*
      @function (private) _resetHeadersSort
      @description Resets all the sorted headers, it does nothing in the clicked header
      @param {Object} header
      */
      handleHeadersChange: function (header, sortType) {

        var el = this;

        var sortedHeaders = el._refs.headersWrapper.querySelectorAll('vc-cell[sort="descending"], vc-cell[sort="ascending"]');
        var icon = "";

        if (sortType != "none") {
          icon = "keyboard_arrow_" + (sortType == "descending" ? "down" : "up");
        }

        header.querySelector("i").innerHTML = icon;
        header.setAttribute("sort", sortType);

        for (var i = 0; i < sortedHeaders.length; i++) {
          if (!sortedHeaders[i].isEqualNode(header)) {
            headerIcon = sortedHeaders[i].querySelector("i");
            sortedHeaders[i].sort = "none";
            headerIcon.innerHTML = "";
          }
        }

      },
      /*
      @function (private) {String} _getSortTypeForHeader
      @description Takes the header and returns the corresponding sort type 
      @param {Object} header
      */
      getSortTypeForHeader: function (header) {

        var currentSort = header.getAttribute("sort");
        var sortType;

        if (currentSort == "none") {

          sortType = "descending";

        } else {

          sortType = currentSort == "descending" ? "ascending" : "none";

        }

        return sortType;

      },
      /*
      @function (private) _navigate
      @description Called from the navigation buttons to navigate through the pages
      @param {Object} button 
      */
      navigate: function (button) {

        if (button.dataset.enabled == "true" || button.dataset.enabled == true) {

          var el = this;

          var navigation = button.dataset.navigation;
          var currentPage = parseInt(el._misc.currentPage);
          var pageSize = parseInt(el.pageSize);
          var start;
          var limit;

          switch (navigation) {
            case "first":
              start = 1;
              limit = parseInt(start + pageSize - 1);

              el._handleStoreRange(start, limit, true);
              el._updatePages(1);
              break;
            case "previous":
              var previousPage = currentPage - 1;

              start = parseInt(((previousPage - 1) * pageSize) + 1);
              limit = parseInt(start + pageSize - 1);

              if (previousPage >= 1) {
                previousPage = (previousPage < 1) ? 1 : previousPage;
                el._handleStoreRange(start, limit, true);
                el._updatePages(previousPage);
              }
              break;
            case "next":
              var nextPage = currentPage + 1;

              start = parseInt((nextPage - 1) * pageSize + 1);
              limit = parseInt(start + pageSize - 1);

              if (nextPage <= el._getStoreDataLastPage()) {
                el._handleStoreRange(start, limit, true);
                el._updatePages(nextPage);
              }
              break;
            case "last":
              var lastPage;

              limit = el.store.size;
              lastPage = el._getStoreDataLastPage();
              start = parseInt(((lastPage * pageSize) - pageSize) + 1);

              if (lastPage > 0) {
                el._handleStoreRange(start, limit, true);
                el._updatePages(lastPage);
              }
              break;
            default:

          }
        }
      },
      /*
      @function (private) _disableNavigationButton
      @description Disables a navigation button
      @param {Object} button
      */
      disableNavigationbutton: function (button) {
        button.classList.add("vc-grid-disabled");
        button.dataset.enabled = "false";
      },
      /*
      @function (private) _disableNavigationButton
      @description Enables a navigation button
      @param {Object} button
      */
      enableNavigationButton: function (button) {
        button.classList.remove("vc-grid-disabled");
        button.dataset.enabled = "true";
      },
      /*
      @function (private) _createPagesForPagesStrip
      @description Creates the pages for the strip page selector
      */
      createPagesForPagesStrip: function () {

        var el = this;
        var currentPage = el._misc.currentPage;
        var pageSize = parseInt(el.pageSize);
        var pageCount = el._getStoreDataLastPage();
        var pageItemsDocFragment = document.createDocumentFragment();
        var pageItem;

        var pagesToCreate = [];

        el.querySelector(".vc-grid-stripPageSelector").innerHTML = "";

        var loopStart;
        var loopEnd;

        if (pageCount > 5) {
          if (currentPage == pageCount) {

            loopStart = parseInt(currentPage) - 4;
            loopEnd = parseInt(currentPage);

          } else if (currentPage > 2) {

            if (currentPage == (pageCount - 1)) {

              loopStart = parseInt(currentPage) - 3;
              loopEnd = parseInt(currentPage) + 1;

            } else {

              loopStart = parseInt(currentPage) - 2;
              loopEnd = parseInt(currentPage) + 2;
            }
          } else if (currentPage == 2) {

            loopStart = parseInt(currentPage) - 1;
            loopEnd = parseInt(currentPage) + 3;

          } else {

            loopStart = 1;
            loopEnd = 5;
          }
        } else {

          loopStart = 1;
          loopEnd = parseInt(pageCount);
        }

        for (var page = loopStart; page <= loopEnd; page++) {
          pagesToCreate.push(parseInt(page));
        }

        for (var i = 0; i < pagesToCreate.length; i++) {

          pageItem = document.createElement("div");

          pageItem.classList.add("vc-grid-stripPage", "vc-sect2-border-hoverable");
          pageItem.dataset.page = pagesToCreate[i];
          pageItem.innerHTML = pagesToCreate[i];
          pageItem.onclick = function () {
            el._selectPage(this.dataset.page, this.getAttribute('selected'))
          };
          pageItem.setAttribute("selected", "false");

          if (currentPage == pagesToCreate[i]) {
            pageItem.id = "currentPage";
            pageItem.classList.add("vc-grid-currentPage", "vc-sect2-hoverable", "vc-fg1");
            pageItem.setAttribute("selected", "true");
          }
          pageItemsDocFragment.appendChild(pageItem);
        }

        el.querySelector(".vc-grid-stripPageSelector").appendChild(pageItemsDocFragment);
      },
      /*
      @function (private) _updatePageSelector
      @description Redirects the call depending on the page selector
      @param {Number} page
      */
      updatePageSelector: function (page) {

        var el = this;

        if (el.pagination == "strip") {

          el._updateStripPageSelector(page);

        } else if (el.pagination == "input") {

          el._updateInputPageSelector(page);
        }

      },
      /*
      @function (private) _updateStripPageSelector
      @description Updates strip page selector
      @param {Number} page
      */
      updateStripPageSelector: function (page) {

        var el = this;

        var pageSelector = el._refs.pageSelector;
        var previousSelectedPage = pageSelector.querySelector('[selected="true"]');
        var newPageToSelect = pageSelector.querySelector('[data-page="' + page + '"]');

        if (previousSelectedPage) {
          previousSelectedPage.classList.remove("vc-grid-currentPage", "vc-sect2-hoverable", "vc-fg1");
          previousSelectedPage.setAttribute("selected", "false");
        }

        if (newPageToSelect) {
          newPageToSelect.classList.add("vc-grid-currentPage", "vc-sect2-hoverable", "vc-fg1");
          newPageToSelect.setAttribute("selected", "true");
        }

      },
      /*
      @function (private) _updateInputPageSelector
      @description Updates input page selector
      @param {Number} page
      */
      updateInputPageSelector: function (page) {

        var el = this;

        var pageSelector = el._refs.pageSelector;
        var pageInput = pageSelector.querySelector('.pageInput');
        var totalPages = pageSelector.querySelector('.totalPages');

        totalPages.classList.add("totalPages");
        pageInput.innerHTML = page;
        totalPages.innerHTML = el._getStoreDataLastPage();

      },
      /*
      @function (private) _selectPage
      @description Selects a page
      @param {Number} selectedPage
      @param {Boolean} isSelected
      */
      selectPage: function (selectedPage, isSelected) {

        if (isSelected == false || isSelected == "false" || typeof isSelected == "undefined") {

          var el = this;

          var pageSize = parseInt(el.pageSize);
          var rangeLimit = (parseInt(selectedPage) * pageSize);
          var rangeStart = rangeLimit - pageSize + 1;

          el._handleStoreRange(rangeStart, rangeLimit, true);
          el._updatePages(selectedPage);

        }
      },
      /*
      @function (private) _updatePaged
      @description Updates pageSelectors and the navigability buttons
      @param {Number} page
      */
      updatePages: function (page) {

        var el = this;

        el._misc.currentPage = page;

        if (el._misc.hasPagination) {

          if (el.pagination == "strip") el._createPagesForPagesStrip();

          el._updatePageSelector(page);
          el._handleNavigability();

        }

      },
      /*
      @function (private) _increaseEntriesCount
      @description Increases the entries count
      */
      increaseEntriesCount: function () {

        var el = this;
        
        el._misc.entriesCount++;
        el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";
      },
      /*
      @function (private) _decreaseEntriesCount
      @description Decrease the entries count
      */
      decreaseEntriesCount: function () {

        var el = this;

        el._misc.entriesCount--;
        el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";
      },
      /*
      @function (private) _resetEntriesCount
      @description Resets the count of the entries
      */
      resetEntriesCount: function () {

        var el = this;
        
        el._misc.entriesCount = 0;
        el._refs.entriesCount.innerHTML = el._misc.entriesCount + " entries";

      },
      /*
      @function (private) _getStoreDataLastPage
      @description Gets the current last page depending on the store size
      */
      getStoreDataLastPage: function () {

        var el = this;

        if (el._misc.pageSizeType == "all" && typeof el.store.size == "undefined") {
          return 1;
        }

        return Math.ceil(parseInt(el.store.size) / parseInt(el.pageSize));
      },
      /*
      @function (private) _getRowsCapacity
      @description Gets the current rows capacity
      */
      getRowsCapacity: function () {

        var el = this;
        var rowsWrapperHeight = (parseInt(el._refs.rowsWrapper.offsetHeight) == 0) ? (el.offsetHeight - (el._refs.header.offsetHeight + el._refs.footer.offsetHeight)) : el.offsetHeight;
        
        return Math.floor(rowsWrapperHeight / parseInt(el.rowMinHeight));
      },
      /*
      @function (private) {Object}  _createPageEventObject
      @description Returns an object with information about the current grid page
      */
      createPageEventObject: function () {

        var el = this;

        var eventObject = {

          currentPage: parseInt(el._misc.currentPage),
          totalPages: el._getStoreDataLastPage(),
          currentEntries: el._misc.entriesCount,
          totalEntries: parseInt(el.store.size),

          currentRange: {
            start: el._misc.range.start,
            end: el._misc.range.limit
          }

        }

        return eventObject;

      }
    },

    functions: {

      /*
      @function setData
      @description Takes the provided data object and uses it to fill the grid
      @param {Object} data
      */
      setData: function (data) {

        var el = this;
        var dataInstance = data.constructor === Array ? data[0] : data[Object.keys(data)[0]]

        // If the object provided doesnt have our idproperty we set it based on the order in which the entries of the object were given
        if (!dataInstance.hasOwnProperty(el.store.idProperty)) {

          var dataKeys = Object.keys(data);

          for (var i = 0; i < dataKeys.length; i++) {
            data[dataKeys[i]][el.store.idProperty] = i;
          }

        }

        // Once the store has loaded we set its data and call our callbacks
        el.store.onLoaded(function () {

          el.store.setData(data);
          el.store.getRange(1, el.pageSize);

          // Here we will update the grid in different ways depending on the pageSizeType
          if (el._misc.pageSizeType == "auto") {

            var dataSource = (el.store.type == "memory" && el._misc.pageSizeType != "all") ? el.store.rangeData : el.store.data;
            
            el._handleRowsLayout(Object.keys(dataSource.asObject()).length);

          } else {

            el._selectPage(1);

          };

        });

      },
      /*
      @function (private) {Object}  _next
      @description Navigates to the next grid page
      */
      next: function () {

        var el = this;

        var currentPage = parseInt(el._misc.currentPage);
        var nextPage;

        nextPage = currentPage + 1;
        nextPage = nextPage > el._getStoreDataLastPage() ? el._getStoreDataLastPage() : nextPage;

        el._selectPage(nextPage);

        return el._createPageEventObject();

      },
      /*
      @function (private) {Object}  _previous
      @description Navigates to the previous grid page
      */
      previous: function () {

        var el = this;

        var currentPage = parseInt(el._misc.currentPage);
        var previousPage;

        previousPage = currentPage - 1;
        previousPage = previousPage < 1 ? 1 : previousPage;

        el._selectPage(previousPage);

        return el._createPageEventObject();

      },
      /*
      @function (private) {Object}  _first
      @description Navigates to the first grid page
      */
      first: function () {

        var el = this;

        el._selectPage(1);

        return el._createPageEventObject();

      },
      /*
      @function (private) {Object}  _last
      @description Navigates to the last grid page
      */
      last: function () {

        var el = this;

        el._selectPage(el._getStoreDataLastPage());

        return el._createPageEventObject();

      },
      /*
      @function (private) {Object}  _goTo
      @param {Number} page
      @description Navigates to the requested grid page
      */
      goTo: function (page) {

        var el = this;

        page = parseInt(page);

        if (!isNaN(page)) {

          page = page < 1 ? 1 : page;
          page = page > el._getStoreDataLastPage() ? el._getStoreDataLastPage() : page;

          el._selectPage(page);

          return el._createPageEventObject();

        }

      },



    },

    onCreated: function () {

      var el = this;

      el._setupMisc();
      el._generateSourceFragment();
      el._defineDataSourceType();

      vcomet.createCallback("onCellCreated", el);
      vcomet.createCallback("onRowCreated", el);
      vcomet.createCallback("onEdit", el);

    },
    onInit: function () {

      var el = this;

      // ** Apply default items positioning style
      el._setDefaultStyle();

    },

    onBubbleRender: function () {

      var el = this;
      var sourceNodes = el.getSourceElements();

      el.classList.add("vc-bg1", "vc-boxshadow1");

      el._setupRefs();

      el._setupColumns();
      el._setupHeaders();

      el._setupPageSize();
      el._setupContent();

      el._setupFooter();

      el._setupAutofit();
      el._setupGridResizeHandler();
      el._setupHeaderHorizontalScroll();

    }
  });

</script>