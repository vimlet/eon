<script type="text/javascript">
  vcomet.element("vc-swiper", {
    themed: true,
    privateProperties: {
      /*
        @property (private) {String} sizeProperty
        @description Slide size property depending on swiper direction
      */
      sizeProperty: {
        value: "offsetWidth"
      },
      /*
        @property (private) {String} styleSizeProperty
        @description Slide size style property
      */
      styleSizeProperty: {
        value: "width"
      },
      /*
        @property (private) {Number} thumbnailSize
        @description Slide thumbnail size value
      */
      thumbnailSize: {
        value: 0
      },
      /*
        @property (private) {Number} maxTranslation
        @description Maximum translate value allowed
      */
      maxTranslation: {
        value: ""
      },
      /*
        @property (private) {Number} minPagingTranslation
        @description Minimum translate value allowed on pagination node
      */ 
      minPagingTranslation: {
        value: ""
      },
      /*
        @property (private) {Number} maxPagingTranslation
        @description Maximum translate value allowed on pagination node
      */ 
      maxPagingTranslation: {
        value: ""
      },
      /*
        @property (private) {Boolean} selectElement
        @description Prevent thumbnails selection on pagination shift
      */ 
      selectElement: {
        value: true
      },
      /*
        @property (private) {Boolean} selectElement
        @description Prevent thumbnails selection on pagination shift
      */ 
      styleSheet: {
        value: {}
      }
    },
    properties: {
      /*
        @property {String} type
        @description Swiper type
        Values: slider, gallery
        Default: slider
      */
      type: {
        value: "slider",
        reflect: true
      },
      /*
        @property {String} direction
        @description Slides direction movement
        Values: horizontal, vertical
        Default: horizontal
      */
      direction: {
        value: "horizontal",
        reflect: true
      },
      /*
        @property {Boolean} externalSlide
        @description Denied slide by touching
      */
      externalSlide: {
        value: false,
        reflect: true
      },
      /*
        @property {Object} wrapper
        @description Quick access to the slides wrapper node
      */
      wrapper: {
        value: {}
      },
      /*
        @property {Object} pagingNode
        @description Quick access to the thumbnails container node
      */
      pagingNode: {
        value: {}
      },
      /*
        @property {String} pagination
        @description Pagination type
        Values: filled, hideable
        Default: filled
      */
      pagination: {
        value: "filled", // (filled), hideable
        reflect: true
      },
      /*
        @property {Boolean} navigation
        @description Whether or not navigation buttons should be displayed
      */
      navigation: {
        value: false,
        reflect: true
      },
      /*
        @property {Array} slides
        @description Slides nodes and their translate ranges
      */
      slides: {
        value: []
      },
      /*
        @property {Array} thumbnails
        @description Thumbnails nodes and their translate ranges
      */
      thumbnails: {
        value: []
      },
      /*
        @property {Number} initialSlide
        @description Initial displayed slide index
      */
      initialSlide: {
        value: 0,
        reflect: true
      },
      /*
        @property {Object} currentSlide
        @description Slide which the view is focused on
      */
      currentSlide: {
        value: {},
        observe: true
      },
      /*
        @property {Number} slideDistance
        @description Slide translate pixels amount for each pixel move by the mouse
      */
      slideDistance: {
        value: 1
      },
      /*
        @property {Number} thumbnailDistance
        @description Translate pixels amount for each pixel move by the mouse on pagination node
      */
      thumbnailDistance: {
        value: 2
      },  
      /*
        @property {Array} excludedSliders
        @description Nodes not allowed to act as sliders
      */
      excludedSliders: {
        value: "",
        reflect: true
      },
      /*
        @property {Boolean} fullScreen
        @description Whether or not the swiper should have full screen mode
      */
      fullScreen: {
        value: false,
        reflect: true
      }
    },
    privateFunctions: {
      /*
        @function (private) _setUp
        @description Configure swiper
      */
      setUp: function() {
        var el = this;
        // Check swiper type
        if(el.type == "gallery"){
          el.classList.add("vc-swiper-gallery");
        }
        // Set initial displayed slide
        el.initialSlide = !el.initialSlide ? 0 : parseInt(el.initialSlide);
        // Format exclude sliders nodes property
        el.excludedSliders = el._formatArrayProperty(el.excludedSliders);
      },
      /*
        @function (private) {Number} _getNumProperty
        @description Get element computed style float property value
        @param {String} property [CSS property name]
        @param {Object} elm [Element target]
        @return {Number} [Number property value]
      */
      getNumProperty: function(property, elm) {
        var el = elm ? elm : this;
        return parseFloat(getComputedStyle(el).getPropertyValue(property));
      },
      /*
        @function (private) _buildWrapper
        @description Swiper structure and slides configuration
        @param {Object} fragment [Swiper temporal structure]
      */
      buildWrapper: function(fragment){
        var el = this;
        el.slides = [];
        // Create swiper wrapper container
        var wrapper = document.createElement("div");
        wrapper.classList.add("vc-swiper-wrapper");
        el.wrapper = wrapper;
        // Wrapper fragment the pages are going to be appended to
        var children = el.getSourceElements();
        // Get axis
        if(el.direction == "horizontal"){
          el._sizeProperty = "offsetWidth";
          el._styleSizeProperty = "width";
        }else{
          el.classList.add("vc-swiper-vertical");
          el._sizeProperty = "offsetHeight";
          el._styleSizeProperty = "height";
        }
        fragment.appendChild(wrapper);
        // Get maximum slide value
        el._maxTranslation = -Math.abs((el.slides.length - 1) * el._getNumProperty(el._styleSizeProperty));
      },
      /*
        @function (private) _buildPagination
        @description Pagination configuration and nodes structure
        @param {Object} fragment [Swiper temporal container]
      */
      buildPagination: function(fragment) {
        var el = this;
        el.thumbnails = [];
        // Is pagination activated
        if(el.pagination){
          // Create swiper pagination container
          var pagination = document.createElement("div");
          pagination.classList.add("vc-swiper-pagination");
          el.pagingNode = pagination;
          // Build gallery pagination container
          el._buildGalleryPagination(pagination);
          fragment.appendChild(pagination);
        }
      },
      /*
        @function (private) _buildGalleryPagination
        @description Gallery pagination slide configuration
        @param {Object} pagingNode [Thumbnails container element]
      */
      buildGalleryPagination: function(pagingNode) {
        var el = this;
        if(el.type == "gallery"){
          var pagingFragment = document.createDocumentFragment();
          // Create swiper wrapper container
          var pagingWrapper = document.createElement("div");
          pagingWrapper.classList.add("vc-swiper-paginationWrapper");
          // Append paging wrapper as the new paging node
          pagingFragment.appendChild(pagingWrapper);
          pagingNode.appendChild(pagingFragment);
          el.pagingNode = pagingWrapper;
          // Make sure paging thumbnails are created, allowing access to thumnail size
          el.onPagingReady(function(thumbnailSize){
            el._thumbnailSize = thumbnailSize;
            // Add paging wrapper slide event listener
            el._addPagingSlideEventListeners();
          });
          // Apply pagination type
          if(el.pagination == "hideable"){
            el._paginationHideAnim();
          }else if(el.pagination){
            // Make pagination static
            el.style.flexDirection = el.direction == "horizontal" ? "column": "row";
            pagingNode.classList.add("vc-swiper-paginationStatic");
          }
        }
      },
      /*
        @function (private) _setUpNavigation
        @description Set up navigation button controllers
        @param {Object} fragment [Navigation container element]
      */
      setUpNavigation: function(fragment) {
        var el = this;
        if(el.navigation == "true" || el.navigation == true){
          // Create navigation next button
          var nextBtn = document.createElement("i");
          nextBtn.className = " material-icons vc-swiper-navBtn vc-swiper-next unselectable"
          nextBtn.innerHTML = el.direction == "horizontal" ? "keyboard_arrow_right" : "keyboard_arrow_down"
          // Create navigation back button
          var backBtn = document.createElement("i");
          backBtn.className = " material-icons vc-swiper-navBtn vc-swiper-back unselectable"
          backBtn.innerHTML = el.direction == "horizontal" ? "keyboard_arrow_left" : "keyboard_arrow_up"
          // Get swiper type size properties
          var sizeValue = el.direction == "horizontal"
                  ? el._getNumProperty("height", el.pagingNode) : el._getNumProperty("width", el.pagingNode);
          var btnSizeValue = el.direction == "horizontal"
                  ? nextBtn.offsetHeight : nextBtn.offsetWidth;
          // Save the navigation buttons reference
          el.nextBtn = {node: nextBtn,
                        minSize: btnSizeValue - sizeValue};
          el.backBtn = {node: backBtn,
                        minSize: btnSizeValue - sizeValue};
          // If pagination is not hideable change clickable zone size
          if(el.pagination){
            el._decreaseNavButtonHeight(el.nextBtn);
            el._decreaseNavButtonHeight(el.backBtn);
          }
          // Navigation Functionality
          el._navClick();
          // Append buttons
          fragment.appendChild(nextBtn);
          fragment.appendChild(backBtn);
        }
      },
      /*
        @function (private) _addPagingSlideEventListeners
        @description Pagination slide event listeners
      */
      addPagingSlideEventListeners: function(){
        // Relevant nodes
        var el = this;
        var paging = el.pagingNode;
        var pagingParent = paging.parentNode;
        // Functionality control
        var throttled, mousedown, thumbnailClicked, initialValue, moveValue, translatePixels, position;
        var delay = 50;
        // Movement information
        var axis = el.direction == "horizontal" ? "clientX" : "clientY";
        // Thumbnail size information
        var thumbnailSize = el._thumbnailSize;
        var thumbnailMidSize = thumbnailSize / 2;
        var marginValue = el.direction == "vertical" ? 5 : 10;
        el._minPagingTranslation = (el._getNumProperty(el._styleSizeProperty, pagingParent) / 2) - (marginValue + thumbnailMidSize);
        // Translate element
        el._translate(paging, el._minPagingTranslation);
        // Start slide on mouse down event
        pagingParent.addEventListener("pointerdown", function(e){
          // Needed to make mouseup event work perfectly
          e.preventDefault();
          // Prevent mouse down functionality on secondaary mouse button is clicked
          if(e.button == 0){
            if(e.target.classList.contains("vc-swiper-thumbnail")){
              thumbnailClicked = e.target;
            }
            mousedown = true;
            // Get x/y value
            initialValue = moveValue = e[axis];
          }
        }, false);
        // Slide element on mouse move
        pagingParent.addEventListener("pointermove", function(e){
          if(mousedown){
             if (!throttled) {
              // Get y/z translate pixels
              translatePixels = moveValue - e[axis];
              // Proccess position with the new movement values
              position = el._proccesPosition(paging, translatePixels, "thumbnails");
              // Translate element
              el._translate(paging, position);
              // Update move value
              moveValue = e[axis];
              // Throttle
              throttled = true;
              // Set a timeout to un-throttle
              setTimeout(function() {
               throttled = false;
              }, delay);
            }
          }
        });
        // Stop slide on mouse up
        document.addEventListener("pointerup", function(e){
          // Make sure a movement has been fired
          if(mousedown){
            mousedown = false;
            // Mouse position is different from inital position
            // The mousedown thumbnail target is different from mouseup ones
            if(moveValue != initialValue && thumbnailClicked == e.target){
              // Denied thumbnail selection
              el._selectElement = false;
            } else {
              el._selectElement = true;
            }
          }
        });
      },
      /*
        @function (private) _paginationHideAnim
        @description Hideable pagination animation
      */
      paginationHideAnim: function() {
        var el = this;
        var node = el.pagingNode.parentNode;
        // Create pagination hidden control div
        var control = document.createElement("div");
        var fragment = document.createDocumentFragment();
        control.classList.add("vc-swiper-paginationHideControl");
        // Get translate property for this swiper direction
        var prop = el.direction == "horizontal" ? "bottom" : "right";
        var hideSizeProp = el._sizeProperty == "offsetWidth" ? "offsetHeight" : "offsetWidth";
        var leaveTimeout;
        var pagingActive = true;
        // Control div on mouseover  functionality
        control.addEventListener("pointerover", function(){
          clearTimeout(leaveTimeout);
          // Show pagination
          node.style[prop] = 0;
          // Hide pagination control div
          control.style.display = "none";
          if(!pagingActive && node.style[prop] == "0px"){
            // Decrease navigation buttons size
            el._decreaseNavButtonHeight(el.nextBtn);
            el._decreaseNavButtonHeight(el.backBtn);
            pagingActive = true;
          }
        });
        // Paging node on mouseover functionality
        node.addEventListener("pointerover", function(){
          clearTimeout(leaveTimeout);
          // Show pagination
          node.style[prop] = 0;
          // Hide pagination control div
          control.style.display = "none";
        });
        // Paging node on mouseleave functionality
        node.addEventListener("pointerleave", function(){
          leaveTimeout = setTimeout(function () {
            // Hide pagination translating its width distance
            node.style[prop] = -node[hideSizeProp] + "px";
            // Disaplay pagination control div
            control.style.display = "block";
              // Increase navigation buttons size
              el.nextBtn.node.style[el.direction == "horizontal" ? "height" : "width"] = "100%";
              el.backBtn.node.style[el.direction == "horizontal" ? "height" : "width"] = "100%";
            pagingActive = false;
          }, 300);
        });
        fragment.appendChild(control);
        el.appendChild(fragment);
      },
      /*
        @function (private) _decreaseNavButtonHeight
        @description Decrease navigation button container considering pagination size
        @param {Object} btn [Target element]
      */
      decreaseNavButtonHeight: function(btn){
        var el = this;
        // Make sure the paging node has been rendered
        setTimeout(function () {
          // Get pagination node size
          var pagingSize = el._sizeProperty == "offsetHeight"
                          ?  el.pagingNode["offsetWidth"]: el.pagingNode["offsetHeight"];
          // Get button node size
          var btnSize;
          if(el.direction == "horizontal"){
            btnSize = btn.node.offsetHeight;
            // Subtract pagination height to button height for centering purposes
            var value = (btnSize - pagingSize);
            btn.node.style.height = value < btn.minSize ? btn.minSize + "px" : value + "px";
          }else{
            btnSize = btn.node.offsetWidth;
            // Subtract pagination width to button width for centering purposes
            var value = (btnSize - pagingSize);
            btn.node.style.width = value < btn.minSize ? btn.minSize + "px" : value + "px";
          }
         }, 0);
      },
      /*
        @function (private) _updateNavButtonSize
        @description Update navigation button container size
      */
      updateNavButtonSize: function(){
        var el = this;
        var sizeProp = el.direction == "horizontal" ? "height" : "width";
        // Get swiper node size
        var sizeValue = el._getNumProperty(sizeProp, el);
        // Get pagination node size
        var pagingSizeValue = el._getNumProperty(sizeProp, el.pagingNode);
        el.nextBtn.minSize = sizeValue - pagingSizeValue;
        el.backBtn.minSize = sizeValue - pagingSizeValue;
        // Update navigation button size
        el.nextBtn.node.style[sizeProp] = el.nextBtn.minSize + "px";
        el.backBtn.node.style[sizeProp] = el.backBtn.minSize + "px";
        // Update fullscreen icon
        el._resizeFullScreenHandler();
        // If pagination is not hideable change clickable zone size
        setTimeout(function() {
          if(el.pagination == "hideable" && el.pagingNode.parentNode.style.right !== 0) {
            // Show pagination and adjust navigation buttons
            el.pagingNode.parentNode.style.right = 0;
            el._decreaseNavButtonHeight(el.nextBtn);
            el._decreaseNavButtonHeight(el.backBtn);
          }
        }, 200);
      },
      /*
        @function (private) _navClick
        @description Navigation controller click functionality
      */
      navClick: function() {
        var el = this;
        el.backBtn.node.addEventListener("click", function(){
          el.prev();
        });
        el.nextBtn.node.addEventListener("click", function(){
          el.next();
        });
      },
      /*
        @function (private) _createThumbnail
        @description Create and configure a new thumbnail
        @param {Object} slide [vc-slide element]
        @param {Object} slideObj [vc-swiper slide object reference ]
      */
      createThumbnail: function(slide, slideObj){
        var el = this;
        if(el.pagination){
          // Create thumbnail span element
          var thumbnail = document.createElement("span");
          var thumbnailStored = thumbnail;
          thumbnail.classList.add("vc-swiper-thumbnail");
          // Add thumbnail node
          var thumbnailFragment = document.createDocumentFragment();
          thumbnailFragment.appendChild(thumbnail);
          el.pagingNode.appendChild(thumbnailFragment);
          // Configure swiper gallery thumbnail
          el._setGalleryThumbnail(slide, thumbnail);
          // Thumbnail click functionality
          el._thumbnailClick(el.slides.indexOf(slideObj), thumbnail);

          if(el.type == "gallery"){
            var thumbnailObj = {};
            thumbnailObj.el = thumbnail;
            // Set 4:3 thumbnail size
            el._createThumbStyle(thumbnail);
            var size = thumbnail[el._sizeProperty];
            var slideIndex = el.slides.indexOf(slideObj);
            // Trigger paging created event
            if(slideIndex === 0){
              vcomet.triggerCallback("onPagingReady", el, el, [size]);
            }
            // Set thumbnail translation range
            thumbnailStored = el._updateThumbnailRange(thumbnailObj, slideIndex, size);
          }
          // Add thumbnail to swiper thumbails array
          el.thumbnails.push(thumbnailStored);
          return thumbnail;
        }
      },
      /*
        @function (private) _createThumbStyle
        @description Create the dynamic thumbnail size style rule
        @param {Object} thumbnail [Thumnnail node]
      */
      createThumbStyle: function(thumbnail){
        var el = this;
        // Check style existance
        if(!el._styleSheet["thumbnail"]) {
          // Calculate 4:3 size ratio
          var invertSizeProp = el._styleSizeProperty == "width" ? "height" : "width";
          var invertSize = el._getNumProperty(invertSizeProp, thumbnail);
          var size = invertSize + (invertSize / 3);

          // Set up css rule
          var typeRuleName = el.direction == "vertical" ? ".vc-swiper-vertical": "";
          var staticRuleName = 'vc-swiper[theme="'+ el.getAttribute("theme") +'"].vc-swiper-gallery'+ typeRuleName + ' .vc-swiper-thumbnail';
          var clss = staticRuleName + ".vc-swiper-thumbnailSize{" + el._styleSizeProperty + ":" + size + "px;}";
          
          // Insert and save rule
          vcomet.style.sheet.insertRule(clss);
          el._styleSheet["thumbnail"] = vcomet.style.sheet.cssRules[0];

        }
        thumbnail.classList.add("vc-swiper-thumbnailSize");
      },
      /*
        @function (private) _updateThumbnailsSize
        @description Update the dynamic thumbnail size style rule
      */
      updateThumbnailsSize: function(){
        var el = this;
        // Calculate 4:3 size ratio
        var invertSizeProp = el._styleSizeProperty == "width" ? "height" : "width";
        var invertSize = el._getNumProperty(invertSizeProp, el.thumbnails[0].el);
        var size = invertSize + (invertSize / 3);
        // Update size rule
        if (el._styleSheet.thumbnail){
         el._styleSheet.thumbnail.style[el._styleSizeProperty] = size + "px";
        }
      },
      /*
        @function (private) _updateThumbnailRange
        @description Update thumbnail range values
        @param {Object} thumbnailObj [Target thumbnail object reference]
        @param {Number} index [Thumbnail index position]
        @param {Number} [Thumbnail size value]
      */
      updateThumbnailRange: function(thumbnailObj, index, size) {
        var el = this;
        var marginValue = el.direction == "vertical" ? 5 : 10;
        size = !size ? el._thumbnailSize : size;
        // Get thumbnail centered position value
        var indexValue = ((size + marginValue) * index);
        var min = index == 0 ? el._minPagingTranslation : el._minPagingTranslation - indexValue;
        var max = 0 - ((size + marginValue) * (index + 1));
        thumbnailObj.range = [min, max];
        // Update max slide value
        el._maxPagingTranslation = min;
        return thumbnailObj;
      },
      /*
        @function (private) _activateThumbnail
        @description Select thumbnail related to the current slide selected
        @param {Object} target [Thumbnail node to be selected]
      */
      activateThumbnail: function(target){
        var el = this;
        // Check thumbnail existance
        if(target){
          try {
            // Active style
            target.classList.add("vc-swiper-thumbnailActive");
          } catch (e) {
            // Active style
            target.el.classList.add("vc-swiper-thumbnailActive");
            // Get translate position
            var min = target.range[0];
            // Translate paging wrapper to thumbail centered position
            if(el.direction == "horizontal"){
              el.pagingNode.style.transform = "translate3d(" + min + "px, 0px, 0px)";
            }else{
              el.pagingNode.style.transform = "translate3d(0px, " + min + "px, 0px)";
            }
          }
        }
        // Check other thumbails status
        for (var i = 0; i < el.thumbnails.length; i++) {
          var thumbnail = el.thumbnails[i].el || el.thumbnails[i];
          // If thumbnail is active change inactive class
          if(i != el.thumbnails.indexOf(target)
          && thumbnail.classList.contains("vc-swiper-thumbnailActive")){
            thumbnail.classList.remove("vc-swiper-thumbnailActive")
          }
        }
      },
      /*
        @function (private) _thumbnailClick
        @description Thumbnail click functionality
        @param {Number} slideIndex [Slide index position]
        @param {Object} thumbnail [Click target thumbnail]
      */
      thumbnailClick: function(slideIndex, thumbnail) {
        var el = this;
        //
        thumbnail.addEventListener("click", function(){
          // Translate to slide position
          if(el._selectElement){
            el.slideTo(slideIndex);
          }else{
            el._selectElement = true;
          }
        });
      },
      /*
        @function (private) _setGalleryThumbnail
        @description Configure gallery thumbnail node 
        @param {Object} slide [Related slide element]
        @param {Object} thumbnail [Target thumbnail element]
      */
      setGalleryThumbnail: function(slide, thumbnail){
        var el = this;
        // Slide belongs to a swiper gallery type
        if(el.type == "gallery" && slide.image){
          var path = slide.image;
          // Add swiper image style
          thumbnail.classList.add("vc-swiper-image");
          thumbnail.style.backgroundImage = "url(" + path + ")";
        }
      },
      /*
        @function (private) _createSlide
        @description Create and configure a new slide
        @param {Object} slide [Target slide element]
        @return {Object} [Slide object reference]
      */
      createSlide: function(slide){
        var el = this;
        // Create slide element
        var slideObj = {};
        var newSlideIndex = el.slides.length;
        slide.classList.add("vc-swiper-child");
        // Store swiper elements object
        slideObj.el = slide;
        // Set slide range values
        el.slides.push(el._updateSlideRange(slideObj, newSlideIndex));
        return slideObj;
      },
      /*
        @function (private) _updateSlideRange
        @description Update slide range values
        @param {Object} slideObj [Target slide object reference]
        @param {Number} index [Target slide index position]
        @return {Object} [Slide object reference]
      */
      updateSlideRange: function(slideObj, index){
        var el = this;
        slideObj.range = [-Math.abs((el._getNumProperty(el._styleSizeProperty) * index))
                      , -Math.abs((el._getNumProperty(el._styleSizeProperty) * (index + 1)))];
        return slideObj;
      },
      /*
        @function (private) _addFullScreenListener
        @description Create full screen mode functionality
      */
      addFullScreenListener: function(){
        var el = this;
        var mousedown = false;
        var axis = el.direction == "horizontal" ? "clientX" : "clientY";
        var clickDelay, clickCounter, clickCounter, diff, initValue, moveValue;
        clickDelay = clickCounter = clickCounter = diff = initValue = moveValue = 0;
        var resetDbClick = function(){
          // Reset double click paramaters
          clickCounter = 0;
          clickDelay = 0;
        };

        // Check fullscreen functionality
        if(el.fullScreen === true || el.fullScreen === "true") {
          // Create the full screen button handler
          el._createFullScreenHandler();
          el.wrapper.addEventListener("pointerdown", function(e){
            e.preventDefault();
            mousedown = true;
            initValue = moveValue = e[axis];
            // Save current date in miliseconds
            if(clickCounter == 0){
              clickDelay = new Date().getTime();
            }
          });
          el.wrapper.addEventListener("pointermove", function(e){
            e.preventDefault();
            // Save movement new position;
            if(mousedown) {
              moveValue = moveValue - e[axis];
            }
          });
          el.wrapper.addEventListener("pointerup", function(e){
            clickCounter++
            mousedown = false;
            // No movement registered
            if(moveValue == initValue) { moveValue = 0; }
            // Trigger double click functionality
            if(clickCounter == 2 && moveValue == 0) {
              // Check double click time lapse
              diff = new Date().getTime() - clickDelay;
              if (diff < 400) {
                // Activate or deactivate full screen mode
                el._toggleFullScreen();
              }
              // Reset double click paramaters
              resetDbClick();
            } else {
              // Handle double click interruption
              if(clickCounter == 1) {
                setTimeout(resetDbClick, 400);
              }
            }
          });
        }
      },
      /*
        @function (private) _createFullScreenHandler
        @description Set up the full screen button handler
      */
      createFullScreenHandler: function(){
        var el = this;
        var btn = document.createElement("div");
        var sizeProp = el.direction == "horizontal" ? "offsetWidth" : "offsetHeight";
        btn.className = "material-icons vc-swiper-screenBtn unselectable"
        btn.innerHTML = "crop_free";
        // Set screen button initial size
        el._resizeFullScreenHandler(btn);
        el.appendChild(btn);
        // Full screen toggle function
        btn.addEventListener("pointerdown", function(e){
          e.preventDefault();
          e.stopPropagation();
          el._toggleFullScreen();
        });
      },
      /*
        @function (private) _toggleFullScreen
        @description Activate or deactivate full screen mode
      */
      toggleFullScreen: function(){
        var el = this;
        var activated = el.classList.contains("vc-swiper-fullscreen") ? true : false;
        el.querySelector(".vc-swiper-screenBtn").style.opacity = 0;
        // Remove translate animation
        el.wrapper.style.transition = "none";
        el.pagingNode.style.transition = "none";
        // Toggle full screen
        if(activated) {
          el.classList.remove("vc-swiper-fullscreen");
        } else {
          el.pagingNode.style.opacity = 0;
          el.classList.add("vc-swiper-fullscreen");
          // Wait for the thumbnail positioning before make the paging node visible
          setTimeout(function() {
            el.pagingNode.style.opacity = 1;
          }, 30);
        }
        // Restore translate animation
        setTimeout(function() {
          el.wrapper.style.transition = "transform .2s";
          el.pagingNode.style.transition = "transform .2s";
        }, 60);
      },
      /*
        @function (private) _resizeFullScreenHandler
        @description Udpate the full screen handler button dimensions
      */
      resizeFullScreenHandler: function(btn){
        var el = this;
        if (el.fullScreen == true || el.fullScreen == "true") {
          btn = !btn ? el.querySelector(".vc-swiper-screenBtn") : btn;
          btn.style.opacity = 0;
          var sizeProp = el.direction == "horizontal" ? "height" : "width";
          var scrBtnSizeProp = sizeProp == "height" ? "offsetWidth" : "offsetHeight";
          btn.style.width = el.nextBtn.node[scrBtnSizeProp] + "px";
          btn.style.height = el.nextBtn.node[scrBtnSizeProp] + "px";
          btn.style.opacity = 1;
        }
      },
      /*
        @function (private) _addSlideEventListeners
        @description Create slide functionality event listeners
      */
      addSlideEventListeners: function(){
        var el = this;
        var mousedown, mousedownEvt, mousedownThrottled, throttled;
        mousedown = mousedownThrottled = throttled = false;
        var initialValue, moveValue, slideCounter, position, target, translatePixels;
        var index, slideLimitValue, minTranslValue, elementTranslateMiddle, slide;
        var delay = 50;
        var axis = el.direction == "horizontal" ? "clientX" : "clientY";
        if(!el.externalSlide || el.externalSlide === "false"){
          // Start slide on mouse down event
          el.addEventListener("pointerdown", function(e){
            // Needed to prevent bad mouseup event
            e.preventDefault();
            // Check slide policy
            mousedown = el._allowSlide(e.button, e.target);
            // Slide complete trigger interval
            el.slideTimeInterval = setInterval(function() {
              slideCounter = !slideCounter ? 1 : slideCounter + 1;
            }, 1);
            if(mousedown) {
              // Get x/y value
              initialValue = moveValue = e[axis];
            }
          }, false);
          // Slide element on mouse move
          el.addEventListener("pointermove", function(e){
            if(mousedown){
              if(slideCounter > 5) {
                // mousedownEvt.stopPropagation();
                e.stopPropagation();
                if (!throttled) {
                  // Get y/z translate pixels
                  translatePixels = moveValue - e[axis];
                  // Proccess position with the new movement values
                  position = el._proccesPosition(el.wrapper, translatePixels, "slides");
                  // Translate element
                  el._translate(el.wrapper, position);
                  // Update initial move value
                  moveValue = e[axis];
                  // Throttle
                  throttled = true;
                  // Set a timeout to un-throttle
                  setTimeout(function() {
                    throttled = false;
                  }, delay);
                }
              }
            }
          });
          // Stop slide on mouse up
          document.addEventListener("pointerup", function(e){
            // Make sure a movement has been fired
            clearInterval(el.slideTimeInterval);
            if(mousedown){
              mousedown = false;
              // Complete slide monitor
              if(slideCounter < 100){
                // Trigger complete slide
                if(moveValue < initialValue){
                  el.next();
                }else if(moveValue > initialValue){
                  el.prev();
                }
              }else {
                // Get translate position
                position = el.direction == "horizontal"
                      ? parseInt(el.wrapper.style.transform.split(",")[0].split("(")[1])
                      : parseInt(el.wrapper.style.transform.split(",")[1]);
                // Get current element displayed index
                index = el.slides.indexOf(el.currentSlide);
                slideLimitValue = el._getNumProperty(el._styleSizeProperty) / 2;
                minTranslValue = el._getNumProperty(el._styleSizeProperty) * index;
                elementTranslateMiddle = -Math.abs(minTranslValue + slideLimitValue);
                // Get slide from translate position value
                slide = el._getPositionSlide(position, "slides");
                // Execute programmed slide
                if(position >= elementTranslateMiddle
                  && el.slides.indexOf(el.currentSlide) != el.slides.indexOf(slide)
                  && position > (slide.range[1] + (el._getNumProperty(el._styleSizeProperty)/2))){
                    // Slide back
                    el.slideTo(index - 1);
                  }else if(position >= elementTranslateMiddle){
                    // Stay on the current element
                    el.slideTo(index);
                  }else{
                    // Slide to next element
                    el.slideTo(index + 1);
                  }
              }
            }
            slideCounter = 0;
          });
        }
      },
      /*
        @function (private) _getPositionSlide
        @description Get slide element by index
        @param {Number} position [Slide index position]
        @param {Array} swipeElms [Slides array]
        @return {Object} [Slide object reference]
      */
      getPositionSlide: function(position, swipeElms){
        var el = this;
        var selElem, elm, i;
        // Loop through swiper slider array
        for (i = 0; i < el[swipeElms].length; i++) {
          elem = el[swipeElms][i];
          // Is position between range values
          if(position > elem.range[1] && position <= elem.range[0]){
            selElem = elem;
            break;
          }
        }
        return selElem;
      },
      /*
        @function (private) _isEdgeElement
        @description Whether or not the current position is related to an edge slide
        @param {Number} position [Source position]
        @param {Object} slide [Target slide element]
      */
      isEdgeElement: function(position, slide){
        var el = this;
        var sibling = !slide ? el.currentSlide.el.nextSibling : slide.el.nextSibling;
        // Get the current swiper element
        if(position == "start"){
          return (sibling && sibling.tagName === "VC-SLIDE")? false: true;
        }else{
          sibling = !slide ? el.currentSlide.el.previousSibling : slide.el.previousSibling;
          return (sibling && sibling.tagName === "VC-SLIDE") ? false: true;
        }
      },
      /*
        @function (private) _translate
        @description Move node a specified pixels distance
        @param {Object} node [Target element]
        @param {Number} distance [Translate pixel value]
      */
      translate: function(node, distance){
        var el = this;
        // Set the new node translate position
        if(el.direction == "horizontal"){
          node.style.transform = "translate3d(" + distance + "px, 0px, 0px)";
        }else{
          node.style.transform = "translate3d(0px, " + distance + "px, 0px)";
        }
      },
      /*
        @function (private) _proccesPosition
        @description Proccess a position value and add the new distance to be translate to
        @param {Object} node [Translate target element]
        @param {Number} pixels [Movement pixel value]
        @param {String} slider [Targen swiper element type]
        @return {Number} [Processed position value]
      */
      proccesPosition: function(node, pixels, slider){
        var el = this;
        // Get current translate value
        var position = el.direction == "horizontal"
              ? parseInt(node.style.transform.split(",")[0].split("\(")[1])
              : parseInt(node.style.transform.split(",")[1]);
        // Monitor node first position null value
        position = !position ? 0 : position;
        // Set translate x/y new value
        position -= (pixels * (slider == "slides" ? el.slideDistance : el.thumbnailDistance));
        // Check min and max translate limit values
        var min = slider == "slides" ? 0 : el._minPagingTranslation;
        var max = slider == "slides" ? el._maxTranslation : el._maxPagingTranslation;
        position = position > min ? min: position;
        position = position < max ? max : position;
        return position;
      },
      /*
        @function (private) _addWrapperResizeListener
        @description Swiper resize functionality
      */
      addWrapperResizeListener: function(){
        var el = this;
        // Throttle event triggering for better performance
        var throttled = false;
        var delay = 20;
        var currentIndex, currentThumbnail, i;
        vcomet.addResizeListener(el, "resize", function(element){
          if (!throttled) {
            // Update maximum translation value
            el._maxTranslation = -Math.abs((el.slides.length - 1) * el._getNumProperty(el._styleSizeProperty));

            // Update slides ranges
            for (i = 0; i < el.slides.length; i++) {
              el.slides[i] = el._updateSlideRange(el.slides[i], i);
            }
            

            //
            el._updateThumbnailsSize();

            // Update thumbnail size reference
            el._thumbnailSize = el._getNumProperty(el._styleSizeProperty, el.thumbnails[0].el);

            // Update minimum paging translation
            el._minPagingTranslation = (el._getNumProperty(el._styleSizeProperty, el.pagingNode.parentNode) / 2) - (10 + (el._thumbnailSize / 2));
            
            // Update thumbnails ranges
            if(el.thumbnails[0]) {
              el._thumbnailSize = el._getNumProperty(el._styleSizeProperty, el.thumbnails[0].el);
              for (i = 0; i < el.thumbnails.length; i++) {
                el.thumbnails[i] = el._updateThumbnailRange(el.thumbnails[i], i);
              }
            }

            // Translate current thumbnail to its new centered position
            currentindex = el.slides.indexOf(el.currentSlide);
            currentThumbnail = el.thumbnails[currentindex];
            if (el.type === "gallery") {
              el._translate(el.pagingNode, currentThumbnail.range[0]);
            }
            
            // Translate current slide to its new centered position
            el.slideTo(currentindex);
            if(el.navigation == "true" || el.navigation == true) {
              // Update navigation buttons position
              el._updateNavButtonSize();
            }


            // Throttle
            throttled = true;
            // Set a timeout to un-throttle
            setTimeout(function() {
              throttled = false;
            }, delay);
          }
        });
      },
      /*
        @function (private) _append
        @description Use internally when a slide is appended via html api
        @param {Object} slide [Target slide element]
      */
      append: function(slide){
        var el = this;
        var slideObj = el._createSlide(slide);
        el._createThumbnail(slide, slideObj);
        // Update max slide value
        el._maxTranslation = -Math.abs((el.slides.length - 1) * el._getNumProperty(el._styleSizeProperty));
      },
      /*
        @function (private) {Boolean} _allowSlide
        @description Whether or not slide process should be triggered
        @param {Number} btn [Pointer down event button pressed]
        @param {Object} sliderNode [Pointer down target element]
        @return {Boolean} [Slide permission]
      */
      allowSlide: function(btn, sliderNode) {
        var el = this;
        var allow = false;
        // Check slide excluded nodes array
        if(btn == 0 && (sliderNode != el.pagingNode
          && !sliderNode.classList.contains("vc-swiper-thumbnail")
          && !sliderNode.classList.contains("vc-swiper-pagination"))){
          allow = true;
          // Loop through nodes excluded from triggering drawer displaying
          for (var i = 0; i < el.excludedSliders.length; i++) {
            excludedNode = el.querySelector(el.excludedSliders[i]);
            if (excludedNode.isEqualNode(sliderNode) || excludedNode.isOnPath == true) {
              allow = false;
              break;
            }
          }  
        }
        return allow;
      },
      /*
        @function (private) _hideNavBtn
        @description Hide navigation button on edge slides
        @param {Object} slide [Current view slide element]
      */
      hideNavBtn: function(slide) {
        var el = this;
        // Check if navigation controller exists
        if (el.type == "gallery" && (el.navigation == "true" || el.navigation == true)) {
          var backBtnStyle = el.backBtn.node.style;
          var nextBtnStyle = el.nextBtn.node.style;
          if (el._isEdgeElement(null, slide)) {
            // Hide secondary navigation button
            backBtnStyle.opacity=".5";
          } else { backBtnStyle.opacity = backBtnStyle != "1" ? backBtnStyle = "1" : backBtnStyle}
          if (el._isEdgeElement("start", slide)) {
            // Hide first navigation button
            nextBtnStyle.opacity=".5";
          } else {nextBtnStyle.opacity = nextBtnStyle != "1" ? nextBtnStyle = "1" : nextBtnStyle}
        }
      },
      /*
        @function (private) {Array} _formatArrayProperty
        @description Format array property
        @param {Array} prop [Property]
      */
      formatArrayProperty: function(prop) {
        var el = this;
        // Check preventclose property value
        if (typeof prop == "string") {
          // Convert value into an array
          prop = el._getValueAsArray(prop);
        }
        return prop;
      },
      /*
        @function (private) {Array} _getValueAsArray
        @description Get value as array
        @param {String} value [Array or String value to be processed]
        @return {Array} [Resulting array]
      */
      getValueAsArray: function(value) {
        var el = this;
        var array = [];
        // Check preventclose property value
        if (typeof value == "string") {
          // Convert value into an array
          value = value.replace(/\s/g, '');
          array = value.split(",");
        }
        return array[0] ? array : [];
      }
    },
    functions: {
      /*
        @function next
        @description Slide to the next slide element
      */
      next: function(){
        var el = this;
        // Current child has a next sibling
        if(!el._isEdgeElement("start")){
          // Update current element
          var currentIndex = el.slides.indexOf(el.currentSlide);
          el.currentSlide = el.slides[currentIndex + 1];
          // Get new y/z position
          var newPos =  el.currentSlide.range[0];
          // Translate element
          el._translate(el.wrapper, newPos);
          // Trigger onSlideChange event
          vcomet.triggerCallback("onSlideChange", el, el, [currentIndex, (currentIndex + 1)]);
        }
      },
      /*
        @function prev
        @description Slide to the previous slide element
      */
      prev: function(){
        var el = this;
        // Current child has a next sibling
        if(!el._isEdgeElement("end")){
          // Update current element
          var currentIndex = el.slides.indexOf(el.currentSlide);
          el.currentSlide = el.slides[currentIndex - 1];
          // Get new y/z position
          var newPos = el.currentSlide.range[0];
          // Translate element
          el._translate(el.wrapper, newPos);
          // Trigger onSlideChange event
          vcomet.triggerCallback("onSlideChange", el, el, [currentIndex, (currentIndex - 1)]);
        }
      },
      /*
        @function slideTo
        @description Slide to the previous slide element
        @param {Number} index [Translate target slide index]
      */
      slideTo: function(index){
        var el = this;
        // Get current slide index
        var currentIndex = el.slides.indexOf(el.currentSlide);
        // Update current element
        el.currentSlide = el.slides[index];
        // Get new y/z position
        var swiperHeight = el._getNumProperty(el._styleSizeProperty);
        var newPos = swiperHeight * (index);
        // Translate element
        el._translate(el.wrapper, -newPos);
        // Trigger onSlideChange event
        vcomet.triggerCallback("onSlideChange", el, el, [currentIndex, index]);
      },
      /*
        @function add
        @description Add swiper slide element
        @param {Object} slide [Slide element to be appended]
      */
      add: function(slide){
        var el = this;
        var slideFragment = document.createDocumentFragment();
        slideFragment.appendChild(slide);
        el.wrapper.appendChild(slideFragment);
        // Update max slide value
        el._maxTranslation = -Math.abs((el.slides.length - 1) * el._getNumProperty(el._styleSizeProperty));
      }
    },
    onCreated: function(){
      var el = this;
      // Create on slide change event callback
      vcomet.createCallback("onSlideChange", el);
      // Create on paging ready event
      // ** Internally used for thumbnails translation calculation
      vcomet.createCallback("onPagingReady", el);
      // Event target path monitor
      vcomet.registerPathListener(el);
    },
    onInit: function() {
      var el = this;
      // Pointer events attribute required
      el.setAttribute("touch-action", "none");
      // Set up swiper
      el._setUp();
      // Swiper elements container
      var fragment = document.createDocumentFragment();
      // Build main swiper structure
      el._buildWrapper(fragment);
      // Build swiper pagination controller
      el._buildPagination(fragment);
      // Insert gallery navigation
      el._setUpNavigation(fragment);
      el.appendChild(fragment);
    },
    onPropertyChanged: function(prop, oldValue, value){
      var el = this;
      if(prop == "currentSlide"){
        // Select related thumbnail
        var thumbnail = el.thumbnails[el.slides.indexOf(value)];
        // Activate thumbnail on swiper current slide change
        el._activateThumbnail(thumbnail);
        // Disable navigation button on limit reached
        el._hideNavBtn(value);
      };
    },
    onRender: function() {
      var el = this;
      // Add wrapper resize listener
      el._addWrapperResizeListener();
      // Configure slide events
      el._addSlideEventListeners();
      // Configure full screen mode
      el._addFullScreenListener();
      // Make sure slides are created before the initial slide translation
      setTimeout(function() {
        el.slideTo(el.initialSlide);
      }, 0);
    }
  });
</script>
