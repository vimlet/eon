<template></template>

<script type="text/javascript">
  eon.element({

    name: "eon-scroll",
    style: "eon-scroll.css",

    properties: {
      /*
        @property {String} type
        @description Indicates the allowed scrolls, auto/horizontal/vertical
      */
      type: {
        value: "auto",
        reflect: true
      },
      /*
        @property {Boolean} fill
        @description Indicates whether the scroll will autofill its container or grow according to its content until it fills its container
      */
      fill: {
        value: true,
        reflect: true
      },
      /*
        @property {Number} thickness
        @description Indicates the thickness for the scroll rails
      */
      thickness: {
        value: 15,
        reflect: true
      },
      /*
        @property {Boolean} arrowScrolls
        @description Indicates whether we want arrow scrolls or not
      */
      arrowScrolls: {
        value: false,
        reflect: true
      },
      /*
        @property {String} static
        @description Indicates whether we want some scroll rails to be always visible or not, none/horizontal/vertical/both
      */
      static: {
        value: false,
        reflect: true
      },
      /*
        @property {Boolean} square
        @description Indicates whether we want some scroll rails to be always visible or not, none/horizontal/vertical/both
      */
      square: {
        value: false,
        reflect: true
      },
      /*
        @property {String} autoGrowth
        @description Indicates whether the scroll grows with the parent or the parent grows with the scroll content
      */
      autoGrowth: {
        value: false,
        reflect: true
      }
    },
    privateProperties: {
      /*
        @property (private) {Object} _refs
        @description Object with references
      */
      refs: {
        value: {}
      },
      /*
        @property (private) {Object} _misc
        @description Object with useful information
      */
      misc: {
        value: {}
      },
    },
    functions: {
      /*
        @function scrollTo
        @description Scrolls to a given position
        @param {Number} scrollTop
        @param {Number} scrollLeft
        @param {Boolean} smooth [Whether the user wants a transition while scrolling to the request position]
      */
      scrollTo: function (scrollTop, scrollLeft, smooth) {
        this._performScroll(scrollTop, scrollLeft, smooth);
      },
      /*
        @function update
        @description Recalculate scroll bar size
      */
      update: function () {
        if (this._misc.resize.fn) {
          this._misc.resize.fn();
        }
      }
    },
    privateFunctions: {
      /*
        @function (private) _setupMisc
        @description Creates basic miscellaneous variables to be used by the element
      */
      setupMisc: function () {
        var el = this;

        el._misc.scrollBarSpace = eon.util.getBrowserScrollBarWidth();

        el._misc.vertical = {};
        el._misc.vertical.drag = {};

        el._misc.horizontal = {};
        el._misc.horizontal.drag = {};

        el._misc.square = {};

        el._misc.mouse = {};

        // Default milliseconds for the scrollbars to hide
        el._misc.hideScrollbarsMs = 1000;

        // Threshold for the scrollbars to be shown when moving the mouse
        el._misc.moveThreshold = {};
        el._misc.moveThreshold.start = 0;
        el._misc.moveThreshold.time = 500;

        el._misc.arrowScroll = {};
        el._misc.arrowScrollAmount = 5;

        el._misc.railScroll = {};
        el._misc.railScrollAmount = 5;

        // This helps our pointerEnter to be triggered only once
        el._misc.pointerOut = true;

        el._misc.resize = {};
        el._misc.resize.time = 500;

        el._misc.contentResize = {};

        el._misc.smoothScroll = {};
        el._misc.smoothScroll.vertical = {};
        el._misc.smoothScroll.horizontal = {};
        el._misc.smoothScroll.amount = 20;

      },
      /*
        @function (private) _definePublicProperties
        @description Creates definitions for some public properties
      */
      definePublicProperties: function () {

        var el = this;
        var scrollTopDescriptor = {};
        var scrollTopEndDescriptor = {};
        var scrollLeftDescriptor = {};
        var scrollLeftEndDescriptor = {};

        // ScrollTop property descriptor
        scrollTopDescriptor.get = function () {
          return el.content.scrollTop;
        };

        scrollTopDescriptor.set = function (value) {

          var smooth = false;
          var scrollTop;

          // If the value is an array, the first value should be the scrollTop and 
          // the second one should be whether the user wants transition or not
          if (value.constructor === Array) {
            scrollTop = value[0];
            smooth = value[1];
          } else {
            scrollTop = value;
          }

          el._performScroll(scrollTop, el.content.scrollLeft, smooth);

        };

        // ScrollLeft property descriptor
        scrollLeftDescriptor.get = function () {
          return el.content.scrollLeft;
        };

        scrollLeftDescriptor.set = function (value) {

          var smooth = false;
          var scrollLeft;

          // If the value is an array, the first value should be the scrollTop and 
          // the second one should be whether the user wants transition or not
          if (value.constructor === Array) {
            scrollLeft = value[0];
            smooth = value[1];
          } else {
            scrollLeft = value;
          }

          el._performScroll(el.content.scrollTop, scrollLeft, smooth);

        };

        // ScrollLeftEnd property descriptor
        scrollLeftEndDescriptor.get = function () {
          return el._getHorizontalScrollableSize();
        };

        scrollLeftEndDescriptor.set = function (value) { };

        // ScrollTopEnd property descriptor
        scrollTopEndDescriptor.get = function () {
          return el._getVerticalScrollableSize();
        };

        scrollTopEndDescriptor.set = function (value) { };

        // Defines our public properties
        Object.defineProperty(el, "scrollTop", scrollTopDescriptor);
        Object.defineProperty(el, "scrollLeft", scrollLeftDescriptor);
        Object.defineProperty(el, "scrollTopEnd", scrollTopEndDescriptor);
        Object.defineProperty(el, "scrollLeftEnd", scrollLeftEndDescriptor);

      },
      /*
        @function (private) _setupScrolling
        @description Prepares the scrolling for the element
      */
      setupScrolling: function () {

        var el = this;

        // Either way we create or not our custom scrolls, we want to trigger the onScrolled event
        el._setupOnScrolledEvent();

        // If the scrollbars take no space then we do not need to implement our custom behavior
        if (eon.util.getBrowserScrollBarWidth() != 0 || el._isChromeDevice()) {

          // By default we want smooth scrolling
          el.classList.add("eon-scroll-smooth");

          // This class will hide the arrows and the square to make it similar to webkit native ones
          if (el._isChromeDevice()) {
            el.classList.add("eon-scroll-chrome-device");
          }

          // If the user allows us to have vertical scrolling, we set our overflow and margin to hide the native one
          if (el._isAllowedToHaveScroll("vertical")) {
            el.content.style.overflowY = "scroll";
            if (!el._isChromeDevice()) {
              el.content.style.marginRight = "-" + el._misc.scrollBarSpace + "px";
            }
          }

          // If the user allows us to have horizontal scrolling, we set our overflow and margin to hide the native one
          if (el._isAllowedToHaveScroll("horizontal")) {
            el.content.style.overflowX = "scroll";
            if (!el._isChromeDevice()) {
              el.content.style.marginBottom = "-" + el._misc.scrollBarSpace + "px";
            }
          }

          // Creates basic events such as pointerenter/pointerleave, wheel...
          el._setupPointerEvents();

          // Creates the scrollbars and the resize listeners once all the elements are ready
          eon.onReady(function () {
            el._setupScrollBars();
            el._setupResizeListeners();
          });

          // If there scroll bars take no space then we just enable the native scrolling
        } else {

          el.content.style.overflow = "auto";
          el.classList.add("eon-scroll-native");

        }
      },
      /*
        @function (private) _setupOnScrolledEvent
        @description Sets up the onScrolledEvent
      */
      setupOnScrolledEvent: function () {
        var el = this;

        // Scroll event that triggers our updates
        el.content.addEventListener("scroll", function () {

          // We want to always display the scroll bars when scrolling
          el._showScrollbars(el._misc.hideScrollbarsMs);

          // For each scroll event update the vertical scrollbar, if its created and active
          if (el._misc.vertical.created && el._refs.verticalScroll.classList.contains("eon-scroll-active")) {
            el._updateVerticalScrollBarPosition();
          }

          // For each scroll event update the horizontal scrollbar, if its created and active
          if (el._misc.horizontal.created && el._refs.horizontalScroll.classList.contains("eon-scroll-active")) {
            el._updateHorizontalScrollBarPosition();
          }

          // Trigger our onScrolled callback returning an object with scrollTop/scrollLeft properties
          eon.triggerCallback("onScrolled", el, el, [{ scrollTop: el.content.scrollTop, scrollLeft: el.content.scrollLeft }]);

        });
      },
      /*
        @function (private) _setupPointerEvents
        @description Sets up the basic Events
      */
      setupPointerEvents: function () {

        var el = this;

        //This event is to show the scrolls when the mouse hovers the container
        el.addEventListener("pointerenter", function (e) {

          // If the pointer was outside of the scroll active area
          if (el._misc.pointerOut) {

            // If we are dragging we are already displaying the scrollbars so we avoid calling it again
            if (!eon.util.isTrue(el._misc.horizontal.drag.active) && !eon.util.isTrue(el._misc.vertical.drag.active)) {
              el._showScrollbars(el._misc.hideScrollbarsMs);
            }

            // Since we just entered the scroll active area we are no longer coming from outside
            el._misc.pointerOut = false;
          }

        }, true);

        //This event is to show the scrolls when the mouse moves the container
        el.addEventListener("pointermove", function (e) {

          // If no dragging is active, we display the scrollbars again after certain time has passed and the user moves the pointer
          if (!eon.util.isTrue(el._misc.horizontal.drag.active) && !eon.util.isTrue(el._misc.vertical.drag.active)) {

            var now = Date.now();

            // Simple check to know if the threshold time is exceeded to display the scrollbars
            if ((now - el._misc.moveThreshold.start) > el._misc.moveThreshold.time) {
              el._misc.moveThreshold.start = now;
              el._showScrollbars(el._misc.hideScrollbarsMs);
            }

          }

        }, true);

        //This event is to hide the scrolls when the mouse leaves the container
        el.addEventListener("pointerleave", function (e) {
          el._hideScrollbars();
          el._misc.pointerOut = true;
        });

        // On pointerup we want to stop either the railscroll or the arrowscroll
        document.addEventListener("pointerup", function () {
          el._handleArrowScrollStop();
          el._handleRailScrollStop();
        });
      },
      /*
        @function (private) _createContent
        @description Creates the content node and saves its reference
      */
      createContent: function () {
        this.content = document.createElement("div");
        this.content.classList.add("eon-scroll-content");
      },
      /*
        @function (private) _createChromeDeviceRule
        @description Creates a CSS Rule for the webkit device case
      */
      createChromeDeviceRule: function () {
        if (!eon.rules.ChromeDevice && this._isChromeDevice()) {
          var ChromeDeviceRuleIndex = eon.style.sheet.insertRule(".eon-scroll-chrome-device > .eon-scroll-content::-webkit-scrollbar { display: none; }", 0);
          eon.rules.ChromeDevice = eon.style.sheet.cssRules[ChromeDeviceRuleIndex];
        }
      },
      /*
        @function (private) _appendContent
        @description Takes the source content and moves it to our content node
      */
      appendContent: function () {
        var el = this;
        var sourceNodes = this.getSourceNodes();

        // Loops through the source elements to move them to the content node
        for (var i = 0; i < sourceNodes.length; i++) {
          el.content.appendChild(sourceNodes[i]);
        }

        el.appendChild(el.content);
      },
      /*
        @function (private) _assignSize
        @description Depending on the settings provided by the user and our container we will add some style
      */
      assignSize: function () {
        var el = this;
        var fn = function () {

          el._refs.container = el.parentNode;

          // If the element will take the size of its parent
          if (eon.util.isTrue(el.fill)) {

            var containerComputedStyle = window.getComputedStyle(el._refs.container);

            // If the parent has a height given by flex then we also setup our element as flex
            if (containerComputedStyle.flexGrow == "1") {

              el._refs.container.classList.add("eon-scroll-flexContainer");

              el.style.display = "flex";
              el.style.flexGrow = "1";

              el.content.style.flexGrow = "1";

              // Else if the container has a specified height we will completely fill it
            } else {

              el.style.height = "100%";
              el.style.width = "100%";

              if (el._isAllowedToHaveScroll("vertical")) {
                el.content.style.width = "calc(100% + " + el._misc.scrollBarSpace + "px)";
              }

              if (el._isAllowedToHaveScroll("horizontal")) {
                el.content.style.height = "calc(100% + " + el._misc.scrollBarSpace + "px)";
              }

              el._misc.calculatedContentSize = true;

            }

            // Else if we do not want to fill
          } else {

            // If we have autoGrowth set to true then it means the scroll will grow according to its content, so we set display: flex to the container
            if (eon.util.isTrue(el.autoGrowth)) {
              el._refs.container.style.display = "flex";
            }

            el.style.display = "flex";
            el.style.flexDirection = "column";

            el.content.style.flexGrow = 1;

          }
        }
        // if (el.parentNode.nodeType == 1) {
        //   fn();
        // } else {
        el.onReady(function () {
          fn();
        });
        // }
      },
      /*
        @function (private) _setupResizeListeners
        @description Creates the resize listener and the content scrollHeight/scrollWidth watcher
      */
      setupResizeListeners: function () {
        var el = this;

        el._misc.resize.fn = function () {
          // Only do stuff if it has offsetParent, that means the eon-scroll is not hidden by display none, in which case we 
          // do not want to take the resize into account
          if (el.offsetParent) {
            el._handleVerticalResize();
            el._handleHorizontalResize();
          }

        }

        eon.addResizeListener(el, el.nodeName.toLowerCase(), el._misc.resize.fn);

        // This resize listener is meant to handle the window resize triggered when the user zooms in/out the browser and the 
        // native scroll bar sizes may be affected
        window.addEventListener("resize", function () {

          // First of all clears any pending timeout
          clearTimeout(el._misc.windowResizeTimeout);

          // Creates a new timeout that will be triggered if not cleared by another resize event
          el._misc.windowResizeTimeout = setTimeout(function () {

            // Gets the scroll bar width
            var scrollBarSpace = eon.util.getBrowserScrollBarWidth();

            // Compares the saved width with the current one, if it is different then it updates the margins
            if (el._misc.scrollBarSpace != scrollBarSpace) {

              el._misc.scrollBarSpace = scrollBarSpace;

              // If the user allows us to have vertical scrolling, we set our overflow and margin to hide the native one
              if (el._isAllowedToHaveScroll("vertical")) {
                if (!el._isChromeDevice()) {
                  el.content.style.marginRight = "-" + el._misc.scrollBarSpace + "px";
                }
                // We have to also update the content calc size if its done before
                if (el._misc.calculatedContentSize) {
                  el.content.style.width = "calc(100% + " + el._misc.scrollBarSpace + "px)";
                }
              }

              // If the user allows us to have horizontal scrolling, we set our overflow and margin to hide the native one
              if (el._isAllowedToHaveScroll("horizontal")) {
                if (!el._isChromeDevice()) {
                  el.content.style.marginBottom = "-" + el._misc.scrollBarSpace + "px";
                }
                // We have to also update the content calc size if its done before
                if (el._misc.calculatedContentSize) {
                  el.content.style.height = "calc(100% + " + el._misc.scrollBarSpace + "px)";
                }
              }

            }

          }, el._misc.resize.time);

        });

        el._createContentResizeWatcher();
      },
      /*
        @function (private) _createContentResizeWatcher
        @description Creates the content scrollHeight/scrollWidth watcher
      */
      createContentResizeWatcher: function () {
        var el = this;

        // Assigns the current content scrollHeight that will be compared in the animation frame
        el._misc.contentResize.lastScrollHeight = el.content.scrollHeight;
        el._misc.contentResize.lastScrollWidth = el.content.scrollWidth;

        // Creates the function that will compare the scroll sizes to know if it has changed
        el._misc.contentResize.watchFn = function () {
          // Cancels the animation frame
          cancelAnimationFrame(el._misc.contentResize.watcher);

          // Only do stuff if it has offsetParent, that means the eon-scroll is not hidden by display none, in which case we 
          // do not want to take the resize into account
          if (el.offsetParent) {

            // Checks if the scrollHeight has changed, if it did then triggers functionality and updates the lastScrollHeight
            if (el._isAllowedToHaveScroll("vertical") && el.content.scrollHeight !== el._misc.contentResize.lastScrollHeight) {
              el._handleVerticalResize();
              el._misc.contentResize.lastScrollHeight = el.content.scrollHeight;
            }

            // Checks if the scrollWidth has changed, if it did then triggers functionality and updates the lastScrollHeight
            if (el._isAllowedToHaveScroll("horizontal") && el.content.scrollWidth !== el._misc.contentResize.lastScrollWidth) {
              el._handleHorizontalResize();
              el._misc.contentResize.lastScrollWidth = el.content.scrollWidth;
            }

          }

          // Waits a specified time to call requestAnimationFrame
          setTimeout(function () {
            el._misc.contentResize.watcher = requestAnimationFrame(el._misc.contentResize.watchFn);
          }, el._misc.resize.time);

        };

        // Inits the requestAnimationFrame watcher
        el._misc.contentResize.watcher = window.requestAnimationFrame(el._misc.contentResize.watchFn);
      },
      /*
        @function (private) _handleVerticalResize
        @description Handles the vertical resizing 
      */
      handleVerticalResize: function () {

        var el = this;
        var hasVerticalScroll = el._getVerticalScrollableSize() > 0;

        // If the vertical scroll is not event created
        if (!el._misc.vertical.created) {
          //  If we have vertical scrollable content
          if (hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) {
            // Then create it
            el._setupVerticalScroll();
            // If the horizontal scroll is active we also create the square
            if (el._misc.horizontal.created && el._refs.horizontalScroll.classList.contains("eon-scroll-active")) {
              el._setupSquare();
            }
          }
          // Else if it is already created
        } else {
          //  If we have vertical scrollable content
          if (hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) {
            // If the vertical scroll currently active 
            if (!el._refs.verticalScroll.classList.contains("eon-scroll-active")) {
              // Then activate it
              el._refs.verticalScroll.classList.add("eon-scroll-active");
              eon.triggerCallback("onVerticalStatusChange", el, el, [true]);
              // If the horizontal scroll is active 
              if (el._misc.horizontal.created && el._refs.horizontalScroll.classList.contains("eon-scroll-active")) {
                // Then check if the square is already created, if it is
                if (el._misc.square.created) {
                  //  Then check if its not active, if it is not, then we activate it
                  if (!el._refs.square.classList.contains("eon-scroll-active")) {
                    el._refs.square.classList.add("eon-scroll-active")
                  }
                  // If its not created 
                } else {
                  // Then we create it
                  el._setupSquare();

                }

                // Update everything horizontal scroll related
                el._assignHorizontalScrollSize();
                el._updateHorizontalScrollBar();

              }

            }
            // If there is no vertical scrollable content 
          } else {
            // Then deactive the scroll
            el._refs.verticalScroll.classList.remove("eon-scroll-active");
            eon.triggerCallback("onVerticalStatusChange", el, el, [false]);
            // If the square is active
            if (el._misc.square.created && el._refs.square.classList.contains("eon-scroll-active")) {
              // Then deactivate it
              el._refs.square.classList.remove("eon-scroll-active");
              // And update everything horizontal scroll related
              el._assignHorizontalScrollSize();
              el._updateHorizontalScrollBar();

            }

          }

          el._updateVerticalScrollBar();

        }
      },
      /*
        @function (private) _handleHorizontalResize
        @description Handles the horizontal resizing 
      */
      handleHorizontalResize: function () {

        var el = this;
        var hasHorizontalScroll = el._getHorizontalScrollableSize() > 0;

        // If the horizontal scroll is not event created
        if (!el._misc.horizontal.created) {

          //  If we have horizontal scrollable content
          if (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal")) {
            // Then create it
            el._setupHorizontalScroll();
            // If the vertical scroll is active we also create the square
            if (el._misc.vertical.created && el._refs.verticalScroll.classList.contains("eon-scroll-active")) {
              el._setupSquare();
            }
          }
          // Else if it is already created
        } else {

          //  If we have horizontal scrollable content
          if (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal")) {
            // If the horizontal scroll currently active 
            if (!el._refs.horizontalScroll.classList.contains("eon-scroll-active")) {
              // Then activate it
              el._refs.horizontalScroll.classList.add("eon-scroll-active");
              eon.triggerCallback("onHorizontalStatusChange", el, el, [true]);
              // If the vertical scroll is active 
              if (el._misc.vertical.created && el._refs.verticalScroll.classList.contains("eon-scroll-active")) {
                // Then check if the square is already created, if it is
                if (el._misc.square.created) {
                  //  Then check if its not active, if it is not, then we activate it
                  if (!el._refs.square.classList.contains("eon-scroll-active")) {
                    el._refs.square.classList.add("eon-scroll-active")
                  }
                  // If its not created 
                } else {
                  // Then we create it
                  el._setupSquare();

                }

                // Update everything vertical scroll related
                el._assignVerticalScrollSize();
                el._updateVerticalScrollBar();

              }

            }
            // If there is no horizontal scrollable content 
          } else {
            // Then deactive the scroll
            el._refs.horizontalScroll.classList.remove("eon-scroll-active");
            eon.triggerCallback("onHorizontalStatusChange", el, el, [false]);

            // If the square is active
            if (el._misc.square.created && el._refs.square.classList.contains("eon-scroll-active")) {
              // Then deactivate it
              el._refs.square.classList.remove("eon-scroll-active");
              // And update everything horizontal scroll related
              el._assignVerticalScrollSize();
              el._updateVerticalScrollBar();
            }

          }

          el._updateHorizontalScrollBar();

        }
      },
      /*
        @function (private) _setupScrollBars
        @description Based on some parameters, creates the scrollbars
      */
      setupScrollBars: function () {
        var el = this;

        var hasVerticalScroll = (el.content.scrollHeight > el.content.offsetHeight);
        var hasHorizontalScroll = (el.content.scrollWidth > el.content.offsetWidth);

        // If there is scrollable content on both sides and we are allowed to have those scrolls then we create the square separator
        if ((hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) && (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal"))) {
          el._setupSquare();
        }

        // If there is vertical scrollable content and we are allowed to scroll on that direction
        if (hasVerticalScroll && el._isAllowedToHaveScroll("vertical")) {
          el._setupVerticalScroll();
        }

        // If there is horizontal scrollable content and we are allowed to scroll on that direction
        if (hasHorizontalScroll && el._isAllowedToHaveScroll("horizontal")) {
          el._setupHorizontalScroll();
        }
      },
      /*
        @function (private) _setupSquare
        @description Sets up the square separating both scrolls
      */
      setupSquare: function () {
        var el = this;
        var square = document.createElement("div");

        square.classList.add("eon-scroll-square", "eon-bg8", "eon-scroll-active");

        // If the user specified the display of the scrollbars to be static then we do so on the square as well
        if (eon.util.isTrue(el.static)) {
          square.classList.add("eon-scroll-static");
        }

        if (!eon.util.isTrue(el.square)) {
          square.style.display = "none";
        }

        //The square width and height depends on the vertical and horizontal scroll thickness
        square.style.height = el._getThickness() + "px";
        square.style.width = el._getThickness() + "px";

        // Saves the reference and appends it
        el._refs.square = square;
        el.appendChild(square);

        el._misc.square.created = true;
      },
      /*
        @function (private) _setupVerticalScroll
        @description Sets up the vertical scroll
      */
      setupVerticalScroll: function () {

        var el = this;

        // If the vertical scroll is not created yet then we do so
        if (!el._misc.vertical.created) {

          el._createVerticalScroll();

          //When left clicking on the scrollBar we will start the dragging event
          el.addEventListener("wheel", function (e) {
            el.classList.add("eon-scroll-smooth");
          });

          //When left clicking on the scrollBar we will start the dragging event
          el._refs.verticalBar.addEventListener("mousedown", function (e) {
            el._handleVerticalDragStart(e);
          });

          //When the drag event is active and we start moving the mouse we will scroll the content and the bar
          document.addEventListener("mousemove", function (e) {
            el._handleVerticalDrag(e);
          });

          //When releasing the mouse button we set the dragging event bool to false
          document.addEventListener("mouseup", function (e) {
            el._handleVerticalDragEnd(e);
          });

          // Vertical rail scrolling
          el._refs.verticalRail.addEventListener("mousedown", function (e) {
            el._handleRailScroll(e, "vertical");
          });

          el._misc.vertical.created = true;

          // Triggers the callback
          eon.triggerCallback("onVerticalScrollCreated", el, el, [el._refs.verticalScroll]);
        }

      },
      /*
        @function (private) _setupHorizontalScroll
        @description Sets up the horizontal scroll
      */
      setupHorizontalScroll: function () {

        var el = this;

        // If the horizontal scroll is not created yet then we do so
        if (!el._misc.horizontal.created) {

          el._createHorizontalScroll();

          //When left clicking on the scrollBar we will start the dragging event
          el._refs.horizontalBar.addEventListener("pointerdown", function (e) {
            el._handleHorizontalDragStart(e);
          });

          //When the drag event is active and we start moving the mouse we will scroll the content and the bar
          document.addEventListener("pointermove", function (e) {
            el._handleHorizontalDrag(e);
          });

          //When releasing the mouse button we set the dragging event bool to false
          document.addEventListener("pointerup", function (e) {
            el._handleHorizontalDragEnd(e);
          });

          // Vertical rail scrolling
          el._refs.horizontalRail.addEventListener("pointerdown", function (e) {
            el._handleRailScroll(e, "horizontal");
          });

          el._misc.horizontal.created = true;

          // Triggers the callback
          eon.triggerCallback("onHorizontalScrollCreated", el, el, [el._refs.horizontalScroll]);
        }

      },
      /*
       @function (private) _createVerticalScroll
       @description Creates the vertical scroll nodes structure
      */
      createVerticalScroll: function () {
        var el = this;

        var scroll = document.createElement("div");
        var rail = document.createElement("div");
        var bar = document.createElement("div");

        el._refs.verticalScroll = scroll;
        el._refs.verticalRail = rail;
        el._refs.verticalBar = bar;

        scroll.classList.add("eon-scroll-verticalScroll");
        rail.classList.add("eon-scroll-verticalRail");
        bar.classList.add("eon-scroll-verticalBar", "eon-bg8", "eon-bg8-hoverable");

        scroll.classList.add("eon-scroll-active");

        rail.appendChild(bar);
        scroll.appendChild(rail);
        el.appendChild(scroll);

        // If the static property is true then we add the static class
        if (eon.util.isTrue(el.static)) {
          scroll.classList.add("eon-scroll-static");
        }

        scroll.style.width = el._getThickness() + "px";

        // If specified by the user then we create the arrow scrolls
        if (eon.util.isTrue(el.arrowScrolls)) {
          el._createVerticalScrollArrows();
        }

        // If by the moment this point is reached the horizontal scroll is already created and active
        // then we create the square if needed and then update the horizontal scroll
        if (el._misc.horizontal.created && el._refs.horizontalScroll.classList.contains("eon-scroll-active")) {
          if (!el._misc.square.created) {
            el._setupSquare();
            el._assignHorizontalScrollSize();
            el._updateHorizontalScrollBar();
          }
        }

        // Assigns the sizes for the scroll
        el._assignVerticalScrollSize();
        el._updateVerticalScrollBar();

        eon.triggerCallback("onVerticalStatusChange", el, el, [true]);
      },
      /*
        @function (private) _createHorizontalScroll
        @description Creates the horizontal scroll nodes structure
      */
      createHorizontalScroll: function () {
        var el = this;

        var scroll = document.createElement("div");
        var rail = document.createElement("div");
        var bar = document.createElement("div");

        el._refs.horizontalScroll = scroll;
        el._refs.horizontalRail = rail;
        el._refs.horizontalBar = bar;

        scroll.classList.add("eon-scroll-horizontalScroll");
        rail.classList.add("eon-scroll-horizontalRail");
        bar.classList.add("eon-scroll-horizontalBar", "eon-bg8", "eon-bg8-hoverable");

        scroll.classList.add("eon-scroll-active");

        rail.appendChild(bar);
        scroll.appendChild(rail);
        el.appendChild(scroll);

        // If the static property is true then we add the static class
        if (eon.util.isTrue(el.static)) {
          scroll.classList.add("eon-scroll-static");
        }

        scroll.style.height = el._getThickness() + "px";

        // If specified by the user then we create the arrow scrolls
        if (eon.util.isTrue(el.arrowScrolls)) {
          el._createHorizontalScrollArrows();
        }

        // If by the moment this point is reached the vertical scroll is already created and active
        // then we create the square if needed and then update the vertical scroll
        if (el._misc.vertical.created && el._refs.verticalScroll.classList.contains("eon-scroll-active")) {
          if (!el._misc.square.created) {
            el._setupSquare();
            el._assignVerticalScrollSize();
            el._updateVerticalScrollBar();
          }
        }

        // Assigns the sizes for the scroll
        el._assignHorizontalScrollSize();
        el._updateHorizontalScrollBar();

        eon.triggerCallback("onHorizontalStatusChange", el, el, [true]);
      },
      /*
        @function (private) _createVerticalScrollArrows
        @description Creates the vertical arrow scrolls nodes structure
      */
      createVerticalScrollArrows: function () {

        var el = this;

        var upButton = document.createElement("div");
        var downButton = document.createElement("div");

        var upIcon = document.createElement("i");
        var downIcon = document.createElement("i");

        upIcon.classList.add("vicon", "vicon-chevron-up", "eon-fg1");
        upIcon.style.fontSize = el._getThickness() + "px";

        downIcon.classList.add("vicon", "vicon-chevron-down", "eon-fg1");
        downIcon.style.fontSize = el._getThickness() + "px";

        upButton.appendChild(upIcon);
        upButton.classList.add("eon-scroll-arrowButton", "eon-bg8", "eon-bg8-hoverable", "eon-unselectable");
        upButton.style.height = el._getThickness() + "px";
        upButton.style.width = el._getThickness() + "px";
        upButton.onmousedown = function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, "vertical", "up")
        };

        downButton.appendChild(downIcon);
        downButton.classList.add("eon-scroll-arrowButton", "eon-bg8", "eon-bg8-hoverable", "eon-unselectable");
        downButton.style.height = el._getThickness() + "px";
        downButton.style.width = el._getThickness() + "px";
        downButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, "vertical", "down");
        });

        el._refs.upArrowButton = upButton;
        el._refs.downArrowButton = downButton;

        el._refs.verticalScroll.insertBefore(upButton, el._refs.verticalRail);
        el._refs.verticalScroll.appendChild(downButton);
      },
      /*
        @function (private) _createHorizontalScrollArrows
        @description Creates the vertical arrow scrolls nodes structure
      */
      createHorizontalScrollArrows: function () {
        var el = this;

        var leftButton = document.createElement("div");
        var rightButton = document.createElement("div");

        var leftIcon = document.createElement("i");
        var rightIcon = document.createElement("i");

        leftIcon.classList.add("vicon", "vicon-chevron-left", "eon-fg1");
        leftIcon.style.fontSize = el._getThickness() + "px";

        rightIcon.classList.add("vicon", "vicon-chevron-right", "eon-fg1");
        rightIcon.style.fontSize = el._getThickness() + "px";

        leftButton.appendChild(leftIcon);
        leftButton.classList.add("eon-scroll-arrowButton", "eon-unselectable", "eon-bg8", "eon-bg8-hoverable");
        leftButton.style.height = el._getThickness() + "px";
        leftButton.style.width = el._getThickness() + "px";
        leftButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, "horizontal", "left");
        });

        rightButton.appendChild(rightIcon);
        rightButton.classList.add("eon-scroll-arrowButton", "eon-unselectable", "eon-bg8", "eon-bg8-hoverable");
        rightButton.style.height = el._getThickness() + "px";
        rightButton.style.width = el._getThickness() + "px";
        rightButton.addEventListener("pointerdown", function (e) {
          e.preventDefault();
          el._handleArrowScroll(e, "horizontal", "right");
        });

        el._refs.leftArrowButton = leftButton;
        el._refs.rightArrowButton = rightButton;

        el._refs.horizontalScroll.insertBefore(leftButton, el._refs.horizontalRail);
        el._refs.horizontalScroll.appendChild(rightButton);
      },
      /*
        @function (private) _handleArrowScroll
        @description Handles the scrolling of the arrow
        @param {Object} e [Event]
        @param {String} type
        @param {String} direction
      */
      handleArrowScroll: function (e, type, direction) {
        var el = this;

        // We trigger the scrolls when the mouse button trigger is the left one
        if (e.button == 0) {

          var arrowScrollFunction;

          if (type == "vertical") {

            arrowScrollFunction = function () {
              var previousScrollTop = el.content.scrollTop;
              var newScrollTop = el.content.scrollTop + (direction == "up" ? -el._misc.arrowScrollAmount : el._misc.arrowScrollAmount);

              el._showScrollbars(el._misc.hideScrollbarsMs);

              //If the scroll has changed we trigger the callback
              if (previousScrollTop != newScrollTop) {
                el._performScroll(newScrollTop);
              }
            };

          } else if (type == "horizontal") {

            arrowScrollFunction = function () {
              var previousScrollLeft = el.content.scrollLeft;
              var newScrollLeft = el.content.scrollLeft + (direction == "left" ? -el._misc.arrowScrollAmount : el._misc.arrowScrollAmount);

              el._showScrollbars(el._misc.hideScrollbarsMs);

              // If the scroll has changed we scroll
              if (previousScrollLeft != newScrollLeft) {
                el._performScroll(el.content.scrollTop, newScrollLeft);
              }
            };

          }

          //Here we create the interval to scroll
          el._misc.arrowScroll.active = true;
          el._misc.arrowScroll.interval = setInterval(function () {
            arrowScrollFunction();
          }, 10);

        }
      },
      /*
        @function (private) _handleArrowScrollStop
        @description Handles the mouseup event when the user is scrolling with the arrows and clears the interval
      */
      handleArrowScrollStop: function () {
        var el = this;
        if (el._misc.arrowScroll.active == true) {
          clearInterval(el._misc.arrowScroll.interval);
          el._misc.arrowScroll.active = false;
        }
      },
      /*
        @function (private) _handleRailScroll
        @description Handles the length of the vertical scroll
        @param {Object} e
        @param {String} type
      */
      handleRailScroll: function (e, type) {
        var el = this;

        //We trigger the scrolls when the mouse button trigger is the left one
        if (e.button == 0) {

          var railScrollFunction;

          if (type == "vertical") {

            railScrollFunction = function () {

              var barRect = el._refs.verticalBar.getBoundingClientRect();
              var shouldStop = parseFloat(barRect.top) + barRect.height > e.clientY && e.clientY > parseFloat(barRect.top);

              // If it already reached the desired point then stop the scrolling 
              if (shouldStop) {

                el._handleRailScrollStop();

                // Else keep scrolling the it the user stops or we reached the pointer
              } else {

                var railRect = el._refs.verticalRail.getBoundingClientRect();
                var isMeantToScrollUp = (railRect.top < e.clientY && e.clientY < barRect.top);
                var isMeantToScrollDown = ((railRect.top + railRect.height) > e.clientY && (barRect.top + barRect.height) < e.clientY);
                var previousScrollTop = el.content.scrollTop;
                var newScrollTop = isMeantToScrollUp ? el.content.scrollTop - el._misc.railScrollAmount : el.content.scrollTop + el._misc.railScrollAmount;

                // If the scroll has changed we scroll
                if (previousScrollTop != newScrollTop) {
                  el._performScroll(newScrollTop);
                }

              }

            };

          } else {

            railScrollFunction = function () {

              var barRect = el._refs.horizontalBar.getBoundingClientRect();
              var shouldStop = parseFloat(barRect.left) + barRect.width > e.clientX && e.clientX > parseFloat(barRect.left);

              // If it already reached the desired point then stop the scrolling 
              if (shouldStop) {

                el._handleRailScrollStop();

                // Else keep scrolling the it the user stops or we reached the pointer
              } else {

                var railRect = el._refs.horizontalRail.getBoundingClientRect();
                var isMeantToScrollLeft = (railRect.left < e.clientX && e.clientX < barRect.left);
                var isMeantToScrollRight = ((railRect.left + railRect.width) > e.clientX && (barRect.left + barRect.width) < e.clientX);
                var previousScrollLeft = el.content.scrollLeft;
                var newScrollLeft = isMeantToScrollLeft ? el.content.scrollLeft - el._misc.railScrollAmount : el.content.scrollLeft + el._misc.railScrollAmount;

                // If the scroll has changed we scroll
                if (previousScrollLeft != newScrollLeft) {
                  el._performScroll(el.content.scrollTop, newScrollLeft);
                }

              }

            };

          }

          //Here we create the interval to scroll
          el._misc.railScroll.active = true;
          el._misc.railScroll.interval = setInterval(function () {
            if (el._misc.vertical.drag.active != true) {
              railScrollFunction();
            }
          }, 10);

        }
      },
      /*
        @function (private) _handleRailScrollStop
        @description Handles the mouseup event when the user is scrolling while clicking on the rail and clears the interval
      */
      handleRailScrollStop: function () {
        var el = this;
        if (el._misc.railScroll.active == true) {
          clearInterval(el._misc.railScroll.interval);
          el._misc.railScroll.active = false;
        }
      },
      /*
        @function (private) _assignVerticalScrollSize
        @description Handles the height of the vertical scroll
      */
      assignVerticalScrollSize: function () {
        this._refs.verticalScroll.style.height = (this._misc.square.created && this._refs.square.classList.contains("eon-scroll-active")) ? "calc(100% - " + this._getThickness() + "px)" : "100%";
      },
      /*
        @function (private) _assignVerticalScrollSize
        @description Handles the height of the horizontal scroll
      */
      assignHorizontalScrollSize: function () {
        this._refs.horizontalScroll.style.width = (this._misc.square.created && this._refs.square.classList.contains("eon-scroll-active")) ? "calc(100% - " + this._getThickness() + "px)" : "100%";
      },
      /*
        @function (private) _updateVerticalScrollStatus
        @description Depending on the scroll bar size if its exceeds the rail limits it means there is no active scroll
      */
      updateVerticalScrollStatus: function () {
        var el = this;

        if (el._misc.vertical.created) {

          if ((el._refs.verticalBar.getBoundingClientRect().height > el._refs.verticalRail.getBoundingClientRect().height) && !eon.util.isTrue(el.static)) {
            el._refs.verticalScroll.classList.remove("eon-scroll-active");
            eon.triggerCallback("onVerticalStatusChange", el, el, [false]);
          } else {
            el._refs.verticalScroll.classList.add("eon-scroll-active");
            eon.triggerCallback("onVerticalStatusChange", el, el, [true]);
          }

        }
      },
      /*
        @function (private) _updateHorizontalScrollStatus
        @description Depending on the scroll bar size if its exceeds the rail limits it means there is no active scroll
      */
      updateHorizontalScrollStatus: function () {
        var el = this;

        if (el._misc.horizontal.created) {

          if ((el._refs.horizontalBar.getBoundingClientRect().width > el._refs.horizontalRail.getBoundingClientRect().width) && !eon.util.isTrue(el.static)) {
            el._refs.horizontalScroll.classList.remove("eon-scroll-active");
            eon.triggerCallback("onHorizontalStatusChange", el, el, [false]);
          } else {
            el._refs.horizontalScroll.classList.add("eon-scroll-active");
            eon.triggerCallback("onHorizontalStatusChange", el, el, [true]);
          }

        }
      },
      /*
        @function (private) _updateVerticalScrollBar
        @description Updates the vertical scroll bar
      */
      updateVerticalScrollBar: function () {
        var el = this;

        el._assignVerticalScrollBarSize();
        el._updateVerticalScrollBarPosition();
      },
      /*
        @function (private) _updateHorizontalScrollBar
        @description Updates the horizontal scroll bar
      */
      updateHorizontalScrollBar: function () {
        var el = this;

        el._assignHorizontalScrollBarSize();
        el._updateHorizontalScrollBarPosition();
      },
      /*
        @function (private) _assignVerticalScrollSize
        @description Handles the length of the vertical bar
      */
      assignVerticalScrollBarSize: function () {
        this._refs.verticalBar.style.height = Math.ceil(this._refs.verticalRail.getBoundingClientRect().height / (this.content.scrollHeight / this.content.getBoundingClientRect().height)) + "px";
      },
      /*
        @function (private) _assignVerticalScrollSize
        @description Handles the length of the horizontal bar
      */
      assignHorizontalScrollBarSize: function () {
        this._refs.horizontalBar.style.width = Math.ceil(this._refs.horizontalRail.getBoundingClientRect().width / (this.content.scrollWidth / this.content.getBoundingClientRect().width)) + "px";
      },
      /*
        @function (private) _updateVerticalBarPosition
        @description Updates the vertical bar position based on the content scrollTop
      */
      updateVerticalScrollBarPosition: function () {
        var el = this;

        var scrollableSize = el._getVerticalScrollableSize();
        var scrollTopProportion = el.content.scrollTop / scrollableSize;
        var proportionalScrollBarTop = Math.ceil(scrollTopProportion * (el._refs.verticalRail.offsetHeight - el._refs.verticalBar.offsetHeight));

        el._refs.verticalBar.style.transform = "translate3d( 0, " + proportionalScrollBarTop + "px, 0)";
      },
      /*
        @function (private) _updateHorizontalScrollBarPosition
        @description Updates the vertical bar position based on the content scrollLeft
      */
      updateHorizontalScrollBarPosition: function () {
        var el = this;

        var scrollableSize = el._getHorizontalScrollableSize();
        var scrollLeftProportion = el.content.scrollLeft / scrollableSize;
        var proportionalScrollBarLeft = Math.ceil(scrollLeftProportion * (el._refs.horizontalRail.offsetWidth - el._refs.horizontalBar.offsetWidth));

        el._refs.horizontalBar.style.transform = "translate3d(" + proportionalScrollBarLeft + "px, 0, 0)";
      },
      /*
        @function (private) _handleVerticalDragStart
        @description Handles the start of the dragging
        @param {Object} e [Event]
      */
      handleVerticalDragStart: function (e) {
        var el = this;

        if (e.button == 0) {
          e.preventDefault();
          e.stopPropagation();
          el._misc.vertical.drag.active = true;
          el._misc.vertical.drag.start = e.clientY - el._refs.verticalBar.getBoundingClientRect().top;
        }
      },
      /*
        @function (private) _handleHorizontalDragStart
        @description Handles the start of the dragging
        @param {Object} e [Event]
      */
      handleHorizontalDragStart: function (e) {
        var el = this;

        if (e.button == 0) {
          e.preventDefault();
          e.stopPropagation();
          el._misc.horizontal.drag.active = true;
          el._misc.horizontal.drag.start = e.clientX - el._refs.horizontalBar.getBoundingClientRect().left;
        }
      },
      /*
        @function (private) _handleVerticalDrag
        @description Handles the dragging of the vertical scroll bar
        @param {Object} e [Event]
      */
      handleVerticalDrag: function (e) {
        var el = this;

        // Only do stuff is the dragging is active
        if (el._misc.vertical.drag.active) {

          var scrollableSize = el._getVerticalScrollableSize();
          var verticalRailRect = el._refs.verticalRail.getBoundingClientRect();
          var verticalBarRect = el._refs.verticalBar.getBoundingClientRect();
          var bottomDragLimit = (verticalRailRect.top + verticalRailRect.height - verticalBarRect.height + parseFloat(el._misc.vertical.drag.start));
          var scrollbarPosition, scrollbarProportion;

          //Show the scrollbars when dragging, event if the mouse is outside of the scroll container
          el._showScrollbars();

          //Only do stuff when the mouse position is bigger than the verticalRail start
          if (e.clientY >= verticalRailRect.top && e.clientY <= (verticalRailRect.top + verticalRailRect.height)) {

            //We calculate the top position of the scrollBar
            scrollbarPosition = e.clientY - verticalRailRect.top - parseFloat(el._misc.vertical.drag.start);

            // If it exceeds either the superior or the inferior limit we update the value
            scrollbarPosition = scrollbarPosition < 0 ? 0 : scrollbarPosition;
            scrollbarPosition = e.clientY > bottomDragLimit ? verticalRailRect.height - verticalBarRect.height : scrollbarPosition;

            //Here we calculate the proportional scroll that we have to make according of the scrollbar movement
            scrollbarProportion = scrollbarPosition / (verticalRailRect.height - verticalBarRect.height);

            // Scrolls to the corresponding position
            el._performScroll(scrollableSize * scrollbarProportion);

          }

        }
      },
      /*
        @function (private) _handleHorizontalDrag
        @description Handles the dragging of the horizontal scroll bar
        @param {Object} e [Event]
      */
      handleHorizontalDrag: function (e) {
        var el = this;

        // Only do stuff is the dragging is active
        if (el._misc.horizontal.drag.active) {

          var scrollableSize = el._getHorizontalScrollableSize();
          var horizontalRailRect = el._refs.horizontalRail.getBoundingClientRect();
          var horizontalBarRect = el._refs.horizontalBar.getBoundingClientRect();
          var rightDragLimit = (horizontalRailRect.left + horizontalRailRect.width - horizontalBarRect.width + parseFloat(el._misc.horizontal.drag.start));
          var scrollbarPosition, scrollbarProportion;

          //Show the scrollbars when dragging, event if the mouse is outside of the scroll container
          el._showScrollbars();

          //Only do stuff when the mouse position is bigger than the horizontalRail start
          if (e.clientX > horizontalRailRect.left) {

            //We calculate the top position of the scrollBar
            scrollbarPosition = e.clientX - horizontalRailRect.left - parseFloat(el._misc.horizontal.drag.start);

            // If it exceeds either the left or the right limit we update the value
            scrollbarPosition = scrollbarPosition < 0 ? 0 : scrollbarPosition;
            scrollbarPosition = e.clientX > rightDragLimit ? horizontalRailRect.width - horizontalBarRect.width : scrollbarPosition;

            //Here we calculate the proportional scroll that we have to make according of the scrollbar movement
            scrollbarProportion = scrollbarPosition / (horizontalRailRect.width - horizontalBarRect.width);

            // Scrolls to the corresponding position
            el._performScroll(el.content.scrollTop, scrollableSize * scrollbarProportion);

          }

        }
      },
      /*
        @function (private) _handleVerticalDrag
        @description Handles the drag of the vertical scroll bar
        @param {Object} e [Event]
      */
      handleVerticalDragEnd: function (e) {
        var el = this;

        if (!el._isCursorInsideScroll(e) && el._misc.vertical.drag.active == true) {
          el._hideScrollbars();
        }

        el._misc.vertical.drag.active = false;
      },
      /*
        @function (private) _handleHorizontalDragEnd
        @description Handles the drag of the horizontal scroll bar
        @param {Object} e [Event]
      */
      handleHorizontalDragEnd: function (e) {
        var el = this;

        if (!el._isCursorInsideScroll(e) && el._misc.horizontal.drag.active == true) {
          el._hideScrollbars();
        }

        el._misc.horizontal.drag.active = false;
      },
      /*
        @function (private) {Boolean} _isCursorInsideScroll
        @description Returns whether the pointer is inside the scrolling area or not
        @param {Object} e [Event]
      */
      isCursorInsideScroll: function (e) {
        var rect = this.getBoundingClientRect();
        return (e.clientX > rect.left && e.clientX < rect.right && e.clientY > rect.top && e.clientY < rect.bottom);
      },
      /*
        @function (private) _showScrollbars
        @description Shows the scrollbars
        @param {Number} hideScrollbarsMs [Milliseconds for the scrollbars to hide again after being displayed]
      */
      showScrollbars: function (hideScrollbarsMs) {
        var el = this;

        // If there was a timeout for the scrollbars to hide we clear it
        clearTimeout(el._misc.hideScrollbarsTimeout);

        // Displays the vertical scroll if its created, active and its not static (Since this means its always displayed)
        if (el._misc.vertical.created && el._refs.verticalScroll.classList.contains("eon-scroll-active") && !eon.util.isTrue(el.static)) {
          el._refs.verticalScroll.classList.add("eon-scroll-visible");
        }

        // Displays the horizontal scroll if its created, active and its not static (Since this means its always displayed)
        if (el._misc.horizontal.created && el._refs.horizontalScroll.classList.contains("eon-scroll-active") && !eon.util.isTrue(el.static)) {
          el._refs.horizontalScroll.classList.add("eon-scroll-visible");
        }

        // Displays the square if its created, active and its not static (Since this means its always displayed)
        if (el._misc.square.created && !eon.util.isTrue(el.static)) {
          el._refs.square.classList.add("eon-scroll-visible");
        }

        // If we receive the hideScrollbarsMs parameter we pass the parameter to the hideScrollbars function to hide all on the requested time
        if (hideScrollbarsMs) {
          el._hideScrollbars(hideScrollbarsMs);
        }
      },
      /*
        @function (private) _hideScrollbars
        @description Hides the scrollbars
        @param {Number} milliseconds [Milliseconds for the scrollbars to hide]
      */
      hideScrollbars: function (milliseconds) {
        var el = this;

        milliseconds = milliseconds ? milliseconds : 0;

        // Clears any hideScrollbarsTimeout if there was one waiting to be triggered
        clearTimeout(el._misc.hideScrollbarsTimeout);

        // Creates a new timeout with the given milliseconds
        el._misc.hideScrollbarsTimeout = setTimeout(function () {

          // Hides the vertical scroll if its created, active and its not static (Since this means its always displayed)
          if (el._misc.vertical.created && !eon.util.isTrue(el.static)) {
            el._refs.verticalScroll.classList.remove("eon-scroll-visible");
          }

          // Hides the vertical scroll if its created, active and its not static (Since this means its always displayed)
          if (el._misc.horizontal.created && !eon.util.isTrue(el.static)) {
            el._refs.horizontalScroll.classList.remove("eon-scroll-visible");
          }

          // Hides the square if its created, active and its not static (Since this means its always displayed)
          if (el._misc.square.created && !eon.util.isTrue(el.static)) {
            el._refs.square.classList.remove("eon-scroll-visible");
          }

        }, milliseconds);
      },
      /*
        @function (private) {Boolean} _isAllowedToHaveScroll
        @description Returns whether that specified scroll type is allowed to exists based on the element setup
        @param {String} scrollType
      */
      isAllowedToHaveScroll: function (scrollType) {
        var el = this;
        var returnBoolean = false;

        if (scrollType == "horizontal") {
          returnBoolean = (el.type == "auto" || el.type == "horizontal") ? true : false;
        } else if (scrollType == "vertical") {
          returnBoolean = (el.type == "auto" || el.type == "vertical") ? true : false;
        }

        return returnBoolean;
      },
      /*
        @function (private) {Number} _getThickness
        @description Returns the proper thickness depending on the scenario
      */
      getThickness: function () {
        return !this._isChromeDevice() ? this.thickness : parseInt(this.thickness) / 3;
      },
      /*
        @function (private) {Number} _getVerticalScrollableSize
        @description Returns the vertical scrollable amount
      */
      getVerticalScrollableSize: function () {
        var el = this;
        var scrollable = 0;

        if (Math.ceil(el.content.scrollHeight) != el.content.clientHeight) {
          scrollable = Math.ceil(el.content.scrollHeight) - Math.ceil(el.content.getBoundingClientRect().height);
          scrollable = el._isAllowedToHaveScroll("horizontal") ? scrollable + el._misc.scrollBarSpace : scrollable;
        }

        return Math.floor(scrollable);
      },
      /*
        @function (private) {Number} _getHorizontalScrollableSize
        @description Returns the horizontal scrollable amount
      */
      getHorizontalScrollableSize: function () {
        var el = this;
        var scrollable = 0;

        if (Math.ceil(el.content.scrollWidth) != el.content.clientWidth) {
          scrollable = Math.ceil(el.content.scrollWidth) - Math.ceil(el.content.getBoundingClientRect().width)
          scrollable = el._isAllowedToHaveScroll("vertical") ? scrollable + el._misc.scrollBarSpace : scrollable;
        }

        return Math.floor(scrollable);
      },
      /*
        @function (private) _performScroll
        @description Performs the scroll action with the given parameters
        @param {Number} top
        @param {Number} left
        @param {Boolean} smooth
      */
      performScroll: function (top, left, smooth) {
        var el = this;

        // If no parameter is passed we take the current one
        var top = !isNaN(parseInt(top)) ? top : el.content.scrollTop;
        var left = !isNaN(parseInt(left)) ? left : el.content.scrollLeft;

        el.classList.remove("eon-scroll-smooth");

        if (smooth) {

          el._performVerticalSmoothScroll(top);
          el._performHorizontalSmoothScroll(left);

        } else {

          // If the browsers supports scrollTo function then thats what will be used
          if (el.content.scrollTo) {
            el.content.scrollTo(left, top);
            // Else we used scrollTop/scrollLeft properties
          } else {
            el.content.scrollTop = top;
            el.content.scrollLeft = left;
          }

        }
      },
      /*
        @function (private) _performVerticalSmoothScroll
        @description Scrolls to the given position smoothly
        @param {Number} top
      */
      performVerticalSmoothScroll: function (top) {
        var el = this;

        var positive = top > el.content.scrollTop ? true : false;
        var initial = el.content.scrollTop;
        var advance = top - initial;
        var duration = Math.min(1200, Math.abs(advance) * 1.2);
        var endTime = + new Date() + duration;
        var finished, rate, proportion;

        // Removes the smooth scroll class
        el.classList.remove("vc-scroll-smooth");

        // If there is a previous animation frame still running we cancel it
        cancelAnimationFrame(el._misc.smoothScroll.vertical.animationFrame);

        // Makes sure the top number does not exceeds neither the maximum nor the minimum scroll
        top = top > el._getVerticalScrollableSize() ? el._getVerticalScrollableSize() : top;
        top = top < 0 ? 0 : top;

        // Creates the function that will scroll until it reached the desired position
        el._misc.smoothScroll.vertical.fn = function () {

          var currentTime = +new Date();
          var remaining = (endTime - currentTime);

          rate = 1 - Math.pow(remaining / duration, 3);
          rate = rate > 1 ? 1 : rate;

          proportion = rate * advance;

          // If there is place for us to scroll
          if ((positive && el.content.scrollTop < top) || (!positive && el.content.scrollTop > top)) {

            el.content.scrollTop = initial + proportion;

            // Once it finishes sets the finished variable to true
          } else {

            finished = true;

          }

          // Keeps running the animation frame until it finishes
          if (!finished) {
            el._misc.smoothScroll.vertical.animationFrame = requestAnimationFrame(el._misc.smoothScroll.vertical.fn);
          } else {
            cancelAnimationFrame(el._misc.smoothScroll.vertical.animationFrame);
          }

        };

        // Inits the requestAnimationFrame
        el._misc.smoothScroll.vertical.animationFrame = window.requestAnimationFrame(el._misc.smoothScroll.vertical.fn);
      },
      /*
        @function (private) _performHorizontalSmoothScroll
        @description Scrolls to the given position smoothly
        @param {Number} left
      */
      performHorizontalSmoothScroll: function (left) {
        var el = this;

        var positive = left > el.content.scrollLeft ? true : false;
        var finished;

        // Removes the smooth scroll class
        el.classList.remove("eon-scroll-smooth");

        // If there is a previous animation frame still running we cancel it
        cancelAnimationFrame(el._misc.smoothScroll.horizontal.animationFrame);

        // Makes sure the left number does not exceeds neither the maximum nor the minimum scroll
        left = left > el._getHorizontalScrollableSize() ? el._getHorizontalScrollableSize() : left;
        left = left < 0 ? 0 : left;

        // Creates the function that will scroll until it reached the desired position
        el._misc.smoothScroll.horizontal.fn = function () {

          // If there is place for us to scroll
          if ((positive && el.content.scrollLeft < left) || (!positive && el.content.scrollLeft > left)) {

            // If its scrolling down and it hasn't reach its destination
            if ((positive && el.content.scrollLeft < left)) {
              // If it can still scroll our established amount then it does it, if there is less space then scrolls to the final position
              el.content.scrollLeft = (left - el.content.scrollLeft) > el._misc.smoothScroll.amount ? el.content.scrollLeft + el._misc.smoothScroll.amount : left;
              // If its scrolling up and it hasn't reach its destination
            } else if (!positive && el.content.scrollLeft > left) {
              // If it can still scroll our established amount then it does it, if there is less space then scrolls to the final position
              el.content.scrollLeft = (el.content.scrollLeft - left) > el._misc.smoothScroll.amount ? el.content.scrollLeft - el._misc.smoothScroll.amount : 0;
            }

            // Once it finishes sets the finished variable to true
          } else {

            finished = true;

          }

          // Keeps running the animation frame until it finishes
          if (!finished) {
            el._misc.smoothScroll.horizontal.animationFrame = requestAnimationFrame(el._misc.smoothScroll.horizontal.fn);
          } else {
            cancelAnimationFrame(el._misc.smoothScroll.horizontal.animationFrame);
          }

        };

        // Inits the requestAnimationFrame
        el._misc.smoothScroll.horizontal.animationFrame = window.requestAnimationFrame(el._misc.smoothScroll.horizontal.fn);
      },
      /*
        @function (private) _isChromeDevice
        @description Triggered when thickness has changed, updates everything according to the new one
      */
      isChromeDevice: function () {
        return eon.util.getBrowserScrollBarWidth() == 0 && eon.util.getBrowser() == "Chrome";
      },
      /*
        @function (private) _updateThickness
        @description Triggered when thickness has changed, updates everything according to the new one
      */
      updateThickness: function () {
        var el = this;

        if (el._misc.square.created) {
          el._refs.square.style.height = el._getThickness() + "px";
          el._refs.square.style.width = el._getThickness() + "px";
        }

        if (el._refs.upArrowButton) {
          el._refs.upArrowButton.style.height = el._getThickness() + "px";
          el._refs.upArrowButton.style.width = el._getThickness() + "px";
          el._refs.upArrowButton.style.fontSize = el._getThickness() + "px";
          el._refs.upArrowButton.querySelector("i").style.fontSize = el._getThickness() + "px";
        }

        if (el._refs.downArrowButton) {
          el._refs.downArrowButton.style.height = el._getThickness() + "px";
          el._refs.downArrowButton.style.width = el._getThickness() + "px";
          el._refs.downArrowButton.style.fontSize = el._getThickness() + "px";
          el._refs.downArrowButton.querySelector("i").style.fontSize = el._getThickness() + "px";
        }

        if (el._refs.leftArrowButton) {
          el._refs.leftArrowButton.style.height = el._getThickness() + "px";
          el._refs.leftArrowButton.style.width = el._getThickness() + "px";
          el._refs.leftArrowButton.style.fontSize = el._getThickness() + "px";
          el._refs.leftArrowButton.querySelector("i").style.fontSize = el._getThickness() + "px";
        }

        if (el._refs.rightArrowButton) {
          el._refs.rightArrowButton.style.height = el._getThickness() + "px";
          el._refs.rightArrowButton.style.width = el._getThickness() + "px";
          el._refs.rightArrowButton.style.fontSize = el._getThickness() + "px";
          el._refs.rightArrowButton.querySelector("i").style.fontSize = el._getThickness() + "px";
        }

        if (el._refs.verticalScroll) {
          el._refs.verticalScroll.style.width = el._getThickness() + "px";
          el._refs.verticalScroll.style.height = (el._misc.square.created && el._refs.square.classList.contains("eon-scroll-active")) ? "calc(100% - " + el._getThickness() + "px)" : "100%";
          el._refs.verticalBar.style.height = Math.ceil(parseFloat(el._refs.verticalRail.offsetHeight / (el.content.scrollHeight / el.offsetHeight))) + "px";
        }

        if (el._refs.horizontalScroll) {
          el._refs.horizontalScroll.style.height = el._getThickness() + "px";
          el._refs.horizontalScroll.style.width = (el._misc.square.created && el._refs.square.classList.contains("eon-scroll-active")) ? "calc(100% - " + el._getThickness() + "px)" : "100%";
          el._refs.horizontalBar.style.width = Math.ceil((el._refs.horizontalRail.offsetWidth / (el.content.scrollWidth / el.offsetWidth))) + "px";
        }

      },
    },
    onCreated: function () {
      var el = this;

      // Creates a callbacks for the user to use
      eon.createCallback("onScrolled", el);
      eon.createCallback("onHorizontalScrollCreated", el);
      eon.createCallback("onVerticalScrollCreated", el);
      eon.createCallback("onHorizontalStatusChange", el);
      eon.createCallback("onVerticalStatusChange", el);

      el._setupMisc();
      el._createContent();

      el._createChromeDeviceRule();
    },

    onInit: function () {
      var el = this;

      el._appendContent();
      el._assignSize();

      el._definePublicProperties();
      el._setupScrolling();
    },

    onPropertyChanged: function (key, oldVal, newVal) {
      var el = this;

      if (key == "thickness") {
        el._updateThickness();
      }
    }
  });
</script>